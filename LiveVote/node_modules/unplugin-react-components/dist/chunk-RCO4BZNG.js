var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/index.ts
import { createUnplugin } from "unplugin";
import MagicString from "magic-string";
import { createFilter } from "@rollup/pluginutils";

// src/core/utils.ts
var isExportComponent = (component) => typeof component === "string" ? component === "Export" : component.type === "Export";
var isCapitalCase = (code) => {
  const ascii = code[0].charCodeAt(0);
  return ascii >= 65 && ascii <= 90;
};
function slash(str) {
  return str.replace(/\\/g, "/");
}
function stringifyImport(info) {
  if (typeof info === "string")
    return `import '${info}'`;
  else if (info.name && info.as)
    return `import { ${info.name} as ${info.as} } from '${info.from}'`;
  else if (info.name)
    return `import { ${info.name} } from '${info.from}'`;
  else
    return `import ${info.default} from '${info.from}'`;
}
function resolveOptions(options = {}) {
  return __spreadValues({
    rootDir: options.rootDir || process.cwd(),
    dts: false,
    include: [/\.[j|t]sx$/],
    exclude: [/[\\/]node_modules[\\/]/, /[\\/]\.git[\\/]/],
    resolvers: options.resolvers || [],
    local: typeof options.local === "boolean" ? options.local : true
  }, options);
}

// src/core/resolvers.ts
var resolversType = /* @__PURE__ */ new Set();
var getResolversResult = async (resolvers) => {
  if (!resolvers)
    return;
  for (const item of resolvers) {
    const fn = await item;
    if (typeof fn === "function")
      resolversType.add(fn());
    else
      resolversType.add(fn);
  }
  return resolversType;
};

// src/core/transformer.ts
var reactDevRE = /_jsxDEV\(([^"][^React\.]\s{0,}\w+|[a-zA-Z]+|)/g;
var reactLatestDevRE = /jsxDEV\(([^"][^React\.]\s{0,}\w+|[a-zA-Z]+|)/g;
var reactBuildRE = /_jsx[s]?\(([^"][^React\.]\s{0,}\w+|[a-zA-Z]+|)/g;
var reactLatestBuildRE = /jsx[s]?\(([^"][^React\.]\s{0,}\w+|[a-zA-Z]+|)/g;
var reactComponentRE;
async function transform(options) {
  let index = 0;
  const { code, id, components, resolvers, local } = options;
  let isDevMode = true;
  let isLatestBundle = false;
  if (code.original.includes("react/jsx-dev-runtime")) {
    if (code.original.includes("_jsxDEV")) {
      reactComponentRE = reactDevRE;
    } else {
      reactComponentRE = reactLatestDevRE;
      isLatestBundle = true;
    }
  } else {
    isDevMode = false;
    if (code.original.includes("_jsx")) {
      reactComponentRE = reactBuildRE;
    } else {
      reactComponentRE = reactLatestBuildRE;
      isLatestBundle = true;
    }
  }
  const matches = Array.from(code.original.matchAll(reactComponentRE)).map((item) => ({
    name: item[1].trim(),
    path: id,
    original: item[0]
  }));
  const importsName = [];
  const imports = [];
  const resolveImports = (name, type, path, original, style) => {
    if (importsName.includes(name))
      return;
    const replacedName = `_unplugin_react_${name}_${index}`;
    index++;
    code.replaceAll(original, `${isDevMode ? isLatestBundle ? "jsxDEV" : "_jsxDEV" : isLatestBundle ? "jsx" : "_jsx"}(${replacedName}`);
    const importedPath = path;
    if (isExportComponent(type)) {
      imports.push(stringifyImport({
        name,
        as: replacedName,
        from: importedPath
      }));
    } else {
      imports.push(stringifyImport({
        default: replacedName,
        from: importedPath
      }));
    }
    if (style)
      imports.push(stringifyImport(style));
    importsName.push(name);
  };
  const resolversResult = await getResolversResult(resolvers);
  for (const matched of matches) {
    resolversResult == null ? void 0 : resolversResult.forEach((resolver) => {
      resolver.forEach((item) => {
        if (item.name === matched.name)
          resolveImports(item.originalName, item.type, item.from, matched.original, item.style);
      });
    });
    if (local) {
      const component = Array.from(components).find((item) => item.name === matched.name);
      if (!component)
        continue;
      resolveImports(component.name, component.type, component.path, matched.original);
    }
  }
  code.prepend(`${imports.join("\n")}
`);
  return code.toString();
}

// src/core/searchGlob.ts
import fs from "fs";
import { resolve } from "path";
import fg from "fast-glob";
import { parse } from "@babel/parser";
import { walk } from "estree-walker";
function searchGlob(options) {
  const { rootPath } = options;
  const files = fg.sync(["**/**.tsx", "**/**.jsx"], {
    ignore: ["node_modules"],
    cwd: rootPath
  });
  const components = /* @__PURE__ */ new Set();
  for (const file of files) {
    const code = fs.readFileSync(resolve(rootPath, file), { encoding: "utf-8" });
    const program = parse(code, {
      sourceType: "module",
      plugins: [
        "typescript",
        "jsx"
      ]
    });
    walk(program, {
      enter(nodes) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        const node = nodes;
        let name = "";
        let type = "Declaration";
        if (node.type === "VariableDeclaration" && (((_a = node.declarations[0].init) == null ? void 0 : _a.type) === "ArrowFunctionExpression" && ((_c = (_b = node.declarations[0].init) == null ? void 0 : _b.body) == null ? void 0 : _c.type) === "JSXElement")) {
          type = "Declaration";
          name = node.declarations.find((item) => item.type === "VariableDeclarator" && item.id.type === "Identifier").id.name;
        } else if (node.type === "FunctionDeclaration" && node.body.type === "BlockStatement" && node.body.body.find((item) => {
          var _a2;
          return item.type === "ReturnStatement" && ((_a2 = item.argument) == null ? void 0 : _a2.type) === "JSXElement";
        })) {
          name = ((_d = node.id) == null ? void 0 : _d.name) || "";
          type = "Declaration";
        } else if (node.type === "ExportDefaultDeclaration") {
          if (node.declaration.type === "FunctionDeclaration" && node.declaration.body.body.find((item) => {
            var _a2;
            return item.type === "ReturnStatement" && ((_a2 = item.argument) == null ? void 0 : _a2.type) === "JSXElement";
          })) {
            name = node.declaration.id.name;
            type = "ExportDefault";
          } else if (node.declaration.type === "Identifier") {
            const exportedName = (_e = node.declaration) == null ? void 0 : _e.name;
            const component = Array.from(components).find((item) => item.name === exportedName);
            if (component && component.type === "Declaration") {
              type = "ExportDefault";
              name = component.name;
            }
          }
        } else if (node.type === "ExportNamedDeclaration") {
          if (((_f = node.declaration) == null ? void 0 : _f.type) === "FunctionDeclaration" && node.declaration.body.type === "BlockStatement" && node.declaration.body.body.find((item) => {
            var _a2;
            return item.type === "ReturnStatement" && ((_a2 = item.argument) == null ? void 0 : _a2.type) === "JSXElement";
          })) {
            name = ((_g = node.declaration.id) == null ? void 0 : _g.name) || "";
            type = "Export";
          } else if (((_h = node.declaration) == null ? void 0 : _h.type) === "VariableDeclaration") {
            const declaration = node.declaration.declarations.find(
              (item) => {
                var _a2;
                return item.type === "VariableDeclarator" && ((_a2 = item.init) == null ? void 0 : _a2.type) === "ArrowFunctionExpression";
              }
            );
            if (declaration && ((_i = declaration.init) == null ? void 0 : _i.type) === "ArrowFunctionExpression" && declaration.init.body.type === "BlockStatement" && declaration.init.body.body.find((item) => {
              var _a2;
              return item.type === "ReturnStatement" && ((_a2 = item.argument) == null ? void 0 : _a2.type) === "JSXElement";
            })) {
              name = declaration.id.name;
              type = "Export";
            }
          }
        }
        if (name == null ? void 0 : name.length) {
          components.add({
            name,
            type,
            path: slash(`${rootPath}/${file}`)
          });
        }
      }
    });
  }
  return new Set(Array.from(components).filter((item) => item.type !== "Declaration"));
}

// src/core/generateDts.ts
import { writeFileSync } from "fs";
import { relative } from "path";
function stringifyComponent(rootPath, component) {
  const related = `./${relative(rootPath, component.path)}`;
  return `typeof import('${slash(related).replace(/\.[tj]sx$/, "")}')['${isExportComponent(component) ? component.name : "default"}']
`;
}
function stringifyResolver(resolver) {
  return `typeof import('${resolver.from}')['${isExportComponent(resolver.type) ? resolver.originalName : "default"}']
`;
}
async function generateDts(options) {
  const {
    components,
    rootPath = process.cwd(),
    filename = "components",
    resolvers,
    local
  } = options;
  const resolversResult = await getResolversResult(resolvers);
  let dts = "/* generated by unplugin-react-components */\nexport {}\ndeclare global{\n";
  if (local) {
    components.forEach((component) => {
      dts += `	const ${component.name}: ${stringifyComponent(rootPath, component)}`;
    });
  }
  resolversResult == null ? void 0 : resolversResult.forEach((resolver) => {
    resolver.forEach((item) => {
      dts += `	const ${item.name}: ${stringifyResolver(item)}`;
    });
  });
  writeFileSync(`${rootPath}/${filename}.d.ts`, `${dts}}`, { encoding: "utf-8" });
  return dts;
}

// src/core/resolvers/createResolver.ts
import { importModule } from "local-pkg";
function createResolver(_options) {
  return async (options = {}) => {
    let prefix;
    if (typeof options.prefix === "boolean" && options.prefix)
      prefix = "Ant";
    else if (typeof options.prefix === "string")
      prefix = options.prefix;
    const pkgs = await importModule(_options.module);
    const components = Object.keys(pkgs).filter((item) => {
      if (_options.exclude)
        return isCapitalCase(item) && _options.exclude(item);
      return isCapitalCase(item);
    }).map((item) => {
      const component = {
        name: `${typeof prefix === "string" ? prefix : ""}${item}`,
        originalName: typeof prefix === "string" ? item.replace(prefix, "") : item,
        from: _options.module,
        type: "Export"
      };
      if (_options.style)
        component.style = `${_options.module}/es/${component.originalName.toLowerCase()}/style/index.css`;
      return component;
    });
    return () => components;
  };
}

// src/core/resolvers/mui.ts
var MuiResolver = createResolver({
  module: "@mui/material",
  prefix: "Mui",
  exclude: (name) => name !== "FormLabelRoot"
});

// src/core/resolvers/antd.ts
var AntdResolver = createResolver({
  module: "antd",
  prefix: "Ant",
  style: true
});

// src/index.ts
var src_default = createUnplugin((options = {}) => {
  var _a, _b, _c;
  options = resolveOptions(options);
  const filter = createFilter(
    options.include || [/\.[j|t]sx$/],
    options.exclude || [/[\\/]node_modules[\\/]/, /[\\/]\.git[\\/]/]
  );
  const searchGlobResult = searchGlob({ rootPath: ((_a = options.dts) == null ? void 0 : _a.rootPath) || options.rootDir });
  const dtsOptions = {
    components: searchGlobResult,
    filename: ((_b = options.dts) == null ? void 0 : _b.filename) || "components",
    rootPath: ((_c = options.dts) == null ? void 0 : _c.rootPath) || options.rootDir,
    local: options.local,
    resolvers: options.resolvers
  };
  if (options.dts === true)
    generateDts(__spreadValues({}, dtsOptions));
  else if (typeof options.dts === "object")
    generateDts(__spreadValues(__spreadValues({}, dtsOptions), options.dts));
  return {
    name: "unplugin-react-components",
    transformInclude(id) {
      return filter(id);
    },
    async transform(code, id) {
      const context = {
        code: new MagicString(code),
        components: searchGlobResult,
        rootDir: options.rootDir,
        resolvers: options.resolvers,
        local: options.local,
        id
      };
      return await transform(context);
    }
  };
});

export {
  resolversType,
  getResolversResult,
  transform,
  searchGlob,
  generateDts,
  createResolver,
  MuiResolver,
  AntdResolver,
  src_default
};
