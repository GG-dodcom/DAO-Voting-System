{
  "version": 3,
  "sources": ["../../ajv/lib/compile/codegen/code.ts", "../../ajv/lib/compile/codegen/scope.ts", "../../ajv/lib/compile/codegen/index.ts", "../../ajv/lib/compile/util.ts", "../../ajv/lib/compile/names.ts", "../../ajv/lib/compile/errors.ts", "../../ajv/lib/compile/validate/boolSchema.ts", "../../ajv/lib/compile/rules.ts", "../../ajv/lib/compile/validate/applicability.ts", "../../ajv/lib/compile/validate/dataType.ts", "../../ajv/lib/compile/validate/defaults.ts", "../../ajv/lib/vocabularies/code.ts", "../../ajv/lib/compile/validate/keyword.ts", "../../ajv/lib/compile/validate/subschema.ts", "../../fast-deep-equal/index.js", "../../json-schema-traverse/index.js", "../../ajv/lib/compile/resolve.ts", "../../ajv/lib/compile/validate/index.ts", "../../ajv/lib/runtime/validation_error.ts", "../../ajv/lib/compile/ref_error.ts", "../../ajv/lib/compile/index.ts", "../../ajv/dist/refs/data.json", "../../fast-uri/lib/scopedChars.js", "../../fast-uri/lib/utils.js", "../../fast-uri/lib/schemes.js", "../../fast-uri/index.js", "../../ajv/lib/runtime/uri.ts", "../../ajv/lib/core.ts", "../../ajv/lib/vocabularies/core/id.ts", "../../ajv/lib/vocabularies/core/ref.ts", "../../ajv/lib/vocabularies/core/index.ts", "../../ajv/lib/vocabularies/validation/limitNumber.ts", "../../ajv/lib/vocabularies/validation/multipleOf.ts", "../../ajv/lib/runtime/ucs2length.ts", "../../ajv/lib/vocabularies/validation/limitLength.ts", "../../ajv/lib/vocabularies/validation/pattern.ts", "../../ajv/lib/vocabularies/validation/limitProperties.ts", "../../ajv/lib/vocabularies/validation/required.ts", "../../ajv/lib/vocabularies/validation/limitItems.ts", "../../ajv/lib/runtime/equal.ts", "../../ajv/lib/vocabularies/validation/uniqueItems.ts", "../../ajv/lib/vocabularies/validation/const.ts", "../../ajv/lib/vocabularies/validation/enum.ts", "../../ajv/lib/vocabularies/validation/index.ts", "../../ajv/lib/vocabularies/applicator/additionalItems.ts", "../../ajv/lib/vocabularies/applicator/items.ts", "../../ajv/lib/vocabularies/applicator/prefixItems.ts", "../../ajv/lib/vocabularies/applicator/items2020.ts", "../../ajv/lib/vocabularies/applicator/contains.ts", "../../ajv/lib/vocabularies/applicator/dependencies.ts", "../../ajv/lib/vocabularies/applicator/propertyNames.ts", "../../ajv/lib/vocabularies/applicator/additionalProperties.ts", "../../ajv/lib/vocabularies/applicator/properties.ts", "../../ajv/lib/vocabularies/applicator/patternProperties.ts", "../../ajv/lib/vocabularies/applicator/not.ts", "../../ajv/lib/vocabularies/applicator/anyOf.ts", "../../ajv/lib/vocabularies/applicator/oneOf.ts", "../../ajv/lib/vocabularies/applicator/allOf.ts", "../../ajv/lib/vocabularies/applicator/if.ts", "../../ajv/lib/vocabularies/applicator/thenElse.ts", "../../ajv/lib/vocabularies/applicator/index.ts", "../../ajv/lib/vocabularies/format/format.ts", "../../ajv/lib/vocabularies/format/index.ts", "../../ajv/lib/vocabularies/metadata.ts", "../../ajv/lib/vocabularies/draft7.ts", "../../ajv/lib/vocabularies/discriminator/types.ts", "../../ajv/lib/vocabularies/discriminator/index.ts", "../../ajv/dist/refs/json-schema-draft-07.json", "../../ajv/lib/ajv.ts"],
  "sourcesContent": ["// eslint-disable-next-line @typescript-eslint/no-extraneous-class\r\nexport abstract class _CodeOrName {\r\n  abstract readonly str: string\r\n  abstract readonly names: UsedNames\r\n  abstract toString(): string\r\n  abstract emptyStr(): boolean\r\n}\r\n\r\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\r\n\r\nexport class Name extends _CodeOrName {\r\n  readonly str: string\r\n  constructor(s: string) {\r\n    super()\r\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\r\n    this.str = s\r\n  }\r\n\r\n  toString(): string {\r\n    return this.str\r\n  }\r\n\r\n  emptyStr(): boolean {\r\n    return false\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    return {[this.str]: 1}\r\n  }\r\n}\r\n\r\nexport class _Code extends _CodeOrName {\r\n  readonly _items: readonly CodeItem[]\r\n  private _str?: string\r\n  private _names?: UsedNames\r\n\r\n  constructor(code: string | readonly CodeItem[]) {\r\n    super()\r\n    this._items = typeof code === \"string\" ? [code] : code\r\n  }\r\n\r\n  toString(): string {\r\n    return this.str\r\n  }\r\n\r\n  emptyStr(): boolean {\r\n    if (this._items.length > 1) return false\r\n    const item = this._items[0]\r\n    return item === \"\" || item === '\"\"'\r\n  }\r\n\r\n  get str(): string {\r\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\r\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\r\n      return names\r\n    }, {}))\r\n  }\r\n}\r\n\r\nexport type CodeItem = Name | string | number | boolean | null\r\n\r\nexport type UsedNames = Record<string, number | undefined>\r\n\r\nexport type Code = _Code | Name\r\n\r\nexport type SafeExpr = Code | number | boolean | null\r\n\r\nexport const nil = new _Code(\"\")\r\n\r\ntype CodeArg = SafeExpr | string | undefined\r\n\r\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\r\n  const code: CodeItem[] = [strs[0]]\r\n  let i = 0\r\n  while (i < args.length) {\r\n    addCodeArg(code, args[i])\r\n    code.push(strs[++i])\r\n  }\r\n  return new _Code(code)\r\n}\r\n\r\nconst plus = new _Code(\"+\")\r\n\r\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\r\n  const expr: CodeItem[] = [safeStringify(strs[0])]\r\n  let i = 0\r\n  while (i < args.length) {\r\n    expr.push(plus)\r\n    addCodeArg(expr, args[i])\r\n    expr.push(plus, safeStringify(strs[++i]))\r\n  }\r\n  optimize(expr)\r\n  return new _Code(expr)\r\n}\r\n\r\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\r\n  if (arg instanceof _Code) code.push(...arg._items)\r\n  else if (arg instanceof Name) code.push(arg)\r\n  else code.push(interpolate(arg))\r\n}\r\n\r\nfunction optimize(expr: CodeItem[]): void {\r\n  let i = 1\r\n  while (i < expr.length - 1) {\r\n    if (expr[i] === plus) {\r\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\r\n      if (res !== undefined) {\r\n        expr.splice(i - 1, 3, res)\r\n        continue\r\n      }\r\n      expr[i++] = \"+\"\r\n    }\r\n    i++\r\n  }\r\n}\r\n\r\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\r\n  if (b === '\"\"') return a\r\n  if (a === '\"\"') return b\r\n  if (typeof a == \"string\") {\r\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\r\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\r\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\r\n    return\r\n  }\r\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\r\n  return\r\n}\r\n\r\nexport function strConcat(c1: Code, c2: Code): Code {\r\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\r\n}\r\n\r\n// TODO do not allow arrays here\r\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\r\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\r\n    ? x\r\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\r\n}\r\n\r\nexport function stringify(x: unknown): Code {\r\n  return new _Code(safeStringify(x))\r\n}\r\n\r\nexport function safeStringify(x: unknown): string {\r\n  return JSON.stringify(x)\r\n    .replace(/\\u2028/g, \"\\\\u2028\")\r\n    .replace(/\\u2029/g, \"\\\\u2029\")\r\n}\r\n\r\nexport function getProperty(key: Code | string | number): Code {\r\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\r\n}\r\n\r\n//Does best effort to format the name properly\r\nexport function getEsmExportName(key: Code | string | number): Code {\r\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\r\n    return new _Code(`${key}`)\r\n  }\r\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\r\n}\r\n\r\nexport function regexpCode(rx: RegExp): Code {\r\n  return new _Code(rx.toString())\r\n}\r\n", "import {_, nil, Code, Name} from \"./code\"\r\n\r\ninterface NameGroup {\r\n  prefix: string\r\n  index: number\r\n}\r\n\r\nexport interface NameValue {\r\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\r\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\r\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\r\n}\r\n\r\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\r\n\r\nclass ValueError extends Error {\r\n  readonly value?: NameValue\r\n  constructor(name: ValueScopeName) {\r\n    super(`CodeGen: \"code\" for ${name} not defined`)\r\n    this.value = name.value\r\n  }\r\n}\r\n\r\ninterface ScopeOptions {\r\n  prefixes?: Set<string>\r\n  parent?: Scope\r\n}\r\n\r\ninterface ValueScopeOptions extends ScopeOptions {\r\n  scope: ScopeStore\r\n  es5?: boolean\r\n  lines?: boolean\r\n}\r\n\r\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\r\n\r\ntype ScopeValues = {\r\n  [Prefix in string]?: Map<unknown, ValueScopeName>\r\n}\r\n\r\nexport type ScopeValueSets = {\r\n  [Prefix in string]?: Set<ValueScopeName>\r\n}\r\n\r\nexport enum UsedValueState {\r\n  Started,\r\n  Completed,\r\n}\r\n\r\nexport type UsedScopeValues = {\r\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\r\n}\r\n\r\nexport const varKinds = {\r\n  const: new Name(\"const\"),\r\n  let: new Name(\"let\"),\r\n  var: new Name(\"var\"),\r\n}\r\n\r\nexport class Scope {\r\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\r\n  protected readonly _prefixes?: Set<string>\r\n  protected readonly _parent?: Scope\r\n\r\n  constructor({prefixes, parent}: ScopeOptions = {}) {\r\n    this._prefixes = prefixes\r\n    this._parent = parent\r\n  }\r\n\r\n  toName(nameOrPrefix: Name | string): Name {\r\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\r\n  }\r\n\r\n  name(prefix: string): Name {\r\n    return new Name(this._newName(prefix))\r\n  }\r\n\r\n  protected _newName(prefix: string): string {\r\n    const ng = this._names[prefix] || this._nameGroup(prefix)\r\n    return `${prefix}${ng.index++}`\r\n  }\r\n\r\n  private _nameGroup(prefix: string): NameGroup {\r\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\r\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\r\n    }\r\n    return (this._names[prefix] = {prefix, index: 0})\r\n  }\r\n}\r\n\r\ninterface ScopePath {\r\n  property: string\r\n  itemIndex: number\r\n}\r\n\r\nexport class ValueScopeName extends Name {\r\n  readonly prefix: string\r\n  value?: NameValue\r\n  scopePath?: Code\r\n\r\n  constructor(prefix: string, nameStr: string) {\r\n    super(nameStr)\r\n    this.prefix = prefix\r\n  }\r\n\r\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\r\n    this.value = value\r\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\r\n  }\r\n}\r\n\r\ninterface VSOptions extends ValueScopeOptions {\r\n  _n: Code\r\n}\r\n\r\nconst line = _`\\n`\r\n\r\nexport class ValueScope extends Scope {\r\n  protected readonly _values: ScopeValues = {}\r\n  protected readonly _scope: ScopeStore\r\n  readonly opts: VSOptions\r\n\r\n  constructor(opts: ValueScopeOptions) {\r\n    super(opts)\r\n    this._scope = opts.scope\r\n    this.opts = {...opts, _n: opts.lines ? line : nil}\r\n  }\r\n\r\n  get(): ScopeStore {\r\n    return this._scope\r\n  }\r\n\r\n  name(prefix: string): ValueScopeName {\r\n    return new ValueScopeName(prefix, this._newName(prefix))\r\n  }\r\n\r\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\r\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\r\n    const name = this.toName(nameOrPrefix) as ValueScopeName\r\n    const {prefix} = name\r\n    const valueKey = value.key ?? value.ref\r\n    let vs = this._values[prefix]\r\n    if (vs) {\r\n      const _name = vs.get(valueKey)\r\n      if (_name) return _name\r\n    } else {\r\n      vs = this._values[prefix] = new Map()\r\n    }\r\n    vs.set(valueKey, name)\r\n\r\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\r\n    const itemIndex = s.length\r\n    s[itemIndex] = value.ref\r\n    name.setValue(value, {property: prefix, itemIndex})\r\n    return name\r\n  }\r\n\r\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\r\n    const vs = this._values[prefix]\r\n    if (!vs) return\r\n    return vs.get(keyOrRef)\r\n  }\r\n\r\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\r\n    return this._reduceValues(values, (name: ValueScopeName) => {\r\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\r\n      return _`${scopeName}${name.scopePath}`\r\n    })\r\n  }\r\n\r\n  scopeCode(\r\n    values: ScopeValues | ScopeValueSets = this._values,\r\n    usedValues?: UsedScopeValues,\r\n    getCode?: (n: ValueScopeName) => Code | undefined\r\n  ): Code {\r\n    return this._reduceValues(\r\n      values,\r\n      (name: ValueScopeName) => {\r\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\r\n        return name.value.code\r\n      },\r\n      usedValues,\r\n      getCode\r\n    )\r\n  }\r\n\r\n  private _reduceValues(\r\n    values: ScopeValues | ScopeValueSets,\r\n    valueCode: (n: ValueScopeName) => Code | undefined,\r\n    usedValues: UsedScopeValues = {},\r\n    getCode?: (n: ValueScopeName) => Code | undefined\r\n  ): Code {\r\n    let code: Code = nil\r\n    for (const prefix in values) {\r\n      const vs = values[prefix]\r\n      if (!vs) continue\r\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\r\n      vs.forEach((name: ValueScopeName) => {\r\n        if (nameSet.has(name)) return\r\n        nameSet.set(name, UsedValueState.Started)\r\n        let c = valueCode(name)\r\n        if (c) {\r\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\r\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\r\n        } else if ((c = getCode?.(name))) {\r\n          code = _`${code}${c}${this.opts._n}`\r\n        } else {\r\n          throw new ValueError(name)\r\n        }\r\n        nameSet.set(name, UsedValueState.Completed)\r\n      })\r\n    }\r\n    return code\r\n  }\r\n}\r\n", "import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\r\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\r\nimport {Scope, varKinds} from \"./scope\"\r\n\r\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\r\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\r\n\r\n// type for expressions that can be safely inserted in code without quotes\r\nexport type SafeExpr = Code | number | boolean | null\r\n\r\n// type that is either Code of function that adds code to CodeGen instance using its methods\r\nexport type Block = Code | (() => void)\r\n\r\nexport const operators = {\r\n  GT: new _Code(\">\"),\r\n  GTE: new _Code(\">=\"),\r\n  LT: new _Code(\"<\"),\r\n  LTE: new _Code(\"<=\"),\r\n  EQ: new _Code(\"===\"),\r\n  NEQ: new _Code(\"!==\"),\r\n  NOT: new _Code(\"!\"),\r\n  OR: new _Code(\"||\"),\r\n  AND: new _Code(\"&&\"),\r\n  ADD: new _Code(\"+\"),\r\n}\r\n\r\nabstract class Node {\r\n  abstract readonly names: UsedNames\r\n\r\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\r\n    return this\r\n  }\r\n\r\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\r\n    return this\r\n  }\r\n\r\n  // get count(): number {\r\n  //   return 1\r\n  // }\r\n}\r\n\r\nclass Def extends Node {\r\n  constructor(\r\n    private readonly varKind: Name,\r\n    private readonly name: Name,\r\n    private rhs?: SafeExpr\r\n  ) {\r\n    super()\r\n  }\r\n\r\n  render({es5, _n}: CGOptions): string {\r\n    const varKind = es5 ? varKinds.var : this.varKind\r\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\r\n    return `${varKind} ${this.name}${rhs};` + _n\r\n  }\r\n\r\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\r\n    if (!names[this.name.str]) return\r\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\r\n    return this\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\r\n  }\r\n}\r\n\r\nclass Assign extends Node {\r\n  constructor(\r\n    readonly lhs: Code,\r\n    public rhs: SafeExpr,\r\n    private readonly sideEffects?: boolean\r\n  ) {\r\n    super()\r\n  }\r\n\r\n  render({_n}: CGOptions): string {\r\n    return `${this.lhs} = ${this.rhs};` + _n\r\n  }\r\n\r\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\r\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\r\n    this.rhs = optimizeExpr(this.rhs, names, constants)\r\n    return this\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\r\n    return addExprNames(names, this.rhs)\r\n  }\r\n}\r\n\r\nclass AssignOp extends Assign {\r\n  constructor(\r\n    lhs: Code,\r\n    private readonly op: Code,\r\n    rhs: SafeExpr,\r\n    sideEffects?: boolean\r\n  ) {\r\n    super(lhs, rhs, sideEffects)\r\n  }\r\n\r\n  render({_n}: CGOptions): string {\r\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\r\n  }\r\n}\r\n\r\nclass Label extends Node {\r\n  readonly names: UsedNames = {}\r\n  constructor(readonly label: Name) {\r\n    super()\r\n  }\r\n\r\n  render({_n}: CGOptions): string {\r\n    return `${this.label}:` + _n\r\n  }\r\n}\r\n\r\nclass Break extends Node {\r\n  readonly names: UsedNames = {}\r\n  constructor(readonly label?: Code) {\r\n    super()\r\n  }\r\n\r\n  render({_n}: CGOptions): string {\r\n    const label = this.label ? ` ${this.label}` : \"\"\r\n    return `break${label};` + _n\r\n  }\r\n}\r\n\r\nclass Throw extends Node {\r\n  constructor(readonly error: Code) {\r\n    super()\r\n  }\r\n\r\n  render({_n}: CGOptions): string {\r\n    return `throw ${this.error};` + _n\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    return this.error.names\r\n  }\r\n}\r\n\r\nclass AnyCode extends Node {\r\n  constructor(private code: SafeExpr) {\r\n    super()\r\n  }\r\n\r\n  render({_n}: CGOptions): string {\r\n    return `${this.code};` + _n\r\n  }\r\n\r\n  optimizeNodes(): this | undefined {\r\n    return `${this.code}` ? this : undefined\r\n  }\r\n\r\n  optimizeNames(names: UsedNames, constants: Constants): this {\r\n    this.code = optimizeExpr(this.code, names, constants)\r\n    return this\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    return this.code instanceof _CodeOrName ? this.code.names : {}\r\n  }\r\n}\r\n\r\nabstract class ParentNode extends Node {\r\n  constructor(readonly nodes: ChildNode[] = []) {\r\n    super()\r\n  }\r\n\r\n  render(opts: CGOptions): string {\r\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\r\n  }\r\n\r\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\r\n    const {nodes} = this\r\n    let i = nodes.length\r\n    while (i--) {\r\n      const n = nodes[i].optimizeNodes()\r\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\r\n      else if (n) nodes[i] = n\r\n      else nodes.splice(i, 1)\r\n    }\r\n    return nodes.length > 0 ? this : undefined\r\n  }\r\n\r\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\r\n    const {nodes} = this\r\n    let i = nodes.length\r\n    while (i--) {\r\n      // iterating backwards improves 1-pass optimization\r\n      const n = nodes[i]\r\n      if (n.optimizeNames(names, constants)) continue\r\n      subtractNames(names, n.names)\r\n      nodes.splice(i, 1)\r\n    }\r\n    return nodes.length > 0 ? this : undefined\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\r\n  }\r\n\r\n  // get count(): number {\r\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\r\n  // }\r\n}\r\n\r\nabstract class BlockNode extends ParentNode {\r\n  render(opts: CGOptions): string {\r\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\r\n  }\r\n}\r\n\r\nclass Root extends ParentNode {}\r\n\r\nclass Else extends BlockNode {\r\n  static readonly kind = \"else\"\r\n}\r\n\r\nclass If extends BlockNode {\r\n  static readonly kind = \"if\"\r\n  else?: If | Else\r\n  constructor(\r\n    private condition: Code | boolean,\r\n    nodes?: ChildNode[]\r\n  ) {\r\n    super(nodes)\r\n  }\r\n\r\n  render(opts: CGOptions): string {\r\n    let code = `if(${this.condition})` + super.render(opts)\r\n    if (this.else) code += \"else \" + this.else.render(opts)\r\n    return code\r\n  }\r\n\r\n  optimizeNodes(): If | ChildNode[] | undefined {\r\n    super.optimizeNodes()\r\n    const cond = this.condition\r\n    if (cond === true) return this.nodes // else is ignored here\r\n    let e = this.else\r\n    if (e) {\r\n      const ns = e.optimizeNodes()\r\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\r\n    }\r\n    if (e) {\r\n      if (cond === false) return e instanceof If ? e : e.nodes\r\n      if (this.nodes.length) return this\r\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\r\n    }\r\n    if (cond === false || !this.nodes.length) return undefined\r\n    return this\r\n  }\r\n\r\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\r\n    this.else = this.else?.optimizeNames(names, constants)\r\n    if (!(super.optimizeNames(names, constants) || this.else)) return\r\n    this.condition = optimizeExpr(this.condition, names, constants)\r\n    return this\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    const names = super.names\r\n    addExprNames(names, this.condition)\r\n    if (this.else) addNames(names, this.else.names)\r\n    return names\r\n  }\r\n\r\n  // get count(): number {\r\n  //   return super.count + (this.else?.count || 0)\r\n  // }\r\n}\r\n\r\nabstract class For extends BlockNode {\r\n  static readonly kind = \"for\"\r\n}\r\n\r\nclass ForLoop extends For {\r\n  constructor(private iteration: Code) {\r\n    super()\r\n  }\r\n\r\n  render(opts: CGOptions): string {\r\n    return `for(${this.iteration})` + super.render(opts)\r\n  }\r\n\r\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\r\n    if (!super.optimizeNames(names, constants)) return\r\n    this.iteration = optimizeExpr(this.iteration, names, constants)\r\n    return this\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    return addNames(super.names, this.iteration.names)\r\n  }\r\n}\r\n\r\nclass ForRange extends For {\r\n  constructor(\r\n    private readonly varKind: Name,\r\n    private readonly name: Name,\r\n    private readonly from: SafeExpr,\r\n    private readonly to: SafeExpr\r\n  ) {\r\n    super()\r\n  }\r\n\r\n  render(opts: CGOptions): string {\r\n    const varKind = opts.es5 ? varKinds.var : this.varKind\r\n    const {name, from, to} = this\r\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    const names = addExprNames(super.names, this.from)\r\n    return addExprNames(names, this.to)\r\n  }\r\n}\r\n\r\nclass ForIter extends For {\r\n  constructor(\r\n    private readonly loop: \"of\" | \"in\",\r\n    private readonly varKind: Name,\r\n    private readonly name: Name,\r\n    private iterable: Code\r\n  ) {\r\n    super()\r\n  }\r\n\r\n  render(opts: CGOptions): string {\r\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\r\n  }\r\n\r\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\r\n    if (!super.optimizeNames(names, constants)) return\r\n    this.iterable = optimizeExpr(this.iterable, names, constants)\r\n    return this\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    return addNames(super.names, this.iterable.names)\r\n  }\r\n}\r\n\r\nclass Func extends BlockNode {\r\n  static readonly kind = \"func\"\r\n  constructor(\r\n    public name: Name,\r\n    public args: Code,\r\n    public async?: boolean\r\n  ) {\r\n    super()\r\n  }\r\n\r\n  render(opts: CGOptions): string {\r\n    const _async = this.async ? \"async \" : \"\"\r\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\r\n  }\r\n}\r\n\r\nclass Return extends ParentNode {\r\n  static readonly kind = \"return\"\r\n\r\n  render(opts: CGOptions): string {\r\n    return \"return \" + super.render(opts)\r\n  }\r\n}\r\n\r\nclass Try extends BlockNode {\r\n  catch?: Catch\r\n  finally?: Finally\r\n\r\n  render(opts: CGOptions): string {\r\n    let code = \"try\" + super.render(opts)\r\n    if (this.catch) code += this.catch.render(opts)\r\n    if (this.finally) code += this.finally.render(opts)\r\n    return code\r\n  }\r\n\r\n  optimizeNodes(): this {\r\n    super.optimizeNodes()\r\n    this.catch?.optimizeNodes() as Catch | undefined\r\n    this.finally?.optimizeNodes() as Finally | undefined\r\n    return this\r\n  }\r\n\r\n  optimizeNames(names: UsedNames, constants: Constants): this {\r\n    super.optimizeNames(names, constants)\r\n    this.catch?.optimizeNames(names, constants)\r\n    this.finally?.optimizeNames(names, constants)\r\n    return this\r\n  }\r\n\r\n  get names(): UsedNames {\r\n    const names = super.names\r\n    if (this.catch) addNames(names, this.catch.names)\r\n    if (this.finally) addNames(names, this.finally.names)\r\n    return names\r\n  }\r\n\r\n  // get count(): number {\r\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\r\n  // }\r\n}\r\n\r\nclass Catch extends BlockNode {\r\n  static readonly kind = \"catch\"\r\n  constructor(readonly error: Name) {\r\n    super()\r\n  }\r\n\r\n  render(opts: CGOptions): string {\r\n    return `catch(${this.error})` + super.render(opts)\r\n  }\r\n}\r\n\r\nclass Finally extends BlockNode {\r\n  static readonly kind = \"finally\"\r\n  render(opts: CGOptions): string {\r\n    return \"finally\" + super.render(opts)\r\n  }\r\n}\r\n\r\ntype StartBlockNode = If | For | Func | Return | Try\r\n\r\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\r\n\r\ntype ChildNode = StartBlockNode | LeafNode\r\n\r\ntype EndBlockNodeType =\r\n  | typeof If\r\n  | typeof Else\r\n  | typeof For\r\n  | typeof Func\r\n  | typeof Return\r\n  | typeof Catch\r\n  | typeof Finally\r\n\r\ntype Constants = Record<string, SafeExpr | undefined>\r\n\r\nexport interface CodeGenOptions {\r\n  es5?: boolean\r\n  lines?: boolean\r\n  ownProperties?: boolean\r\n}\r\n\r\ninterface CGOptions extends CodeGenOptions {\r\n  _n: \"\\n\" | \"\"\r\n}\r\n\r\nexport class CodeGen {\r\n  readonly _scope: Scope\r\n  readonly _extScope: ValueScope\r\n  readonly _values: ScopeValueSets = {}\r\n  private readonly _nodes: ParentNode[]\r\n  private readonly _blockStarts: number[] = []\r\n  private readonly _constants: Constants = {}\r\n  private readonly opts: CGOptions\r\n\r\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\r\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\r\n    this._extScope = extScope\r\n    this._scope = new Scope({parent: extScope})\r\n    this._nodes = [new Root()]\r\n  }\r\n\r\n  toString(): string {\r\n    return this._root.render(this.opts)\r\n  }\r\n\r\n  // returns unique name in the internal scope\r\n  name(prefix: string): Name {\r\n    return this._scope.name(prefix)\r\n  }\r\n\r\n  // reserves unique name in the external scope\r\n  scopeName(prefix: string): ValueScopeName {\r\n    return this._extScope.name(prefix)\r\n  }\r\n\r\n  // reserves unique name in the external scope and assigns value to it\r\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\r\n    const name = this._extScope.value(prefixOrName, value)\r\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\r\n    vs.add(name)\r\n    return name\r\n  }\r\n\r\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\r\n    return this._extScope.getValue(prefix, keyOrRef)\r\n  }\r\n\r\n  // return code that assigns values in the external scope to the names that are used internally\r\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\r\n  scopeRefs(scopeName: Name): Code {\r\n    return this._extScope.scopeRefs(scopeName, this._values)\r\n  }\r\n\r\n  scopeCode(): Code {\r\n    return this._extScope.scopeCode(this._values)\r\n  }\r\n\r\n  private _def(\r\n    varKind: Name,\r\n    nameOrPrefix: Name | string,\r\n    rhs?: SafeExpr,\r\n    constant?: boolean\r\n  ): Name {\r\n    const name = this._scope.toName(nameOrPrefix)\r\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\r\n    this._leafNode(new Def(varKind, name, rhs))\r\n    return name\r\n  }\r\n\r\n  // `const` declaration (`var` in es5 mode)\r\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\r\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\r\n  }\r\n\r\n  // `let` declaration with optional assignment (`var` in es5 mode)\r\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\r\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\r\n  }\r\n\r\n  // `var` declaration with optional assignment\r\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\r\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\r\n  }\r\n\r\n  // assignment code\r\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\r\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\r\n  }\r\n\r\n  // `+=` code\r\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\r\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\r\n  }\r\n\r\n  // appends passed SafeExpr to code or executes Block\r\n  code(c: Block | SafeExpr): CodeGen {\r\n    if (typeof c == \"function\") c()\r\n    else if (c !== nil) this._leafNode(new AnyCode(c))\r\n    return this\r\n  }\r\n\r\n  // returns code for object literal for the passed argument list of key-value pairs\r\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\r\n    const code: CodeItem[] = [\"{\"]\r\n    for (const [key, value] of keyValues) {\r\n      if (code.length > 1) code.push(\",\")\r\n      code.push(key)\r\n      if (key !== value || this.opts.es5) {\r\n        code.push(\":\")\r\n        addCodeArg(code, value)\r\n      }\r\n    }\r\n    code.push(\"}\")\r\n    return new _Code(code)\r\n  }\r\n\r\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\r\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\r\n    this._blockNode(new If(condition))\r\n\r\n    if (thenBody && elseBody) {\r\n      this.code(thenBody).else().code(elseBody).endIf()\r\n    } else if (thenBody) {\r\n      this.code(thenBody).endIf()\r\n    } else if (elseBody) {\r\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\r\n    }\r\n    return this\r\n  }\r\n\r\n  // `else if` clause - invalid without `if` or after `else` clauses\r\n  elseIf(condition: Code | boolean): CodeGen {\r\n    return this._elseNode(new If(condition))\r\n  }\r\n\r\n  // `else` clause - only valid after `if` or `else if` clauses\r\n  else(): CodeGen {\r\n    return this._elseNode(new Else())\r\n  }\r\n\r\n  // end `if` statement (needed if gen.if was used only with condition)\r\n  endIf(): CodeGen {\r\n    return this._endBlockNode(If, Else)\r\n  }\r\n\r\n  private _for(node: For, forBody?: Block): CodeGen {\r\n    this._blockNode(node)\r\n    if (forBody) this.code(forBody).endFor()\r\n    return this\r\n  }\r\n\r\n  // a generic `for` clause (or statement if `forBody` is passed)\r\n  for(iteration: Code, forBody?: Block): CodeGen {\r\n    return this._for(new ForLoop(iteration), forBody)\r\n  }\r\n\r\n  // `for` statement for a range of values\r\n  forRange(\r\n    nameOrPrefix: Name | string,\r\n    from: SafeExpr,\r\n    to: SafeExpr,\r\n    forBody: (index: Name) => void,\r\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\r\n  ): CodeGen {\r\n    const name = this._scope.toName(nameOrPrefix)\r\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\r\n  }\r\n\r\n  // `for-of` statement (in es5 mode replace with a normal for loop)\r\n  forOf(\r\n    nameOrPrefix: Name | string,\r\n    iterable: Code,\r\n    forBody: (item: Name) => void,\r\n    varKind: Code = varKinds.const\r\n  ): CodeGen {\r\n    const name = this._scope.toName(nameOrPrefix)\r\n    if (this.opts.es5) {\r\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\r\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\r\n        this.var(name, _`${arr}[${i}]`)\r\n        forBody(name)\r\n      })\r\n    }\r\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\r\n  }\r\n\r\n  // `for-in` statement.\r\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\r\n  forIn(\r\n    nameOrPrefix: Name | string,\r\n    obj: Code,\r\n    forBody: (item: Name) => void,\r\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\r\n  ): CodeGen {\r\n    if (this.opts.ownProperties) {\r\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\r\n    }\r\n    const name = this._scope.toName(nameOrPrefix)\r\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\r\n  }\r\n\r\n  // end `for` loop\r\n  endFor(): CodeGen {\r\n    return this._endBlockNode(For)\r\n  }\r\n\r\n  // `label` statement\r\n  label(label: Name): CodeGen {\r\n    return this._leafNode(new Label(label))\r\n  }\r\n\r\n  // `break` statement\r\n  break(label?: Code): CodeGen {\r\n    return this._leafNode(new Break(label))\r\n  }\r\n\r\n  // `return` statement\r\n  return(value: Block | SafeExpr): CodeGen {\r\n    const node = new Return()\r\n    this._blockNode(node)\r\n    this.code(value)\r\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\r\n    return this._endBlockNode(Return)\r\n  }\r\n\r\n  // `try` statement\r\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\r\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\r\n    const node = new Try()\r\n    this._blockNode(node)\r\n    this.code(tryBody)\r\n    if (catchCode) {\r\n      const error = this.name(\"e\")\r\n      this._currNode = node.catch = new Catch(error)\r\n      catchCode(error)\r\n    }\r\n    if (finallyCode) {\r\n      this._currNode = node.finally = new Finally()\r\n      this.code(finallyCode)\r\n    }\r\n    return this._endBlockNode(Catch, Finally)\r\n  }\r\n\r\n  // `throw` statement\r\n  throw(error: Code): CodeGen {\r\n    return this._leafNode(new Throw(error))\r\n  }\r\n\r\n  // start self-balancing block\r\n  block(body?: Block, nodeCount?: number): CodeGen {\r\n    this._blockStarts.push(this._nodes.length)\r\n    if (body) this.code(body).endBlock(nodeCount)\r\n    return this\r\n  }\r\n\r\n  // end the current self-balancing block\r\n  endBlock(nodeCount?: number): CodeGen {\r\n    const len = this._blockStarts.pop()\r\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\r\n    const toClose = this._nodes.length - len\r\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\r\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\r\n    }\r\n    this._nodes.length = len\r\n    return this\r\n  }\r\n\r\n  // `function` heading (or definition if funcBody is passed)\r\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\r\n    this._blockNode(new Func(name, args, async))\r\n    if (funcBody) this.code(funcBody).endFunc()\r\n    return this\r\n  }\r\n\r\n  // end function definition\r\n  endFunc(): CodeGen {\r\n    return this._endBlockNode(Func)\r\n  }\r\n\r\n  optimize(n = 1): void {\r\n    while (n-- > 0) {\r\n      this._root.optimizeNodes()\r\n      this._root.optimizeNames(this._root.names, this._constants)\r\n    }\r\n  }\r\n\r\n  private _leafNode(node: LeafNode): CodeGen {\r\n    this._currNode.nodes.push(node)\r\n    return this\r\n  }\r\n\r\n  private _blockNode(node: StartBlockNode): void {\r\n    this._currNode.nodes.push(node)\r\n    this._nodes.push(node)\r\n  }\r\n\r\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\r\n    const n = this._currNode\r\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\r\n      this._nodes.pop()\r\n      return this\r\n    }\r\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\r\n  }\r\n\r\n  private _elseNode(node: If | Else): CodeGen {\r\n    const n = this._currNode\r\n    if (!(n instanceof If)) {\r\n      throw new Error('CodeGen: \"else\" without \"if\"')\r\n    }\r\n    this._currNode = n.else = node\r\n    return this\r\n  }\r\n\r\n  private get _root(): Root {\r\n    return this._nodes[0] as Root\r\n  }\r\n\r\n  private get _currNode(): ParentNode {\r\n    const ns = this._nodes\r\n    return ns[ns.length - 1]\r\n  }\r\n\r\n  private set _currNode(node: ParentNode) {\r\n    const ns = this._nodes\r\n    ns[ns.length - 1] = node\r\n  }\r\n\r\n  // get nodeCount(): number {\r\n  //   return this._root.count\r\n  // }\r\n}\r\n\r\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\r\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\r\n  return names\r\n}\r\n\r\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\r\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\r\n}\r\n\r\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\r\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\r\n  if (expr instanceof Name) return replaceName(expr)\r\n  if (!canOptimize(expr)) return expr\r\n  return new _Code(\r\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\r\n      if (c instanceof Name) c = replaceName(c)\r\n      if (c instanceof _Code) items.push(...c._items)\r\n      else items.push(c)\r\n      return items\r\n    }, [])\r\n  )\r\n\r\n  function replaceName(n: Name): SafeExpr {\r\n    const c = constants[n.str]\r\n    if (c === undefined || names[n.str] !== 1) return n\r\n    delete names[n.str]\r\n    return c\r\n  }\r\n\r\n  function canOptimize(e: SafeExpr): e is _Code {\r\n    return (\r\n      e instanceof _Code &&\r\n      e._items.some(\r\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\r\n      )\r\n    )\r\n  }\r\n}\r\n\r\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\r\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\r\n}\r\n\r\nexport function not<T extends Code | SafeExpr>(x: T): T\r\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\r\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\r\n}\r\n\r\nconst andCode = mappend(operators.AND)\r\n\r\n// boolean AND (&&) expression with the passed arguments\r\nexport function and(...args: Code[]): Code {\r\n  return args.reduce(andCode)\r\n}\r\n\r\nconst orCode = mappend(operators.OR)\r\n\r\n// boolean OR (||) expression with the passed arguments\r\nexport function or(...args: Code[]): Code {\r\n  return args.reduce(orCode)\r\n}\r\n\r\ntype MAppend = (x: Code, y: Code) => Code\r\n\r\nfunction mappend(op: Code): MAppend {\r\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\r\n}\r\n\r\nfunction par(x: Code): Code {\r\n  return x instanceof Name ? x : _`(${x})`\r\n}\r\n", "import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\r\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\r\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\r\nimport {_Code} from \"./codegen/code\"\r\nimport type {Rule, ValidationRules} from \"./rules\"\r\n\r\n// TODO refactor to use Set\r\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\r\n  const hash: {[K in T]?: true} = {}\r\n  for (const item of arr) hash[item] = true\r\n  return hash\r\n}\r\n\r\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\r\n  if (typeof schema == \"boolean\") return schema\r\n  if (Object.keys(schema).length === 0) return true\r\n  checkUnknownRules(it, schema)\r\n  return !schemaHasRules(schema, it.self.RULES.all)\r\n}\r\n\r\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\r\n  const {opts, self} = it\r\n  if (!opts.strictSchema) return\r\n  if (typeof schema === \"boolean\") return\r\n  const rules = self.RULES.keywords\r\n  for (const key in schema) {\r\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\r\n  }\r\n}\r\n\r\nexport function schemaHasRules(\r\n  schema: AnySchema,\r\n  rules: {[Key in string]?: boolean | Rule}\r\n): boolean {\r\n  if (typeof schema == \"boolean\") return !schema\r\n  for (const key in schema) if (rules[key]) return true\r\n  return false\r\n}\r\n\r\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\r\n  if (typeof schema == \"boolean\") return !schema\r\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\r\n  return false\r\n}\r\n\r\nexport function schemaRefOrVal(\r\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\r\n  schema: unknown,\r\n  keyword: string,\r\n  $data?: string | false\r\n): Code | number | boolean {\r\n  if (!$data) {\r\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\r\n    if (typeof schema == \"string\") return _`${schema}`\r\n  }\r\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\r\n}\r\n\r\nexport function unescapeFragment(str: string): string {\r\n  return unescapeJsonPointer(decodeURIComponent(str))\r\n}\r\n\r\nexport function escapeFragment(str: string | number): string {\r\n  return encodeURIComponent(escapeJsonPointer(str))\r\n}\r\n\r\nexport function escapeJsonPointer(str: string | number): string {\r\n  if (typeof str == \"number\") return `${str}`\r\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\r\n}\r\n\r\nexport function unescapeJsonPointer(str: string): string {\r\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\r\n}\r\n\r\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\r\n  if (Array.isArray(xs)) {\r\n    for (const x of xs) f(x)\r\n  } else {\r\n    f(xs)\r\n  }\r\n}\r\n\r\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\r\n\r\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\r\n  gen: CodeGen,\r\n  from: Name | T,\r\n  to: Name | Exclude<T, true> | undefined,\r\n  toName?: typeof Name\r\n) => Name | T\r\n\r\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\r\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\r\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\r\n  mergeValues: (from: T, to: Exclude<T, true>) => T\r\n  resultToName: (gen: CodeGen, res?: T) => Name\r\n}\r\n\r\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\r\n  mergeNames,\r\n  mergeToName,\r\n  mergeValues,\r\n  resultToName,\r\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\r\n  return (gen, from, to, toName) => {\r\n    const res =\r\n      to === undefined\r\n        ? from\r\n        : to instanceof Name\r\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\r\n        : from instanceof Name\r\n        ? (mergeToName(gen, to, from), from)\r\n        : mergeValues(from, to)\r\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\r\n  }\r\n}\r\n\r\ninterface MergeEvaluated {\r\n  props: MergeEvaluatedFunc<EvaluatedProperties>\r\n  items: MergeEvaluatedFunc<EvaluatedItems>\r\n}\r\n\r\nexport const mergeEvaluated: MergeEvaluated = {\r\n  props: makeMergeEvaluated({\r\n    mergeNames: (gen, from, to) =>\r\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\r\n        gen.if(\r\n          _`${from} === true`,\r\n          () => gen.assign(to, true),\r\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\r\n        )\r\n      }),\r\n    mergeToName: (gen, from, to) =>\r\n      gen.if(_`${to} !== true`, () => {\r\n        if (from === true) {\r\n          gen.assign(to, true)\r\n        } else {\r\n          gen.assign(to, _`${to} || {}`)\r\n          setEvaluated(gen, to, from)\r\n        }\r\n      }),\r\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\r\n    resultToName: evaluatedPropsToName,\r\n  }),\r\n  items: makeMergeEvaluated({\r\n    mergeNames: (gen, from, to) =>\r\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\r\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\r\n      ),\r\n    mergeToName: (gen, from, to) =>\r\n      gen.if(_`${to} !== true`, () =>\r\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\r\n      ),\r\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\r\n    resultToName: (gen, items) => gen.var(\"items\", items),\r\n  }),\r\n}\r\n\r\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\r\n  if (ps === true) return gen.var(\"props\", true)\r\n  const props = gen.var(\"props\", _`{}`)\r\n  if (ps !== undefined) setEvaluated(gen, props, ps)\r\n  return props\r\n}\r\n\r\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\r\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\r\n}\r\n\r\nconst snippets: {[S in string]?: _Code} = {}\r\n\r\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\r\n  return gen.scopeValue(\"func\", {\r\n    ref: f,\r\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\r\n  })\r\n}\r\n\r\nexport enum Type {\r\n  Num,\r\n  Str,\r\n}\r\n\r\nexport function getErrorPath(\r\n  dataProp: Name | string | number,\r\n  dataPropType?: Type,\r\n  jsPropertySyntax?: boolean\r\n): Code | string {\r\n  // let path\r\n  if (dataProp instanceof Name) {\r\n    const isNumber = dataPropType === Type.Num\r\n    return jsPropertySyntax\r\n      ? isNumber\r\n        ? _`\"[\" + ${dataProp} + \"]\"`\r\n        : _`\"['\" + ${dataProp} + \"']\"`\r\n      : isNumber\r\n      ? _`\"/\" + ${dataProp}`\r\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\r\n  }\r\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\r\n}\r\n\r\nexport function checkStrictMode(\r\n  it: SchemaCxt,\r\n  msg: string,\r\n  mode: boolean | \"log\" = it.opts.strictSchema\r\n): void {\r\n  if (!mode) return\r\n  msg = `strict mode: ${msg}`\r\n  if (mode === true) throw new Error(msg)\r\n  it.self.logger.warn(msg)\r\n}\r\n", "import {Name} from \"./codegen\"\r\n\r\nconst names = {\r\n  // validation function arguments\r\n  data: new Name(\"data\"), // data passed to validation function\r\n  // args passed from referencing schema\r\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\r\n  instancePath: new Name(\"instancePath\"),\r\n  parentData: new Name(\"parentData\"),\r\n  parentDataProperty: new Name(\"parentDataProperty\"),\r\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\r\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\r\n  // function scoped variables\r\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\r\n  errors: new Name(\"errors\"), // counter of validation errors\r\n  this: new Name(\"this\"),\r\n  // \"globals\"\r\n  self: new Name(\"self\"),\r\n  scope: new Name(\"scope\"),\r\n  // JTD serialize/parse name for JSON string and position\r\n  json: new Name(\"json\"),\r\n  jsonPos: new Name(\"jsonPos\"),\r\n  jsonLen: new Name(\"jsonLen\"),\r\n  jsonPart: new Name(\"jsonPart\"),\r\n}\r\n\r\nexport default names\r\n", "import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\r\nimport type {SchemaCxt} from \"./index\"\r\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\r\nimport {SafeExpr} from \"./codegen/code\"\r\nimport {getErrorPath, Type} from \"./util\"\r\nimport N from \"./names\"\r\n\r\nexport const keywordError: KeywordErrorDefinition = {\r\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\r\n}\r\n\r\nexport const keyword$DataError: KeywordErrorDefinition = {\r\n  message: ({keyword, schemaType}) =>\r\n    schemaType\r\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\r\n      : str`\"${keyword}\" keyword is invalid ($data)`,\r\n}\r\n\r\nexport interface ErrorPaths {\r\n  instancePath?: Code\r\n  schemaPath?: string\r\n  parentSchema?: boolean\r\n}\r\n\r\nexport function reportError(\r\n  cxt: KeywordErrorCxt,\r\n  error: KeywordErrorDefinition = keywordError,\r\n  errorPaths?: ErrorPaths,\r\n  overrideAllErrors?: boolean\r\n): void {\r\n  const {it} = cxt\r\n  const {gen, compositeRule, allErrors} = it\r\n  const errObj = errorObjectCode(cxt, error, errorPaths)\r\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\r\n    addError(gen, errObj)\r\n  } else {\r\n    returnErrors(it, _`[${errObj}]`)\r\n  }\r\n}\r\n\r\nexport function reportExtraError(\r\n  cxt: KeywordErrorCxt,\r\n  error: KeywordErrorDefinition = keywordError,\r\n  errorPaths?: ErrorPaths\r\n): void {\r\n  const {it} = cxt\r\n  const {gen, compositeRule, allErrors} = it\r\n  const errObj = errorObjectCode(cxt, error, errorPaths)\r\n  addError(gen, errObj)\r\n  if (!(compositeRule || allErrors)) {\r\n    returnErrors(it, N.vErrors)\r\n  }\r\n}\r\n\r\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\r\n  gen.assign(N.errors, errsCount)\r\n  gen.if(_`${N.vErrors} !== null`, () =>\r\n    gen.if(\r\n      errsCount,\r\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\r\n      () => gen.assign(N.vErrors, null)\r\n    )\r\n  )\r\n}\r\n\r\nexport function extendErrors({\r\n  gen,\r\n  keyword,\r\n  schemaValue,\r\n  data,\r\n  errsCount,\r\n  it,\r\n}: KeywordErrorCxt): void {\r\n  /* istanbul ignore if */\r\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\r\n  const err = gen.name(\"err\")\r\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\r\n    gen.const(err, _`${N.vErrors}[${i}]`)\r\n    gen.if(_`${err}.instancePath === undefined`, () =>\r\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\r\n    )\r\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\r\n    if (it.opts.verbose) {\r\n      gen.assign(_`${err}.schema`, schemaValue)\r\n      gen.assign(_`${err}.data`, data)\r\n    }\r\n  })\r\n}\r\n\r\nfunction addError(gen: CodeGen, errObj: Code): void {\r\n  const err = gen.const(\"err\", errObj)\r\n  gen.if(\r\n    _`${N.vErrors} === null`,\r\n    () => gen.assign(N.vErrors, _`[${err}]`),\r\n    _`${N.vErrors}.push(${err})`\r\n  )\r\n  gen.code(_`${N.errors}++`)\r\n}\r\n\r\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\r\n  const {gen, validateName, schemaEnv} = it\r\n  if (schemaEnv.$async) {\r\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\r\n  } else {\r\n    gen.assign(_`${validateName}.errors`, errs)\r\n    gen.return(false)\r\n  }\r\n}\r\n\r\nconst E = {\r\n  keyword: new Name(\"keyword\"),\r\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\r\n  params: new Name(\"params\"),\r\n  propertyName: new Name(\"propertyName\"),\r\n  message: new Name(\"message\"),\r\n  schema: new Name(\"schema\"),\r\n  parentSchema: new Name(\"parentSchema\"),\r\n}\r\n\r\nfunction errorObjectCode(\r\n  cxt: KeywordErrorCxt,\r\n  error: KeywordErrorDefinition,\r\n  errorPaths?: ErrorPaths\r\n): Code {\r\n  const {createErrors} = cxt.it\r\n  if (createErrors === false) return _`{}`\r\n  return errorObject(cxt, error, errorPaths)\r\n}\r\n\r\nfunction errorObject(\r\n  cxt: KeywordErrorCxt,\r\n  error: KeywordErrorDefinition,\r\n  errorPaths: ErrorPaths = {}\r\n): Code {\r\n  const {gen, it} = cxt\r\n  const keyValues: [Name, SafeExpr | string][] = [\r\n    errorInstancePath(it, errorPaths),\r\n    errorSchemaPath(cxt, errorPaths),\r\n  ]\r\n  extraErrorProps(cxt, error, keyValues)\r\n  return gen.object(...keyValues)\r\n}\r\n\r\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\r\n  const instPath = instancePath\r\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\r\n    : errorPath\r\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\r\n}\r\n\r\nfunction errorSchemaPath(\r\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\r\n  {schemaPath, parentSchema}: ErrorPaths\r\n): [Name, string | Code] {\r\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\r\n  if (schemaPath) {\r\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\r\n  }\r\n  return [E.schemaPath, schPath]\r\n}\r\n\r\nfunction extraErrorProps(\r\n  cxt: KeywordErrorCxt,\r\n  {params, message}: KeywordErrorDefinition,\r\n  keyValues: [Name, SafeExpr | string][]\r\n): void {\r\n  const {keyword, data, schemaValue, it} = cxt\r\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\r\n  keyValues.push(\r\n    [E.keyword, keyword],\r\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\r\n  )\r\n  if (opts.messages) {\r\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\r\n  }\r\n  if (opts.verbose) {\r\n    keyValues.push(\r\n      [E.schema, schemaValue],\r\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\r\n      [N.data, data]\r\n    )\r\n  }\r\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\r\n}\r\n", "import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\r\nimport type {SchemaCxt} from \"..\"\r\nimport {reportError} from \"../errors\"\r\nimport {_, Name} from \"../codegen\"\r\nimport N from \"../names\"\r\n\r\nconst boolError: KeywordErrorDefinition = {\r\n  message: \"boolean schema is false\",\r\n}\r\n\r\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\r\n  const {gen, schema, validateName} = it\r\n  if (schema === false) {\r\n    falseSchemaError(it, false)\r\n  } else if (typeof schema == \"object\" && schema.$async === true) {\r\n    gen.return(N.data)\r\n  } else {\r\n    gen.assign(_`${validateName}.errors`, null)\r\n    gen.return(true)\r\n  }\r\n}\r\n\r\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\r\n  const {gen, schema} = it\r\n  if (schema === false) {\r\n    gen.var(valid, false) // TODO var\r\n    falseSchemaError(it)\r\n  } else {\r\n    gen.var(valid, true) // TODO var\r\n  }\r\n}\r\n\r\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\r\n  const {gen, data} = it\r\n  // TODO maybe some other interface should be used for non-keyword validation errors...\r\n  const cxt: KeywordErrorCxt = {\r\n    gen,\r\n    keyword: \"false schema\",\r\n    data,\r\n    schema: false,\r\n    schemaCode: false,\r\n    schemaValue: false,\r\n    params: {},\r\n    it,\r\n  }\r\n  reportError(cxt, boolError, undefined, overrideAllErrors)\r\n}\r\n", "import type {AddedKeywordDefinition} from \"../types\"\r\n\r\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\r\n\r\nexport type JSONType = (typeof _jsonTypes)[number]\r\n\r\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\r\n\r\nexport function isJSONType(x: unknown): x is JSONType {\r\n  return typeof x == \"string\" && jsonTypes.has(x)\r\n}\r\n\r\ntype ValidationTypes = {\r\n  [K in JSONType]: boolean | RuleGroup | undefined\r\n}\r\n\r\nexport interface ValidationRules {\r\n  rules: RuleGroup[]\r\n  post: RuleGroup\r\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\r\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\r\n  types: ValidationTypes\r\n}\r\n\r\nexport interface RuleGroup {\r\n  type?: JSONType\r\n  rules: Rule[]\r\n}\r\n\r\n// This interface wraps KeywordDefinition because definition can have multiple keywords\r\nexport interface Rule {\r\n  keyword: string\r\n  definition: AddedKeywordDefinition\r\n}\r\n\r\nexport function getRules(): ValidationRules {\r\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\r\n    number: {type: \"number\", rules: []},\r\n    string: {type: \"string\", rules: []},\r\n    array: {type: \"array\", rules: []},\r\n    object: {type: \"object\", rules: []},\r\n  }\r\n  return {\r\n    types: {...groups, integer: true, boolean: true, null: true},\r\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\r\n    post: {rules: []},\r\n    all: {},\r\n    keywords: {},\r\n  }\r\n}\r\n", "import type {AnySchemaObject} from \"../../types\"\r\nimport type {SchemaObjCxt} from \"..\"\r\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\r\n\r\nexport function schemaHasRulesForType(\r\n  {schema, self}: SchemaObjCxt,\r\n  type: JSONType\r\n): boolean | undefined {\r\n  const group = self.RULES.types[type]\r\n  return group && group !== true && shouldUseGroup(schema, group)\r\n}\r\n\r\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\r\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\r\n}\r\n\r\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\r\n  return (\r\n    schema[rule.keyword] !== undefined ||\r\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\r\n  )\r\n}\r\n", "import type {\r\n  KeywordErrorDefinition,\r\n  KeywordErrorCxt,\r\n  ErrorObject,\r\n  AnySchemaObject,\r\n} from \"../../types\"\r\nimport type {SchemaObjCxt} from \"..\"\r\nimport {isJSONType, JSONType} from \"../rules\"\r\nimport {schemaHasRulesForType} from \"./applicability\"\r\nimport {reportError} from \"../errors\"\r\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\r\nimport {toHash, schemaRefOrVal} from \"../util\"\r\n\r\nexport enum DataType {\r\n  Correct,\r\n  Wrong,\r\n}\r\n\r\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\r\n  const types = getJSONTypes(schema.type)\r\n  const hasNull = types.includes(\"null\")\r\n  if (hasNull) {\r\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\r\n  } else {\r\n    if (!types.length && schema.nullable !== undefined) {\r\n      throw new Error('\"nullable\" cannot be used without \"type\"')\r\n    }\r\n    if (schema.nullable === true) types.push(\"null\")\r\n  }\r\n  return types\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\r\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\r\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\r\n  if (types.every(isJSONType)) return types\r\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\r\n}\r\n\r\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\r\n  const {gen, data, opts} = it\r\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\r\n  const checkTypes =\r\n    types.length > 0 &&\r\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\r\n  if (checkTypes) {\r\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\r\n    gen.if(wrongType, () => {\r\n      if (coerceTo.length) coerceData(it, types, coerceTo)\r\n      else reportTypeError(it)\r\n    })\r\n  }\r\n  return checkTypes\r\n}\r\n\r\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\r\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\r\n  return coerceTypes\r\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\r\n    : []\r\n}\r\n\r\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\r\n  const {gen, data, opts} = it\r\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\r\n  const coerced = gen.let(\"coerced\", _`undefined`)\r\n  if (opts.coerceTypes === \"array\") {\r\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\r\n      gen\r\n        .assign(data, _`${data}[0]`)\r\n        .assign(dataType, _`typeof ${data}`)\r\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\r\n    )\r\n  }\r\n  gen.if(_`${coerced} !== undefined`)\r\n  for (const t of coerceTo) {\r\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\r\n      coerceSpecificType(t)\r\n    }\r\n  }\r\n  gen.else()\r\n  reportTypeError(it)\r\n  gen.endIf()\r\n\r\n  gen.if(_`${coerced} !== undefined`, () => {\r\n    gen.assign(data, coerced)\r\n    assignParentData(it, coerced)\r\n  })\r\n\r\n  function coerceSpecificType(t: string): void {\r\n    switch (t) {\r\n      case \"string\":\r\n        gen\r\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\r\n          .assign(coerced, _`\"\" + ${data}`)\r\n          .elseIf(_`${data} === null`)\r\n          .assign(coerced, _`\"\"`)\r\n        return\r\n      case \"number\":\r\n        gen\r\n          .elseIf(\r\n            _`${dataType} == \"boolean\" || ${data} === null\r\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\r\n          )\r\n          .assign(coerced, _`+${data}`)\r\n        return\r\n      case \"integer\":\r\n        gen\r\n          .elseIf(\r\n            _`${dataType} === \"boolean\" || ${data} === null\r\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\r\n          )\r\n          .assign(coerced, _`+${data}`)\r\n        return\r\n      case \"boolean\":\r\n        gen\r\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\r\n          .assign(coerced, false)\r\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\r\n          .assign(coerced, true)\r\n        return\r\n      case \"null\":\r\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\r\n        gen.assign(coerced, null)\r\n        return\r\n\r\n      case \"array\":\r\n        gen\r\n          .elseIf(\r\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\r\n              || ${dataType} === \"boolean\" || ${data} === null`\r\n          )\r\n          .assign(coerced, _`[${data}]`)\r\n    }\r\n  }\r\n}\r\n\r\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\r\n  // TODO use gen.property\r\n  gen.if(_`${parentData} !== undefined`, () =>\r\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\r\n  )\r\n}\r\n\r\nexport function checkDataType(\r\n  dataType: JSONType,\r\n  data: Name,\r\n  strictNums?: boolean | \"log\",\r\n  correct = DataType.Correct\r\n): Code {\r\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\r\n  let cond: Code\r\n  switch (dataType) {\r\n    case \"null\":\r\n      return _`${data} ${EQ} null`\r\n    case \"array\":\r\n      cond = _`Array.isArray(${data})`\r\n      break\r\n    case \"object\":\r\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\r\n      break\r\n    case \"integer\":\r\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\r\n      break\r\n    case \"number\":\r\n      cond = numCond()\r\n      break\r\n    default:\r\n      return _`typeof ${data} ${EQ} ${dataType}`\r\n  }\r\n  return correct === DataType.Correct ? cond : not(cond)\r\n\r\n  function numCond(_cond: Code = nil): Code {\r\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\r\n  }\r\n}\r\n\r\nexport function checkDataTypes(\r\n  dataTypes: JSONType[],\r\n  data: Name,\r\n  strictNums?: boolean | \"log\",\r\n  correct?: DataType\r\n): Code {\r\n  if (dataTypes.length === 1) {\r\n    return checkDataType(dataTypes[0], data, strictNums, correct)\r\n  }\r\n  let cond: Code\r\n  const types = toHash(dataTypes)\r\n  if (types.array && types.object) {\r\n    const notObj = _`typeof ${data} != \"object\"`\r\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\r\n    delete types.null\r\n    delete types.array\r\n    delete types.object\r\n  } else {\r\n    cond = nil\r\n  }\r\n  if (types.number) delete types.integer\r\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\r\n  return cond\r\n}\r\n\r\nexport type TypeError = ErrorObject<\"type\", {type: string}>\r\n\r\nconst typeError: KeywordErrorDefinition = {\r\n  message: ({schema}) => `must be ${schema}`,\r\n  params: ({schema, schemaValue}) =>\r\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\r\n}\r\n\r\nexport function reportTypeError(it: SchemaObjCxt): void {\r\n  const cxt = getTypeErrorContext(it)\r\n  reportError(cxt, typeError)\r\n}\r\n\r\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\r\n  const {gen, data, schema} = it\r\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\r\n  return {\r\n    gen,\r\n    keyword: \"type\",\r\n    data,\r\n    schema: schema.type,\r\n    schemaCode,\r\n    schemaValue: schemaCode,\r\n    parentSchema: schema,\r\n    params: {},\r\n    it,\r\n  }\r\n}\r\n", "import type {SchemaObjCxt} from \"..\"\r\nimport {_, getProperty, stringify} from \"../codegen\"\r\nimport {checkStrictMode} from \"../util\"\r\n\r\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\r\n  const {properties, items} = it.schema\r\n  if (ty === \"object\" && properties) {\r\n    for (const key in properties) {\r\n      assignDefault(it, key, properties[key].default)\r\n    }\r\n  } else if (ty === \"array\" && Array.isArray(items)) {\r\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\r\n  }\r\n}\r\n\r\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\r\n  const {gen, compositeRule, data, opts} = it\r\n  if (defaultValue === undefined) return\r\n  const childData = _`${data}${getProperty(prop)}`\r\n  if (compositeRule) {\r\n    checkStrictMode(it, `default is ignored for: ${childData}`)\r\n    return\r\n  }\r\n\r\n  let condition = _`${childData} === undefined`\r\n  if (opts.useDefaults === \"empty\") {\r\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\r\n  }\r\n  // `${childData} === undefined` +\r\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\r\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\r\n}\r\n", "import type {AnySchema, SchemaMap} from \"../types\"\r\nimport type {SchemaCxt} from \"../compile\"\r\nimport type {KeywordCxt} from \"../compile/validate\"\r\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\r\nimport {alwaysValidSchema, Type} from \"../compile/util\"\r\nimport N from \"../compile/names\"\r\nimport {useFunc} from \"../compile/util\"\r\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\r\n  const {gen, data, it} = cxt\r\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\r\n    cxt.setParams({missingProperty: _`${prop}`}, true)\r\n    cxt.error()\r\n  })\r\n}\r\n\r\nexport function checkMissingProp(\r\n  {gen, data, it: {opts}}: KeywordCxt,\r\n  properties: string[],\r\n  missing: Name\r\n): Code {\r\n  return or(\r\n    ...properties.map((prop) =>\r\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\r\n    )\r\n  )\r\n}\r\n\r\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\r\n  cxt.setParams({missingProperty: missing}, true)\r\n  cxt.error()\r\n}\r\n\r\nexport function hasPropFunc(gen: CodeGen): Name {\r\n  return gen.scopeValue(\"func\", {\r\n    // eslint-disable-next-line @typescript-eslint/unbound-method\r\n    ref: Object.prototype.hasOwnProperty,\r\n    code: _`Object.prototype.hasOwnProperty`,\r\n  })\r\n}\r\n\r\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\r\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\r\n}\r\n\r\nexport function propertyInData(\r\n  gen: CodeGen,\r\n  data: Name,\r\n  property: Name | string,\r\n  ownProperties?: boolean\r\n): Code {\r\n  const cond = _`${data}${getProperty(property)} !== undefined`\r\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\r\n}\r\n\r\nexport function noPropertyInData(\r\n  gen: CodeGen,\r\n  data: Name,\r\n  property: Name | string,\r\n  ownProperties?: boolean\r\n): Code {\r\n  const cond = _`${data}${getProperty(property)} === undefined`\r\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\r\n}\r\n\r\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\r\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\r\n}\r\n\r\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\r\n  return allSchemaProperties(schemaMap).filter(\r\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\r\n  )\r\n}\r\n\r\nexport function callValidateCode(\r\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\r\n  func: Code,\r\n  context: Code,\r\n  passSchema?: boolean\r\n): Code {\r\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\r\n  const valCxt: [Name, Code | number][] = [\r\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\r\n    [N.parentData, it.parentData],\r\n    [N.parentDataProperty, it.parentDataProperty],\r\n    [N.rootData, N.rootData],\r\n  ]\r\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\r\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\r\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\r\n}\r\n\r\nconst newRegExp = _`new RegExp`\r\n\r\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\r\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\r\n  const {regExp} = opts.code\r\n  const rx = regExp(pattern, u)\r\n\r\n  return gen.scopeValue(\"pattern\", {\r\n    key: rx.toString(),\r\n    ref: rx,\r\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\r\n  })\r\n}\r\n\r\nexport function validateArray(cxt: KeywordCxt): Name {\r\n  const {gen, data, keyword, it} = cxt\r\n  const valid = gen.name(\"valid\")\r\n  if (it.allErrors) {\r\n    const validArr = gen.let(\"valid\", true)\r\n    validateItems(() => gen.assign(validArr, false))\r\n    return validArr\r\n  }\r\n  gen.var(valid, true)\r\n  validateItems(() => gen.break())\r\n  return valid\r\n\r\n  function validateItems(notValid: () => void): void {\r\n    const len = gen.const(\"len\", _`${data}.length`)\r\n    gen.forRange(\"i\", 0, len, (i) => {\r\n      cxt.subschema(\r\n        {\r\n          keyword,\r\n          dataProp: i,\r\n          dataPropType: Type.Num,\r\n        },\r\n        valid\r\n      )\r\n      gen.if(not(valid), notValid)\r\n    })\r\n  }\r\n}\r\n\r\nexport function validateUnion(cxt: KeywordCxt): void {\r\n  const {gen, schema, keyword, it} = cxt\r\n  /* istanbul ignore if */\r\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\r\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\r\n  if (alwaysValid && !it.opts.unevaluated) return\r\n\r\n  const valid = gen.let(\"valid\", false)\r\n  const schValid = gen.name(\"_valid\")\r\n\r\n  gen.block(() =>\r\n    schema.forEach((_sch: AnySchema, i: number) => {\r\n      const schCxt = cxt.subschema(\r\n        {\r\n          keyword,\r\n          schemaProp: i,\r\n          compositeRule: true,\r\n        },\r\n        schValid\r\n      )\r\n      gen.assign(valid, _`${valid} || ${schValid}`)\r\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\r\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\r\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\r\n      if (!merged) gen.if(not(valid))\r\n    })\r\n  )\r\n\r\n  cxt.result(\r\n    valid,\r\n    () => cxt.reset(),\r\n    () => cxt.error(true)\r\n  )\r\n}\r\n", "import type {KeywordCxt} from \".\"\r\nimport type {\r\n  AnySchema,\r\n  SchemaValidateFunction,\r\n  AnyValidateFunction,\r\n  AddedKeywordDefinition,\r\n  MacroKeywordDefinition,\r\n  FuncKeywordDefinition,\r\n} from \"../../types\"\r\nimport type {SchemaObjCxt} from \"..\"\r\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\r\nimport N from \"../names\"\r\nimport type {JSONType} from \"../rules\"\r\nimport {callValidateCode} from \"../../vocabularies/code\"\r\nimport {extendErrors} from \"../errors\"\r\n\r\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\r\n\r\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\r\n  const {gen, keyword, schema, parentSchema, it} = cxt\r\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\r\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\r\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\r\n\r\n  const valid = gen.name(\"valid\")\r\n  cxt.subschema(\r\n    {\r\n      schema: macroSchema,\r\n      schemaPath: nil,\r\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\r\n      topSchemaRef: schemaRef,\r\n      compositeRule: true,\r\n    },\r\n    valid\r\n  )\r\n  cxt.pass(valid, () => cxt.error(true))\r\n}\r\n\r\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\r\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\r\n  checkAsyncKeyword(it, def)\r\n  const validate =\r\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\r\n  const validateRef = useKeyword(gen, keyword, validate)\r\n  const valid = gen.let(\"valid\")\r\n  cxt.block$data(valid, validateKeyword)\r\n  cxt.ok(def.valid ?? valid)\r\n\r\n  function validateKeyword(): void {\r\n    if (def.errors === false) {\r\n      assignValid()\r\n      if (def.modifying) modifyData(cxt)\r\n      reportErrs(() => cxt.error())\r\n    } else {\r\n      const ruleErrs = def.async ? validateAsync() : validateSync()\r\n      if (def.modifying) modifyData(cxt)\r\n      reportErrs(() => addErrs(cxt, ruleErrs))\r\n    }\r\n  }\r\n\r\n  function validateAsync(): Name {\r\n    const ruleErrs = gen.let(\"ruleErrs\", null)\r\n    gen.try(\r\n      () => assignValid(_`await `),\r\n      (e) =>\r\n        gen.assign(valid, false).if(\r\n          _`${e} instanceof ${it.ValidationError as Name}`,\r\n          () => gen.assign(ruleErrs, _`${e}.errors`),\r\n          () => gen.throw(e)\r\n        )\r\n    )\r\n    return ruleErrs\r\n  }\r\n\r\n  function validateSync(): Code {\r\n    const validateErrs = _`${validateRef}.errors`\r\n    gen.assign(validateErrs, null)\r\n    assignValid(nil)\r\n    return validateErrs\r\n  }\r\n\r\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\r\n    const passCxt = it.opts.passContext ? N.this : N.self\r\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\r\n    gen.assign(\r\n      valid,\r\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\r\n      def.modifying\r\n    )\r\n  }\r\n\r\n  function reportErrs(errors: () => void): void {\r\n    gen.if(not(def.valid ?? valid), errors)\r\n  }\r\n}\r\n\r\nfunction modifyData(cxt: KeywordCxt): void {\r\n  const {gen, data, it} = cxt\r\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\r\n}\r\n\r\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\r\n  const {gen} = cxt\r\n  gen.if(\r\n    _`Array.isArray(${errs})`,\r\n    () => {\r\n      gen\r\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\r\n        .assign(N.errors, _`${N.vErrors}.length`)\r\n      extendErrors(cxt)\r\n    },\r\n    () => cxt.error()\r\n  )\r\n}\r\n\r\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\r\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\r\n}\r\n\r\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\r\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\r\n  return gen.scopeValue(\r\n    \"keyword\",\r\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\r\n  )\r\n}\r\n\r\nexport function validSchemaType(\r\n  schema: unknown,\r\n  schemaType: JSONType[],\r\n  allowUndefined = false\r\n): boolean {\r\n  // TODO add tests\r\n  return (\r\n    !schemaType.length ||\r\n    schemaType.some((st) =>\r\n      st === \"array\"\r\n        ? Array.isArray(schema)\r\n        : st === \"object\"\r\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\r\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\r\n    )\r\n  )\r\n}\r\n\r\nexport function validateKeywordUsage(\r\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\r\n  def: AddedKeywordDefinition,\r\n  keyword: string\r\n): void {\r\n  /* istanbul ignore if */\r\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\r\n    throw new Error(\"ajv implementation error\")\r\n  }\r\n\r\n  const deps = def.dependencies\r\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\r\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\r\n  }\r\n\r\n  if (def.validateSchema) {\r\n    const valid = def.validateSchema(schema[keyword])\r\n    if (!valid) {\r\n      const msg =\r\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\r\n        self.errorsText(def.validateSchema.errors)\r\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\r\n      else throw new Error(msg)\r\n    }\r\n  }\r\n}\r\n", "import type {AnySchema} from \"../../types\"\r\nimport type {SchemaObjCxt} from \"..\"\r\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\r\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\r\nimport type {JSONType} from \"../rules\"\r\n\r\nexport interface SubschemaContext {\r\n  // TODO use Optional? align with SchemCxt property types\r\n  schema: AnySchema\r\n  schemaPath: Code\r\n  errSchemaPath: string\r\n  topSchemaRef?: Code\r\n  errorPath?: Code\r\n  dataLevel?: number\r\n  dataTypes?: JSONType[]\r\n  data?: Name\r\n  parentData?: Name\r\n  parentDataProperty?: Code | number\r\n  dataNames?: Name[]\r\n  dataPathArr?: (Code | number)[]\r\n  propertyName?: Name\r\n  jtdDiscriminator?: string\r\n  jtdMetadata?: boolean\r\n  compositeRule?: true\r\n  createErrors?: boolean\r\n  allErrors?: boolean\r\n}\r\n\r\nexport type SubschemaArgs = Partial<{\r\n  keyword: string\r\n  schemaProp: string | number\r\n  schema: AnySchema\r\n  schemaPath: Code\r\n  errSchemaPath: string\r\n  topSchemaRef: Code\r\n  data: Name | Code\r\n  dataProp: Code | string | number\r\n  dataTypes: JSONType[]\r\n  definedProperties: Set<string>\r\n  propertyName: Name\r\n  dataPropType: Type\r\n  jtdDiscriminator: string\r\n  jtdMetadata: boolean\r\n  compositeRule: true\r\n  createErrors: boolean\r\n  allErrors: boolean\r\n}>\r\n\r\nexport function getSubschema(\r\n  it: SchemaObjCxt,\r\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\r\n): SubschemaContext {\r\n  if (keyword !== undefined && schema !== undefined) {\r\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\r\n  }\r\n\r\n  if (keyword !== undefined) {\r\n    const sch = it.schema[keyword]\r\n    return schemaProp === undefined\r\n      ? {\r\n          schema: sch,\r\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\r\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\r\n        }\r\n      : {\r\n          schema: sch[schemaProp],\r\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\r\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\r\n        }\r\n  }\r\n\r\n  if (schema !== undefined) {\r\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\r\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\r\n    }\r\n    return {\r\n      schema,\r\n      schemaPath,\r\n      topSchemaRef,\r\n      errSchemaPath,\r\n    }\r\n  }\r\n\r\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\r\n}\r\n\r\nexport function extendSubschemaData(\r\n  subschema: SubschemaContext,\r\n  it: SchemaObjCxt,\r\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\r\n): void {\r\n  if (data !== undefined && dataProp !== undefined) {\r\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\r\n  }\r\n\r\n  const {gen} = it\r\n\r\n  if (dataProp !== undefined) {\r\n    const {errorPath, dataPathArr, opts} = it\r\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\r\n    dataContextProps(nextData)\r\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\r\n    subschema.parentDataProperty = _`${dataProp}`\r\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\r\n  }\r\n\r\n  if (data !== undefined) {\r\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\r\n    dataContextProps(nextData)\r\n    if (propertyName !== undefined) subschema.propertyName = propertyName\r\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\r\n  }\r\n\r\n  if (dataTypes) subschema.dataTypes = dataTypes\r\n\r\n  function dataContextProps(_nextData: Name): void {\r\n    subschema.data = _nextData\r\n    subschema.dataLevel = it.dataLevel + 1\r\n    subschema.dataTypes = []\r\n    it.definedProperties = new Set<string>()\r\n    subschema.parentData = it.data\r\n    subschema.dataNames = [...it.dataNames, _nextData]\r\n  }\r\n}\r\n\r\nexport function extendSubschemaMode(\r\n  subschema: SubschemaContext,\r\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\r\n): void {\r\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\r\n  if (createErrors !== undefined) subschema.createErrors = createErrors\r\n  if (allErrors !== undefined) subschema.allErrors = allErrors\r\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\r\n  subschema.jtdMetadata = jtdMetadata // not inherited\r\n}\r\n", "'use strict';\r\n\r\n// do not edit .js files directly - edit src/index.jst\r\n\r\n\r\n\r\nmodule.exports = function equal(a, b) {\r\n  if (a === b) return true;\r\n\r\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\r\n    if (a.constructor !== b.constructor) return false;\r\n\r\n    var length, i, keys;\r\n    if (Array.isArray(a)) {\r\n      length = a.length;\r\n      if (length != b.length) return false;\r\n      for (i = length; i-- !== 0;)\r\n        if (!equal(a[i], b[i])) return false;\r\n      return true;\r\n    }\r\n\r\n\r\n\r\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\r\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\r\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\r\n\r\n    keys = Object.keys(a);\r\n    length = keys.length;\r\n    if (length !== Object.keys(b).length) return false;\r\n\r\n    for (i = length; i-- !== 0;)\r\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\r\n\r\n    for (i = length; i-- !== 0;) {\r\n      var key = keys[i];\r\n\r\n      if (!equal(a[key], b[key])) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // true if both NaN, false otherwise\r\n  return a!==a && b!==b;\r\n};\r\n", "'use strict';\r\n\r\nvar traverse = module.exports = function (schema, opts, cb) {\r\n  // Legacy support for v0.3.1 and earlier.\r\n  if (typeof opts == 'function') {\r\n    cb = opts;\r\n    opts = {};\r\n  }\r\n\r\n  cb = opts.cb || cb;\r\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\r\n  var post = cb.post || function() {};\r\n\r\n  _traverse(opts, pre, post, schema, '', schema);\r\n};\r\n\r\n\r\ntraverse.keywords = {\r\n  additionalItems: true,\r\n  items: true,\r\n  contains: true,\r\n  additionalProperties: true,\r\n  propertyNames: true,\r\n  not: true,\r\n  if: true,\r\n  then: true,\r\n  else: true\r\n};\r\n\r\ntraverse.arrayKeywords = {\r\n  items: true,\r\n  allOf: true,\r\n  anyOf: true,\r\n  oneOf: true\r\n};\r\n\r\ntraverse.propsKeywords = {\r\n  $defs: true,\r\n  definitions: true,\r\n  properties: true,\r\n  patternProperties: true,\r\n  dependencies: true\r\n};\r\n\r\ntraverse.skipKeywords = {\r\n  default: true,\r\n  enum: true,\r\n  const: true,\r\n  required: true,\r\n  maximum: true,\r\n  minimum: true,\r\n  exclusiveMaximum: true,\r\n  exclusiveMinimum: true,\r\n  multipleOf: true,\r\n  maxLength: true,\r\n  minLength: true,\r\n  pattern: true,\r\n  format: true,\r\n  maxItems: true,\r\n  minItems: true,\r\n  uniqueItems: true,\r\n  maxProperties: true,\r\n  minProperties: true\r\n};\r\n\r\n\r\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\r\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\r\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\r\n    for (var key in schema) {\r\n      var sch = schema[key];\r\n      if (Array.isArray(sch)) {\r\n        if (key in traverse.arrayKeywords) {\r\n          for (var i=0; i<sch.length; i++)\r\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\r\n        }\r\n      } else if (key in traverse.propsKeywords) {\r\n        if (sch && typeof sch == 'object') {\r\n          for (var prop in sch)\r\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\r\n        }\r\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\r\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\r\n      }\r\n    }\r\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\r\n  }\r\n}\r\n\r\n\r\nfunction escapeJsonPtr(str) {\r\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n}\r\n", "import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\r\nimport type Ajv from \"../ajv\"\r\nimport type {URIComponent} from \"fast-uri\"\r\nimport {eachItem} from \"./util\"\r\nimport * as equal from \"fast-deep-equal\"\r\nimport * as traverse from \"json-schema-traverse\"\r\n\r\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\r\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\r\n\r\n// TODO refactor to use keyword definitions\r\nconst SIMPLE_INLINED = new Set([\r\n  \"type\",\r\n  \"format\",\r\n  \"pattern\",\r\n  \"maxLength\",\r\n  \"minLength\",\r\n  \"maxProperties\",\r\n  \"minProperties\",\r\n  \"maxItems\",\r\n  \"minItems\",\r\n  \"maximum\",\r\n  \"minimum\",\r\n  \"uniqueItems\",\r\n  \"multipleOf\",\r\n  \"required\",\r\n  \"enum\",\r\n  \"const\",\r\n])\r\n\r\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\r\n  if (typeof schema == \"boolean\") return true\r\n  if (limit === true) return !hasRef(schema)\r\n  if (!limit) return false\r\n  return countKeys(schema) <= limit\r\n}\r\n\r\nconst REF_KEYWORDS = new Set([\r\n  \"$ref\",\r\n  \"$recursiveRef\",\r\n  \"$recursiveAnchor\",\r\n  \"$dynamicRef\",\r\n  \"$dynamicAnchor\",\r\n])\r\n\r\nfunction hasRef(schema: AnySchemaObject): boolean {\r\n  for (const key in schema) {\r\n    if (REF_KEYWORDS.has(key)) return true\r\n    const sch = schema[key]\r\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\r\n    if (typeof sch == \"object\" && hasRef(sch)) return true\r\n  }\r\n  return false\r\n}\r\n\r\nfunction countKeys(schema: AnySchemaObject): number {\r\n  let count = 0\r\n  for (const key in schema) {\r\n    if (key === \"$ref\") return Infinity\r\n    count++\r\n    if (SIMPLE_INLINED.has(key)) continue\r\n    if (typeof schema[key] == \"object\") {\r\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\r\n    }\r\n    if (count === Infinity) return Infinity\r\n  }\r\n  return count\r\n}\r\n\r\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\r\n  if (normalize !== false) id = normalizeId(id)\r\n  const p = resolver.parse(id)\r\n  return _getFullPath(resolver, p)\r\n}\r\n\r\nexport function _getFullPath(resolver: UriResolver, p: URIComponent): string {\r\n  const serialized = resolver.serialize(p)\r\n  return serialized.split(\"#\")[0] + \"#\"\r\n}\r\n\r\nconst TRAILING_SLASH_HASH = /#\\/?$/\r\nexport function normalizeId(id: string | undefined): string {\r\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\r\n}\r\n\r\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\r\n  id = normalizeId(id)\r\n  return resolver.resolve(baseId, id)\r\n}\r\n\r\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\r\n\r\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\r\n  if (typeof schema == \"boolean\") return {}\r\n  const {schemaId, uriResolver} = this.opts\r\n  const schId = normalizeId(schema[schemaId] || baseId)\r\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\r\n  const pathPrefix = getFullPath(uriResolver, schId, false)\r\n  const localRefs: LocalRefs = {}\r\n  const schemaRefs: Set<string> = new Set()\r\n\r\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\r\n    if (parentJsonPtr === undefined) return\r\n    const fullPath = pathPrefix + jsonPtr\r\n    let innerBaseId = baseIds[parentJsonPtr]\r\n    if (typeof sch[schemaId] == \"string\") innerBaseId = addRef.call(this, sch[schemaId])\r\n    addAnchor.call(this, sch.$anchor)\r\n    addAnchor.call(this, sch.$dynamicAnchor)\r\n    baseIds[jsonPtr] = innerBaseId\r\n\r\n    function addRef(this: Ajv, ref: string): string {\r\n      // eslint-disable-next-line @typescript-eslint/unbound-method\r\n      const _resolve = this.opts.uriResolver.resolve\r\n      ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref)\r\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\r\n      schemaRefs.add(ref)\r\n      let schOrRef = this.refs[ref]\r\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\r\n      if (typeof schOrRef == \"object\") {\r\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\r\n      } else if (ref !== normalizeId(fullPath)) {\r\n        if (ref[0] === \"#\") {\r\n          checkAmbiguosRef(sch, localRefs[ref], ref)\r\n          localRefs[ref] = sch\r\n        } else {\r\n          this.refs[ref] = fullPath\r\n        }\r\n      }\r\n      return ref\r\n    }\r\n\r\n    function addAnchor(this: Ajv, anchor: unknown): void {\r\n      if (typeof anchor == \"string\") {\r\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\r\n        addRef.call(this, `#${anchor}`)\r\n      }\r\n    }\r\n  })\r\n\r\n  return localRefs\r\n\r\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\r\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\r\n  }\r\n\r\n  function ambiguos(ref: string): Error {\r\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\r\n  }\r\n}\r\n", "import type {\r\n  AddedKeywordDefinition,\r\n  AnySchema,\r\n  AnySchemaObject,\r\n  KeywordErrorCxt,\r\n  KeywordCxtParams,\r\n} from \"../../types\"\r\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\r\nimport type {InstanceOptions} from \"../../core\"\r\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\r\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\r\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\r\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\r\nimport {assignDefaults} from \"./defaults\"\r\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\r\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\r\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\r\nimport N from \"../names\"\r\nimport {resolveUrl} from \"../resolve\"\r\nimport {\r\n  schemaRefOrVal,\r\n  schemaHasRulesButRef,\r\n  checkUnknownRules,\r\n  checkStrictMode,\r\n  unescapeJsonPointer,\r\n  mergeEvaluated,\r\n} from \"../util\"\r\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\r\nimport {\r\n  ErrorPaths,\r\n  reportError,\r\n  reportExtraError,\r\n  resetErrorsCount,\r\n  keyword$DataError,\r\n} from \"../errors\"\r\n\r\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\r\nexport function validateFunctionCode(it: SchemaCxt): void {\r\n  if (isSchemaObj(it)) {\r\n    checkKeywords(it)\r\n    if (schemaCxtHasRules(it)) {\r\n      topSchemaObjCode(it)\r\n      return\r\n    }\r\n  }\r\n  validateFunction(it, () => topBoolOrEmptySchema(it))\r\n}\r\n\r\nfunction validateFunction(\r\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\r\n  body: Block\r\n): void {\r\n  if (opts.code.es5) {\r\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\r\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\r\n      destructureValCxtES5(gen, opts)\r\n      gen.code(body)\r\n    })\r\n  } else {\r\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\r\n      gen.code(funcSourceUrl(schema, opts)).code(body)\r\n    )\r\n  }\r\n}\r\n\r\nfunction destructureValCxt(opts: InstanceOptions): Code {\r\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\r\n    N.data\r\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\r\n}\r\n\r\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\r\n  gen.if(\r\n    N.valCxt,\r\n    () => {\r\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\r\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\r\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\r\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\r\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\r\n    },\r\n    () => {\r\n      gen.var(N.instancePath, _`\"\"`)\r\n      gen.var(N.parentData, _`undefined`)\r\n      gen.var(N.parentDataProperty, _`undefined`)\r\n      gen.var(N.rootData, N.data)\r\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\r\n    }\r\n  )\r\n}\r\n\r\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\r\n  const {schema, opts, gen} = it\r\n  validateFunction(it, () => {\r\n    if (opts.$comment && schema.$comment) commentKeyword(it)\r\n    checkNoDefault(it)\r\n    gen.let(N.vErrors, null)\r\n    gen.let(N.errors, 0)\r\n    if (opts.unevaluated) resetEvaluated(it)\r\n    typeAndKeywords(it)\r\n    returnResults(it)\r\n  })\r\n  return\r\n}\r\n\r\nfunction resetEvaluated(it: SchemaObjCxt): void {\r\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\r\n  const {gen, validateName} = it\r\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\r\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\r\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\r\n}\r\n\r\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\r\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\r\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\r\n}\r\n\r\n// schema compilation - this function is used recursively to generate code for sub-schemas\r\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\r\n  if (isSchemaObj(it)) {\r\n    checkKeywords(it)\r\n    if (schemaCxtHasRules(it)) {\r\n      subSchemaObjCode(it, valid)\r\n      return\r\n    }\r\n  }\r\n  boolOrEmptySchema(it, valid)\r\n}\r\n\r\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\r\n  if (typeof schema == \"boolean\") return !schema\r\n  for (const key in schema) if (self.RULES.all[key]) return true\r\n  return false\r\n}\r\n\r\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\r\n  return typeof it.schema != \"boolean\"\r\n}\r\n\r\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\r\n  const {schema, gen, opts} = it\r\n  if (opts.$comment && schema.$comment) commentKeyword(it)\r\n  updateContext(it)\r\n  checkAsyncSchema(it)\r\n  const errsCount = gen.const(\"_errs\", N.errors)\r\n  typeAndKeywords(it, errsCount)\r\n  // TODO var\r\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\r\n}\r\n\r\nfunction checkKeywords(it: SchemaObjCxt): void {\r\n  checkUnknownRules(it)\r\n  checkRefsAndKeywords(it)\r\n}\r\n\r\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\r\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\r\n  const types = getSchemaTypes(it.schema)\r\n  const checkedTypes = coerceAndCheckDataType(it, types)\r\n  schemaKeywords(it, types, !checkedTypes, errsCount)\r\n}\r\n\r\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\r\n  const {schema, errSchemaPath, opts, self} = it\r\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\r\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\r\n  }\r\n}\r\n\r\nfunction checkNoDefault(it: SchemaObjCxt): void {\r\n  const {schema, opts} = it\r\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\r\n    checkStrictMode(it, \"default is ignored in the schema root\")\r\n  }\r\n}\r\n\r\nfunction updateContext(it: SchemaObjCxt): void {\r\n  const schId = it.schema[it.opts.schemaId]\r\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\r\n}\r\n\r\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\r\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\r\n}\r\n\r\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\r\n  const msg = schema.$comment\r\n  if (opts.$comment === true) {\r\n    gen.code(_`${N.self}.logger.log(${msg})`)\r\n  } else if (typeof opts.$comment == \"function\") {\r\n    const schemaPath = str`${errSchemaPath}/$comment`\r\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\r\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\r\n  }\r\n}\r\n\r\nfunction returnResults(it: SchemaCxt): void {\r\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\r\n  if (schemaEnv.$async) {\r\n    // TODO assign unevaluated\r\n    gen.if(\r\n      _`${N.errors} === 0`,\r\n      () => gen.return(N.data),\r\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\r\n    )\r\n  } else {\r\n    gen.assign(_`${validateName}.errors`, N.vErrors)\r\n    if (opts.unevaluated) assignEvaluated(it)\r\n    gen.return(_`${N.errors} === 0`)\r\n  }\r\n}\r\n\r\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\r\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\r\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\r\n}\r\n\r\nfunction schemaKeywords(\r\n  it: SchemaObjCxt,\r\n  types: JSONType[],\r\n  typeErrors: boolean,\r\n  errsCount?: Name\r\n): void {\r\n  const {gen, schema, data, allErrors, opts, self} = it\r\n  const {RULES} = self\r\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\r\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\r\n    return\r\n  }\r\n  if (!opts.jtd) checkStrictTypes(it, types)\r\n  gen.block(() => {\r\n    for (const group of RULES.rules) groupKeywords(group)\r\n    groupKeywords(RULES.post)\r\n  })\r\n\r\n  function groupKeywords(group: RuleGroup): void {\r\n    if (!shouldUseGroup(schema, group)) return\r\n    if (group.type) {\r\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\r\n      iterateKeywords(it, group)\r\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\r\n        gen.else()\r\n        reportTypeError(it)\r\n      }\r\n      gen.endIf()\r\n    } else {\r\n      iterateKeywords(it, group)\r\n    }\r\n    // TODO make it \"ok\" call?\r\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\r\n  }\r\n}\r\n\r\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\r\n  const {\r\n    gen,\r\n    schema,\r\n    opts: {useDefaults},\r\n  } = it\r\n  if (useDefaults) assignDefaults(it, group.type)\r\n  gen.block(() => {\r\n    for (const rule of group.rules) {\r\n      if (shouldUseRule(schema, rule)) {\r\n        keywordCode(it, rule.keyword, rule.definition, group.type)\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\r\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\r\n  checkContextTypes(it, types)\r\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\r\n  checkKeywordTypes(it, it.dataTypes)\r\n}\r\n\r\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\r\n  if (!types.length) return\r\n  if (!it.dataTypes.length) {\r\n    it.dataTypes = types\r\n    return\r\n  }\r\n  types.forEach((t) => {\r\n    if (!includesType(it.dataTypes, t)) {\r\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\r\n    }\r\n  })\r\n  narrowSchemaTypes(it, types)\r\n}\r\n\r\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\r\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\r\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\r\n  }\r\n}\r\n\r\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\r\n  const rules = it.self.RULES.all\r\n  for (const keyword in rules) {\r\n    const rule = rules[keyword]\r\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\r\n      const {type} = rule.definition\r\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\r\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\r\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\r\n}\r\n\r\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\r\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\r\n}\r\n\r\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\r\n  const ts: JSONType[] = []\r\n  for (const t of it.dataTypes) {\r\n    if (includesType(withTypes, t)) ts.push(t)\r\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\r\n  }\r\n  it.dataTypes = ts\r\n}\r\n\r\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\r\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\r\n  msg += ` at \"${schemaPath}\" (strictTypes)`\r\n  checkStrictMode(it, msg, it.opts.strictTypes)\r\n}\r\n\r\nexport class KeywordCxt implements KeywordErrorCxt {\r\n  readonly gen: CodeGen\r\n  readonly allErrors?: boolean\r\n  readonly keyword: string\r\n  readonly data: Name // Name referencing the current level of the data instance\r\n  readonly $data?: string | false\r\n  schema: any // keyword value in the schema\r\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\r\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\r\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\r\n  readonly parentSchema: AnySchemaObject\r\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\r\n  // requires option trackErrors in keyword definition\r\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\r\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\r\n  readonly def: AddedKeywordDefinition\r\n\r\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\r\n    validateKeywordUsage(it, def, keyword)\r\n    this.gen = it.gen\r\n    this.allErrors = it.allErrors\r\n    this.keyword = keyword\r\n    this.data = it.data\r\n    this.schema = it.schema[keyword]\r\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\r\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\r\n    this.schemaType = def.schemaType\r\n    this.parentSchema = it.schema\r\n    this.params = {}\r\n    this.it = it\r\n    this.def = def\r\n\r\n    if (this.$data) {\r\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\r\n    } else {\r\n      this.schemaCode = this.schemaValue\r\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\r\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\r\n      }\r\n    }\r\n\r\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\r\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\r\n    }\r\n  }\r\n\r\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\r\n    this.failResult(not(condition), successAction, failAction)\r\n  }\r\n\r\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\r\n    this.gen.if(condition)\r\n    if (failAction) failAction()\r\n    else this.error()\r\n    if (successAction) {\r\n      this.gen.else()\r\n      successAction()\r\n      if (this.allErrors) this.gen.endIf()\r\n    } else {\r\n      if (this.allErrors) this.gen.endIf()\r\n      else this.gen.else()\r\n    }\r\n  }\r\n\r\n  pass(condition: Code, failAction?: () => void): void {\r\n    this.failResult(not(condition), undefined, failAction)\r\n  }\r\n\r\n  fail(condition?: Code): void {\r\n    if (condition === undefined) {\r\n      this.error()\r\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\r\n      return\r\n    }\r\n    this.gen.if(condition)\r\n    this.error()\r\n    if (this.allErrors) this.gen.endIf()\r\n    else this.gen.else()\r\n  }\r\n\r\n  fail$data(condition: Code): void {\r\n    if (!this.$data) return this.fail(condition)\r\n    const {schemaCode} = this\r\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\r\n  }\r\n\r\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\r\n    if (errorParams) {\r\n      this.setParams(errorParams)\r\n      this._error(append, errorPaths)\r\n      this.setParams({})\r\n      return\r\n    }\r\n    this._error(append, errorPaths)\r\n  }\r\n\r\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\r\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\r\n  }\r\n\r\n  $dataError(): void {\r\n    reportError(this, this.def.$dataError || keyword$DataError)\r\n  }\r\n\r\n  reset(): void {\r\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\r\n    resetErrorsCount(this.gen, this.errsCount)\r\n  }\r\n\r\n  ok(cond: Code | boolean): void {\r\n    if (!this.allErrors) this.gen.if(cond)\r\n  }\r\n\r\n  setParams(obj: KeywordCxtParams, assign?: true): void {\r\n    if (assign) Object.assign(this.params, obj)\r\n    else this.params = obj\r\n  }\r\n\r\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\r\n    this.gen.block(() => {\r\n      this.check$data(valid, $dataValid)\r\n      codeBlock()\r\n    })\r\n  }\r\n\r\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\r\n    if (!this.$data) return\r\n    const {gen, schemaCode, schemaType, def} = this\r\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\r\n    if (valid !== nil) gen.assign(valid, true)\r\n    if (schemaType.length || def.validateSchema) {\r\n      gen.elseIf(this.invalid$data())\r\n      this.$dataError()\r\n      if (valid !== nil) gen.assign(valid, false)\r\n    }\r\n    gen.else()\r\n  }\r\n\r\n  invalid$data(): Code {\r\n    const {gen, schemaCode, schemaType, def, it} = this\r\n    return or(wrong$DataType(), invalid$DataSchema())\r\n\r\n    function wrong$DataType(): Code {\r\n      if (schemaType.length) {\r\n        /* istanbul ignore if */\r\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\r\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\r\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\r\n      }\r\n      return nil\r\n    }\r\n\r\n    function invalid$DataSchema(): Code {\r\n      if (def.validateSchema) {\r\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\r\n        return _`!${validateSchemaRef}(${schemaCode})`\r\n      }\r\n      return nil\r\n    }\r\n  }\r\n\r\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\r\n    const subschema = getSubschema(this.it, appl)\r\n    extendSubschemaData(subschema, this.it, appl)\r\n    extendSubschemaMode(subschema, appl)\r\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\r\n    subschemaCode(nextContext, valid)\r\n    return nextContext\r\n  }\r\n\r\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\r\n    const {it, gen} = this\r\n    if (!it.opts.unevaluated) return\r\n    if (it.props !== true && schemaCxt.props !== undefined) {\r\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\r\n    }\r\n    if (it.items !== true && schemaCxt.items !== undefined) {\r\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\r\n    }\r\n  }\r\n\r\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\r\n    const {it, gen} = this\r\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\r\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\r\n      return true\r\n    }\r\n  }\r\n}\r\n\r\nfunction keywordCode(\r\n  it: SchemaObjCxt,\r\n  keyword: string,\r\n  def: AddedKeywordDefinition,\r\n  ruleType?: JSONType\r\n): void {\r\n  const cxt = new KeywordCxt(it, def, keyword)\r\n  if (\"code\" in def) {\r\n    def.code(cxt, ruleType)\r\n  } else if (cxt.$data && def.validate) {\r\n    funcKeywordCode(cxt, def)\r\n  } else if (\"macro\" in def) {\r\n    macroKeywordCode(cxt, def)\r\n  } else if (def.compile || def.validate) {\r\n    funcKeywordCode(cxt, def)\r\n  }\r\n}\r\n\r\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\r\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\r\nexport function getData(\r\n  $data: string,\r\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\r\n): Code | number {\r\n  let jsonPointer\r\n  let data: Code\r\n  if ($data === \"\") return N.rootData\r\n  if ($data[0] === \"/\") {\r\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\r\n    jsonPointer = $data\r\n    data = N.rootData\r\n  } else {\r\n    const matches = RELATIVE_JSON_POINTER.exec($data)\r\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\r\n    const up: number = +matches[1]\r\n    jsonPointer = matches[2]\r\n    if (jsonPointer === \"#\") {\r\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\r\n      return dataPathArr[dataLevel - up]\r\n    }\r\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\r\n    data = dataNames[dataLevel - up]\r\n    if (!jsonPointer) return data\r\n  }\r\n\r\n  let expr = data\r\n  const segments = jsonPointer.split(\"/\")\r\n  for (const segment of segments) {\r\n    if (segment) {\r\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\r\n      expr = _`${expr} && ${data}`\r\n    }\r\n  }\r\n  return expr\r\n\r\n  function errorMsg(pointerType: string, up: number): string {\r\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\r\n  }\r\n}\r\n", "import type {ErrorObject} from \"../types\"\r\n\r\nexport default class ValidationError extends Error {\r\n  readonly errors: Partial<ErrorObject>[]\r\n  readonly ajv: true\r\n  readonly validation: true\r\n\r\n  constructor(errors: Partial<ErrorObject>[]) {\r\n    super(\"validation failed\")\r\n    this.errors = errors\r\n    this.ajv = this.validation = true\r\n  }\r\n}\r\n", "import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\r\nimport type {UriResolver} from \"../types\"\r\n\r\nexport default class MissingRefError extends Error {\r\n  readonly missingRef: string\r\n  readonly missingSchema: string\r\n\r\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\r\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\r\n    this.missingRef = resolveUrl(resolver, baseId, ref)\r\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\r\n  }\r\n}\r\n", "import type {\r\n  AnySchema,\r\n  AnySchemaObject,\r\n  AnyValidateFunction,\r\n  AsyncValidateFunction,\r\n  EvaluatedProperties,\r\n  EvaluatedItems,\r\n} from \"../types\"\r\nimport type Ajv from \"../core\"\r\nimport type {InstanceOptions} from \"../core\"\r\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\r\nimport ValidationError from \"../runtime/validation_error\"\r\nimport N from \"./names\"\r\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\r\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\r\nimport {validateFunctionCode} from \"./validate\"\r\nimport {URIComponent} from \"fast-uri\"\r\nimport {JSONType} from \"./rules\"\r\n\r\nexport type SchemaRefs = {\r\n  [Ref in string]?: SchemaEnv | AnySchema\r\n}\r\n\r\nexport interface SchemaCxt {\r\n  readonly gen: CodeGen\r\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\r\n  readonly data: Name // Name with reference to the current part of data instance\r\n  readonly parentData: Name // should be used in keywords modifying data\r\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\r\n  readonly dataNames: Name[]\r\n  readonly dataPathArr: (Code | number)[]\r\n  readonly dataLevel: number // the level of the currently validated data,\r\n  // it can be used to access both the property names and the data on all levels from the top.\r\n  dataTypes: JSONType[] // data types applied to the current part of data instance\r\n  definedProperties: Set<string> // set of properties to keep track of for required checks\r\n  readonly topSchemaRef: Code\r\n  readonly validateName: Name\r\n  evaluated?: Name\r\n  readonly ValidationError?: Name\r\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\r\n  readonly schemaEnv: SchemaEnv\r\n  readonly rootId: string\r\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\r\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\r\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\r\n  readonly errorPath: Code\r\n  readonly propertyName?: Name\r\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\r\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\r\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\r\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\r\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\r\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\r\n  jtdDiscriminator?: string\r\n  jtdMetadata?: boolean\r\n  readonly createErrors?: boolean\r\n  readonly opts: InstanceOptions // Ajv instance option.\r\n  readonly self: Ajv // current Ajv instance\r\n}\r\n\r\nexport interface SchemaObjCxt extends SchemaCxt {\r\n  readonly schema: AnySchemaObject\r\n}\r\ninterface SchemaEnvArgs {\r\n  readonly schema: AnySchema\r\n  readonly schemaId?: \"$id\" | \"id\"\r\n  readonly root?: SchemaEnv\r\n  readonly baseId?: string\r\n  readonly schemaPath?: string\r\n  readonly localRefs?: LocalRefs\r\n  readonly meta?: boolean\r\n}\r\n\r\nexport class SchemaEnv implements SchemaEnvArgs {\r\n  readonly schema: AnySchema\r\n  readonly schemaId?: \"$id\" | \"id\"\r\n  readonly root: SchemaEnv\r\n  baseId: string // TODO possibly, it should be readonly\r\n  schemaPath?: string\r\n  localRefs?: LocalRefs\r\n  readonly meta?: boolean\r\n  readonly $async?: boolean // true if the current schema is asynchronous.\r\n  readonly refs: SchemaRefs = {}\r\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\r\n  validate?: AnyValidateFunction\r\n  validateName?: ValueScopeName\r\n  serialize?: (data: unknown) => string\r\n  serializeName?: ValueScopeName\r\n  parse?: (data: string) => unknown\r\n  parseName?: ValueScopeName\r\n\r\n  constructor(env: SchemaEnvArgs) {\r\n    let schema: AnySchemaObject | undefined\r\n    if (typeof env.schema == \"object\") schema = env.schema\r\n    this.schema = env.schema\r\n    this.schemaId = env.schemaId\r\n    this.root = env.root || this\r\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\r\n    this.schemaPath = env.schemaPath\r\n    this.localRefs = env.localRefs\r\n    this.meta = env.meta\r\n    this.$async = schema?.$async\r\n    this.refs = {}\r\n  }\r\n}\r\n\r\n// let codeSize = 0\r\n// let nodeCount = 0\r\n\r\n// Compiles schema in SchemaEnv\r\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\r\n  // TODO refactor - remove compilations\r\n  const _sch = getCompilingSchema.call(this, sch)\r\n  if (_sch) return _sch\r\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\r\n  const {es5, lines} = this.opts.code\r\n  const {ownProperties} = this.opts\r\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\r\n  let _ValidationError\r\n  if (sch.$async) {\r\n    _ValidationError = gen.scopeValue(\"Error\", {\r\n      ref: ValidationError,\r\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\r\n    })\r\n  }\r\n\r\n  const validateName = gen.scopeName(\"validate\")\r\n  sch.validateName = validateName\r\n\r\n  const schemaCxt: SchemaCxt = {\r\n    gen,\r\n    allErrors: this.opts.allErrors,\r\n    data: N.data,\r\n    parentData: N.parentData,\r\n    parentDataProperty: N.parentDataProperty,\r\n    dataNames: [N.data],\r\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\r\n    dataLevel: 0,\r\n    dataTypes: [],\r\n    definedProperties: new Set<string>(),\r\n    topSchemaRef: gen.scopeValue(\r\n      \"schema\",\r\n      this.opts.code.source === true\r\n        ? {ref: sch.schema, code: stringify(sch.schema)}\r\n        : {ref: sch.schema}\r\n    ),\r\n    validateName,\r\n    ValidationError: _ValidationError,\r\n    schema: sch.schema,\r\n    schemaEnv: sch,\r\n    rootId,\r\n    baseId: sch.baseId || rootId,\r\n    schemaPath: nil,\r\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\r\n    errorPath: _`\"\"`,\r\n    opts: this.opts,\r\n    self: this,\r\n  }\r\n\r\n  let sourceCode: string | undefined\r\n  try {\r\n    this._compilations.add(sch)\r\n    validateFunctionCode(schemaCxt)\r\n    gen.optimize(this.opts.code.optimize)\r\n    // gen.optimize(1)\r\n    const validateCode = gen.toString()\r\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\r\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\r\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\r\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\r\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\r\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\r\n    this.scope.value(validateName, {ref: validate})\r\n\r\n    validate.errors = null\r\n    validate.schema = sch.schema\r\n    validate.schemaEnv = sch\r\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\r\n    if (this.opts.code.source === true) {\r\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\r\n    }\r\n    if (this.opts.unevaluated) {\r\n      const {props, items} = schemaCxt\r\n      validate.evaluated = {\r\n        props: props instanceof Name ? undefined : props,\r\n        items: items instanceof Name ? undefined : items,\r\n        dynamicProps: props instanceof Name,\r\n        dynamicItems: items instanceof Name,\r\n      }\r\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\r\n    }\r\n    sch.validate = validate\r\n    return sch\r\n  } catch (e) {\r\n    delete sch.validate\r\n    delete sch.validateName\r\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\r\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\r\n    throw e\r\n  } finally {\r\n    this._compilations.delete(sch)\r\n  }\r\n}\r\n\r\nexport function resolveRef(\r\n  this: Ajv,\r\n  root: SchemaEnv,\r\n  baseId: string,\r\n  ref: string\r\n): AnySchema | SchemaEnv | undefined {\r\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\r\n  const schOrFunc = root.refs[ref]\r\n  if (schOrFunc) return schOrFunc\r\n\r\n  let _sch = resolve.call(this, root, ref)\r\n  if (_sch === undefined) {\r\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\r\n    const {schemaId} = this.opts\r\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\r\n  }\r\n\r\n  if (_sch === undefined) return\r\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\r\n}\r\n\r\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\r\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\r\n  return sch.validate ? sch : compileSchema.call(this, sch)\r\n}\r\n\r\n// Index of schema compilation in the currently compiled list\r\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\r\n  for (const sch of this._compilations) {\r\n    if (sameSchemaEnv(sch, schEnv)) return sch\r\n  }\r\n}\r\n\r\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\r\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\r\n}\r\n\r\n// resolve and compile the references ($ref)\r\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\r\nfunction resolve(\r\n  this: Ajv,\r\n  root: SchemaEnv, // information about the root schema for the current schema\r\n  ref: string // reference to resolve\r\n): SchemaEnv | undefined {\r\n  let sch\r\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\r\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\r\n}\r\n\r\n// Resolve schema, its root and baseId\r\nexport function resolveSchema(\r\n  this: Ajv,\r\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\r\n  ref: string // reference to resolve\r\n): SchemaEnv | undefined {\r\n  const p = this.opts.uriResolver.parse(ref)\r\n  const refPath = _getFullPath(this.opts.uriResolver, p)\r\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\r\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\r\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\r\n    return getJsonPointer.call(this, p, root)\r\n  }\r\n\r\n  const id = normalizeId(refPath)\r\n  const schOrRef = this.refs[id] || this.schemas[id]\r\n  if (typeof schOrRef == \"string\") {\r\n    const sch = resolveSchema.call(this, root, schOrRef)\r\n    if (typeof sch?.schema !== \"object\") return\r\n    return getJsonPointer.call(this, p, sch)\r\n  }\r\n\r\n  if (typeof schOrRef?.schema !== \"object\") return\r\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\r\n  if (id === normalizeId(ref)) {\r\n    const {schema} = schOrRef\r\n    const {schemaId} = this.opts\r\n    const schId = schema[schemaId]\r\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\r\n    return new SchemaEnv({schema, schemaId, root, baseId})\r\n  }\r\n  return getJsonPointer.call(this, p, schOrRef)\r\n}\r\n\r\nconst PREVENT_SCOPE_CHANGE = new Set([\r\n  \"properties\",\r\n  \"patternProperties\",\r\n  \"enum\",\r\n  \"dependencies\",\r\n  \"definitions\",\r\n])\r\n\r\nfunction getJsonPointer(\r\n  this: Ajv,\r\n  parsedRef: URIComponent,\r\n  {baseId, schema, root}: SchemaEnv\r\n): SchemaEnv | undefined {\r\n  if (parsedRef.fragment?.[0] !== \"/\") return\r\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\r\n    if (typeof schema === \"boolean\") return\r\n    const partSchema = schema[unescapeFragment(part)]\r\n    if (partSchema === undefined) return\r\n    schema = partSchema\r\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\r\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\r\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\r\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\r\n    }\r\n  }\r\n  let env: SchemaEnv | undefined\r\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\r\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\r\n    env = resolveSchema.call(this, root, $ref)\r\n  }\r\n  // even though resolution failed we need to return SchemaEnv to throw exception\r\n  // so that compileAsync loads missing schema.\r\n  const {schemaId} = this.opts\r\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\r\n  if (env.schema !== env.root.schema) return env\r\n  return undefined\r\n}\r\n", "{\r\n  \"$id\": \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\r\n  \"description\": \"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\r\n  \"type\": \"object\",\r\n  \"required\": [\"$data\"],\r\n  \"properties\": {\r\n    \"$data\": {\r\n      \"type\": \"string\",\r\n      \"anyOf\": [{\"format\": \"relative-json-pointer\"}, {\"format\": \"json-pointer\"}]\r\n    }\r\n  },\r\n  \"additionalProperties\": false\r\n}\r\n", "'use strict'\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n", "'use strict'\n\nconst { HEX } = require('./scopedChars')\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host, opts = {}) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components, options) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false })\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n", "'use strict'\n\nconst UUID_REG = /^[\\da-f]{8}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n", "'use strict'\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require('./lib/utils')\nconst SCHEMES = require('./lib/schemes')\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components, options)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false })\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path !== undefined && parsed.path.length) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment !== undefined && parsed.fragment.length) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n", "import * as uri from \"fast-uri\"\r\n\r\ntype URI = typeof uri & {code: string}\r\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\r\n\r\nexport default uri as URI\r\n", "export {\r\n  Format,\r\n  FormatDefinition,\r\n  AsyncFormatDefinition,\r\n  KeywordDefinition,\r\n  KeywordErrorDefinition,\r\n  CodeKeywordDefinition,\r\n  MacroKeywordDefinition,\r\n  FuncKeywordDefinition,\r\n  Vocabulary,\r\n  Schema,\r\n  SchemaObject,\r\n  AnySchemaObject,\r\n  AsyncSchema,\r\n  AnySchema,\r\n  ValidateFunction,\r\n  AsyncValidateFunction,\r\n  AnyValidateFunction,\r\n  ErrorObject,\r\n  ErrorNoParams,\r\n} from \"./types\"\r\n\r\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\r\nexport interface Plugin<Opts> {\r\n  (ajv: Ajv, options?: Opts): Ajv\r\n  [prop: string]: any\r\n}\r\n\r\nexport {KeywordCxt} from \"./compile/validate\"\r\nexport {DefinedError} from \"./vocabularies/errors\"\r\nexport {JSONType} from \"./compile/rules\"\r\nexport {JSONSchemaType} from \"./types/json-schema\"\r\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\r\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\r\n\r\nimport type {\r\n  Schema,\r\n  AnySchema,\r\n  AnySchemaObject,\r\n  SchemaObject,\r\n  AsyncSchema,\r\n  Vocabulary,\r\n  KeywordDefinition,\r\n  AddedKeywordDefinition,\r\n  AnyValidateFunction,\r\n  ValidateFunction,\r\n  AsyncValidateFunction,\r\n  ErrorObject,\r\n  Format,\r\n  AddedFormat,\r\n  RegExpEngine,\r\n  UriResolver,\r\n} from \"./types\"\r\nimport type {JSONSchemaType} from \"./types/json-schema\"\r\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\r\nimport ValidationError from \"./runtime/validation_error\"\r\nimport MissingRefError from \"./compile/ref_error\"\r\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\r\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\r\nimport {Code, ValueScope} from \"./compile/codegen\"\r\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\r\nimport {getJSONTypes} from \"./compile/validate/dataType\"\r\nimport {eachItem} from \"./compile/util\"\r\nimport * as $dataRefSchema from \"./refs/data.json\"\r\n\r\nimport DefaultUriResolver from \"./runtime/uri\"\r\n\r\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\r\ndefaultRegExp.code = \"new RegExp\"\r\n\r\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\r\nconst EXT_SCOPE_NAMES = new Set([\r\n  \"validate\",\r\n  \"serialize\",\r\n  \"parse\",\r\n  \"wrapper\",\r\n  \"root\",\r\n  \"schema\",\r\n  \"keyword\",\r\n  \"pattern\",\r\n  \"formats\",\r\n  \"validate$data\",\r\n  \"func\",\r\n  \"obj\",\r\n  \"Error\",\r\n])\r\n\r\nexport type Options = CurrentOptions & DeprecatedOptions\r\n\r\nexport interface CurrentOptions {\r\n  // strict mode options (NEW)\r\n  strict?: boolean | \"log\"\r\n  strictSchema?: boolean | \"log\"\r\n  strictNumbers?: boolean | \"log\"\r\n  strictTypes?: boolean | \"log\"\r\n  strictTuples?: boolean | \"log\"\r\n  strictRequired?: boolean | \"log\"\r\n  allowMatchingProperties?: boolean // disables a strict mode restriction\r\n  allowUnionTypes?: boolean\r\n  validateFormats?: boolean\r\n  // validation and reporting options:\r\n  $data?: boolean\r\n  allErrors?: boolean\r\n  verbose?: boolean\r\n  discriminator?: boolean\r\n  unicodeRegExp?: boolean\r\n  timestamp?: \"string\" | \"date\" // JTD only\r\n  parseDate?: boolean // JTD only\r\n  allowDate?: boolean // JTD only\r\n  $comment?:\r\n    | true\r\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\r\n  formats?: {[Name in string]?: Format}\r\n  keywords?: Vocabulary\r\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\r\n  logger?: Logger | false\r\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\r\n  // options to modify validated data:\r\n  removeAdditional?: boolean | \"all\" | \"failing\"\r\n  useDefaults?: boolean | \"empty\"\r\n  coerceTypes?: boolean | \"array\"\r\n  // advanced options:\r\n  next?: boolean // NEW\r\n  unevaluated?: boolean // NEW\r\n  dynamicRef?: boolean // NEW\r\n  schemaId?: \"id\" | \"$id\"\r\n  jtd?: boolean // NEW\r\n  meta?: SchemaObject | boolean\r\n  defaultMeta?: string | AnySchemaObject\r\n  validateSchema?: boolean | \"log\"\r\n  addUsedSchema?: boolean\r\n  inlineRefs?: boolean | number\r\n  passContext?: boolean\r\n  loopRequired?: number\r\n  loopEnum?: number // NEW\r\n  ownProperties?: boolean\r\n  multipleOfPrecision?: number\r\n  int32range?: boolean // JTD only\r\n  messages?: boolean\r\n  code?: CodeOptions // NEW\r\n  uriResolver?: UriResolver\r\n}\r\n\r\nexport interface CodeOptions {\r\n  es5?: boolean\r\n  esm?: boolean\r\n  lines?: boolean\r\n  optimize?: boolean | number\r\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\r\n  source?: boolean\r\n  process?: (code: string, schema?: SchemaEnv) => string\r\n  regExp?: RegExpEngine\r\n}\r\n\r\ninterface InstanceCodeOptions extends CodeOptions {\r\n  regExp: RegExpEngine\r\n  optimize: number\r\n}\r\n\r\ninterface DeprecatedOptions {\r\n  /** @deprecated */\r\n  ignoreKeywordsWithRef?: boolean\r\n  /** @deprecated */\r\n  jsPropertySyntax?: boolean // added instead of jsonPointers\r\n  /** @deprecated */\r\n  unicode?: boolean\r\n}\r\n\r\ninterface RemovedOptions {\r\n  format?: boolean\r\n  errorDataPath?: \"object\" | \"property\"\r\n  nullable?: boolean // \"nullable\" keyword is supported by default\r\n  jsonPointers?: boolean\r\n  extendRefs?: true | \"ignore\" | \"fail\"\r\n  missingRefs?: true | \"ignore\" | \"fail\"\r\n  processCode?: (code: string, schema?: SchemaEnv) => string\r\n  sourceCode?: boolean\r\n  strictDefaults?: boolean\r\n  strictKeywords?: boolean\r\n  uniqueItems?: boolean\r\n  unknownFormats?: true | string[] | \"ignore\"\r\n  cache?: any\r\n  serialize?: (schema: AnySchema) => unknown\r\n  ajvErrors?: boolean\r\n}\r\n\r\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\r\n  [K in keyof T]-?: string | undefined\r\n}\r\n\r\nconst removedOptions: OptionsInfo<RemovedOptions> = {\r\n  errorDataPath: \"\",\r\n  format: \"`validateFormats: false` can be used instead.\",\r\n  nullable: '\"nullable\" keyword is supported by default.',\r\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\r\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\r\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\r\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\r\n  sourceCode: \"Use option `code: {source: true}`\",\r\n  strictDefaults: \"It is default now, see option `strict`.\",\r\n  strictKeywords: \"It is default now, see option `strict`.\",\r\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\r\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\r\n  cache: \"Map is used as cache, schema object as key.\",\r\n  serialize: \"Map is used as cache, schema object as key.\",\r\n  ajvErrors: \"It is default now.\",\r\n}\r\n\r\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\r\n  ignoreKeywordsWithRef: \"\",\r\n  jsPropertySyntax: \"\",\r\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\r\n}\r\n\r\ntype RequiredInstanceOptions = {\r\n  [K in\r\n    | \"strictSchema\"\r\n    | \"strictNumbers\"\r\n    | \"strictTypes\"\r\n    | \"strictTuples\"\r\n    | \"strictRequired\"\r\n    | \"inlineRefs\"\r\n    | \"loopRequired\"\r\n    | \"loopEnum\"\r\n    | \"meta\"\r\n    | \"messages\"\r\n    | \"schemaId\"\r\n    | \"addUsedSchema\"\r\n    | \"validateSchema\"\r\n    | \"validateFormats\"\r\n    | \"int32range\"\r\n    | \"unicodeRegExp\"\r\n    | \"uriResolver\"]: NonNullable<Options[K]>\r\n} & {code: InstanceCodeOptions}\r\n\r\nexport type InstanceOptions = Options & RequiredInstanceOptions\r\n\r\nconst MAX_EXPRESSION = 200\r\n\r\n// eslint-disable-next-line complexity\r\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\r\n  const s = o.strict\r\n  const _optz = o.code?.optimize\r\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\r\n  const regExp = o.code?.regExp ?? defaultRegExp\r\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\r\n  return {\r\n    strictSchema: o.strictSchema ?? s ?? true,\r\n    strictNumbers: o.strictNumbers ?? s ?? true,\r\n    strictTypes: o.strictTypes ?? s ?? \"log\",\r\n    strictTuples: o.strictTuples ?? s ?? \"log\",\r\n    strictRequired: o.strictRequired ?? s ?? false,\r\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\r\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\r\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\r\n    meta: o.meta ?? true,\r\n    messages: o.messages ?? true,\r\n    inlineRefs: o.inlineRefs ?? true,\r\n    schemaId: o.schemaId ?? \"$id\",\r\n    addUsedSchema: o.addUsedSchema ?? true,\r\n    validateSchema: o.validateSchema ?? true,\r\n    validateFormats: o.validateFormats ?? true,\r\n    unicodeRegExp: o.unicodeRegExp ?? true,\r\n    int32range: o.int32range ?? true,\r\n    uriResolver: uriResolver,\r\n  }\r\n}\r\n\r\nexport interface Logger {\r\n  log(...args: unknown[]): unknown\r\n  warn(...args: unknown[]): unknown\r\n  error(...args: unknown[]): unknown\r\n}\r\n\r\nexport default class Ajv {\r\n  opts: InstanceOptions\r\n  errors?: ErrorObject[] | null // errors from the last validation\r\n  logger: Logger\r\n  // shared external scope values for compiled functions\r\n  readonly scope: ValueScope\r\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\r\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\r\n  readonly formats: {[Name in string]?: AddedFormat} = {}\r\n  readonly RULES: ValidationRules\r\n  readonly _compilations: Set<SchemaEnv> = new Set()\r\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\r\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\r\n  private readonly _metaOpts: InstanceOptions\r\n\r\n  static ValidationError = ValidationError\r\n  static MissingRefError = MissingRefError\r\n\r\n  constructor(opts: Options = {}) {\r\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\r\n    const {es5, lines} = this.opts.code\r\n\r\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\r\n    this.logger = getLogger(opts.logger)\r\n    const formatOpt = opts.validateFormats\r\n    opts.validateFormats = false\r\n\r\n    this.RULES = getRules()\r\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\r\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\r\n    this._metaOpts = getMetaSchemaOptions.call(this)\r\n\r\n    if (opts.formats) addInitialFormats.call(this)\r\n    this._addVocabularies()\r\n    this._addDefaultMetaSchema()\r\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\r\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\r\n    addInitialSchemas.call(this)\r\n    opts.validateFormats = formatOpt\r\n  }\r\n\r\n  _addVocabularies(): void {\r\n    this.addKeyword(\"$async\")\r\n  }\r\n\r\n  _addDefaultMetaSchema(): void {\r\n    const {$data, meta, schemaId} = this.opts\r\n    let _dataRefSchema: SchemaObject = $dataRefSchema\r\n    if (schemaId === \"id\") {\r\n      _dataRefSchema = {...$dataRefSchema}\r\n      _dataRefSchema.id = _dataRefSchema.$id\r\n      delete _dataRefSchema.$id\r\n    }\r\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\r\n  }\r\n\r\n  defaultMeta(): string | AnySchemaObject | undefined {\r\n    const {meta, schemaId} = this.opts\r\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\r\n  }\r\n\r\n  // Validate data using schema\r\n  // AnySchema will be compiled and cached using schema itself as a key for Map\r\n  validate(schema: Schema | string, data: unknown): boolean\r\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\r\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\r\n  // Separated for type inference to work\r\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\r\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\r\n  // This overload is only intended for typescript inference, the first\r\n  // argument prevents manual type annotation from matching this overload\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  validate<N extends never, T extends SomeJTDSchemaType>(\r\n    schema: T,\r\n    data: unknown\r\n  ): data is JTDDataType<T>\r\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\r\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\r\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\r\n  validate<T>(\r\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\r\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\r\n    data: unknown | T // to be validated\r\n  ): boolean | Promise<T> {\r\n    let v: AnyValidateFunction | undefined\r\n    if (typeof schemaKeyRef == \"string\") {\r\n      v = this.getSchema<T>(schemaKeyRef)\r\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\r\n    } else {\r\n      v = this.compile<T>(schemaKeyRef)\r\n    }\r\n\r\n    const valid = v(data)\r\n    if (!(\"$async\" in v)) this.errors = v.errors\r\n    return valid\r\n  }\r\n\r\n  // Create validation function for passed schema\r\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\r\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\r\n  // Separated for type inference to work\r\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\r\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\r\n  // This overload is only intended for typescript inference, the first\r\n  // argument prevents manual type annotation from matching this overload\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  compile<N extends never, T extends SomeJTDSchemaType>(\r\n    schema: T,\r\n    _meta?: boolean\r\n  ): ValidateFunction<JTDDataType<T>>\r\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\r\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\r\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\r\n    const sch = this._addSchema(schema, _meta)\r\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\r\n  }\r\n\r\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\r\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\r\n  // TODO allow passing schema URI\r\n  // meta - optional true to compile meta-schema\r\n  compileAsync<T = unknown>(\r\n    schema: SchemaObject | JSONSchemaType<T>,\r\n    _meta?: boolean\r\n  ): Promise<ValidateFunction<T>>\r\n  // Separated for type inference to work\r\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\r\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\r\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\r\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\r\n  compileAsync<T = unknown>(\r\n    schema: AnySchemaObject,\r\n    meta?: boolean\r\n  ): Promise<AnyValidateFunction<T>>\r\n  compileAsync<T = unknown>(\r\n    schema: AnySchemaObject,\r\n    meta?: boolean\r\n  ): Promise<AnyValidateFunction<T>> {\r\n    if (typeof this.opts.loadSchema != \"function\") {\r\n      throw new Error(\"options.loadSchema should be a function\")\r\n    }\r\n    const {loadSchema} = this.opts\r\n    return runCompileAsync.call(this, schema, meta)\r\n\r\n    async function runCompileAsync(\r\n      this: Ajv,\r\n      _schema: AnySchemaObject,\r\n      _meta?: boolean\r\n    ): Promise<AnyValidateFunction> {\r\n      await loadMetaSchema.call(this, _schema.$schema)\r\n      const sch = this._addSchema(_schema, _meta)\r\n      return sch.validate || _compileAsync.call(this, sch)\r\n    }\r\n\r\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\r\n      if ($ref && !this.getSchema($ref)) {\r\n        await runCompileAsync.call(this, {$ref}, true)\r\n      }\r\n    }\r\n\r\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\r\n      try {\r\n        return this._compileSchemaEnv(sch)\r\n      } catch (e) {\r\n        if (!(e instanceof MissingRefError)) throw e\r\n        checkLoaded.call(this, e)\r\n        await loadMissingSchema.call(this, e.missingSchema)\r\n        return _compileAsync.call(this, sch)\r\n      }\r\n    }\r\n\r\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\r\n      if (this.refs[ref]) {\r\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\r\n      }\r\n    }\r\n\r\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\r\n      const _schema = await _loadSchema.call(this, ref)\r\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\r\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\r\n    }\r\n\r\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\r\n      const p = this._loading[ref]\r\n      if (p) return p\r\n      try {\r\n        return await (this._loading[ref] = loadSchema(ref))\r\n      } finally {\r\n        delete this._loading[ref]\r\n      }\r\n    }\r\n  }\r\n\r\n  // Adds schema to the instance\r\n  addSchema(\r\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\r\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\r\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\r\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\r\n  ): Ajv {\r\n    if (Array.isArray(schema)) {\r\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\r\n      return this\r\n    }\r\n    let id: string | undefined\r\n    if (typeof schema === \"object\") {\r\n      const {schemaId} = this.opts\r\n      id = schema[schemaId]\r\n      if (id !== undefined && typeof id != \"string\") {\r\n        throw new Error(`schema ${schemaId} must be string`)\r\n      }\r\n    }\r\n    key = normalizeId(key || id)\r\n    this._checkUnique(key)\r\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\r\n    return this\r\n  }\r\n\r\n  // Add schema that will be used to validate other schemas\r\n  // options in META_IGNORE_OPTIONS are alway set to false\r\n  addMetaSchema(\r\n    schema: AnySchemaObject,\r\n    key?: string, // schema key\r\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\r\n  ): Ajv {\r\n    this.addSchema(schema, key, true, _validateSchema)\r\n    return this\r\n  }\r\n\r\n  //  Validate schema against its meta-schema\r\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\r\n    if (typeof schema == \"boolean\") return true\r\n    let $schema: string | AnySchemaObject | undefined\r\n    $schema = schema.$schema\r\n    if ($schema !== undefined && typeof $schema != \"string\") {\r\n      throw new Error(\"$schema must be a string\")\r\n    }\r\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\r\n    if (!$schema) {\r\n      this.logger.warn(\"meta-schema not available\")\r\n      this.errors = null\r\n      return true\r\n    }\r\n    const valid = this.validate($schema, schema)\r\n    if (!valid && throwOrLogError) {\r\n      const message = \"schema is invalid: \" + this.errorsText()\r\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\r\n      else throw new Error(message)\r\n    }\r\n    return valid\r\n  }\r\n\r\n  // Get compiled schema by `key` or `ref`.\r\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\r\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\r\n    let sch\r\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\r\n    if (sch === undefined) {\r\n      const {schemaId} = this.opts\r\n      const root = new SchemaEnv({schema: {}, schemaId})\r\n      sch = resolveSchema.call(this, root, keyRef)\r\n      if (!sch) return\r\n      this.refs[keyRef] = sch\r\n    }\r\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\r\n  }\r\n\r\n  // Remove cached schema(s).\r\n  // If no parameter is passed all schemas but meta-schemas are removed.\r\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\r\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\r\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\r\n    if (schemaKeyRef instanceof RegExp) {\r\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\r\n      this._removeAllSchemas(this.refs, schemaKeyRef)\r\n      return this\r\n    }\r\n    switch (typeof schemaKeyRef) {\r\n      case \"undefined\":\r\n        this._removeAllSchemas(this.schemas)\r\n        this._removeAllSchemas(this.refs)\r\n        this._cache.clear()\r\n        return this\r\n      case \"string\": {\r\n        const sch = getSchEnv.call(this, schemaKeyRef)\r\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\r\n        delete this.schemas[schemaKeyRef]\r\n        delete this.refs[schemaKeyRef]\r\n        return this\r\n      }\r\n      case \"object\": {\r\n        const cacheKey = schemaKeyRef\r\n        this._cache.delete(cacheKey)\r\n        let id = schemaKeyRef[this.opts.schemaId]\r\n        if (id) {\r\n          id = normalizeId(id)\r\n          delete this.schemas[id]\r\n          delete this.refs[id]\r\n        }\r\n        return this\r\n      }\r\n      default:\r\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\r\n    }\r\n  }\r\n\r\n  // add \"vocabulary\" - a collection of keywords\r\n  addVocabulary(definitions: Vocabulary): Ajv {\r\n    for (const def of definitions) this.addKeyword(def)\r\n    return this\r\n  }\r\n\r\n  addKeyword(\r\n    kwdOrDef: string | KeywordDefinition,\r\n    def?: KeywordDefinition // deprecated\r\n  ): Ajv {\r\n    let keyword: string | string[]\r\n    if (typeof kwdOrDef == \"string\") {\r\n      keyword = kwdOrDef\r\n      if (typeof def == \"object\") {\r\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\r\n        def.keyword = keyword\r\n      }\r\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\r\n      def = kwdOrDef\r\n      keyword = def.keyword\r\n      if (Array.isArray(keyword) && !keyword.length) {\r\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\r\n      }\r\n    } else {\r\n      throw new Error(\"invalid addKeywords parameters\")\r\n    }\r\n\r\n    checkKeyword.call(this, keyword, def)\r\n    if (!def) {\r\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\r\n      return this\r\n    }\r\n    keywordMetaschema.call(this, def)\r\n    const definition: AddedKeywordDefinition = {\r\n      ...def,\r\n      type: getJSONTypes(def.type),\r\n      schemaType: getJSONTypes(def.schemaType),\r\n    }\r\n    eachItem(\r\n      keyword,\r\n      definition.type.length === 0\r\n        ? (k) => addRule.call(this, k, definition)\r\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\r\n    )\r\n    return this\r\n  }\r\n\r\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\r\n    const rule = this.RULES.all[keyword]\r\n    return typeof rule == \"object\" ? rule.definition : !!rule\r\n  }\r\n\r\n  // Remove keyword\r\n  removeKeyword(keyword: string): Ajv {\r\n    // TODO return type should be Ajv\r\n    const {RULES} = this\r\n    delete RULES.keywords[keyword]\r\n    delete RULES.all[keyword]\r\n    for (const group of RULES.rules) {\r\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\r\n      if (i >= 0) group.rules.splice(i, 1)\r\n    }\r\n    return this\r\n  }\r\n\r\n  // Add format\r\n  addFormat(name: string, format: Format): Ajv {\r\n    if (typeof format == \"string\") format = new RegExp(format)\r\n    this.formats[name] = format\r\n    return this\r\n  }\r\n\r\n  errorsText(\r\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\r\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\r\n  ): string {\r\n    if (!errors || errors.length === 0) return \"No errors\"\r\n    return errors\r\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\r\n      .reduce((text, msg) => text + separator + msg)\r\n  }\r\n\r\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\r\n    const rules = this.RULES.all\r\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\r\n    for (const jsonPointer of keywordsJsonPointers) {\r\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\r\n      let keywords = metaSchema\r\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\r\n\r\n      for (const key in rules) {\r\n        const rule = rules[key]\r\n        if (typeof rule != \"object\") continue\r\n        const {$data} = rule.definition\r\n        const schema = keywords[key] as AnySchemaObject | undefined\r\n        if ($data && schema) keywords[key] = schemaOrData(schema)\r\n      }\r\n    }\r\n\r\n    return metaSchema\r\n  }\r\n\r\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\r\n    for (const keyRef in schemas) {\r\n      const sch = schemas[keyRef]\r\n      if (!regex || regex.test(keyRef)) {\r\n        if (typeof sch == \"string\") {\r\n          delete schemas[keyRef]\r\n        } else if (sch && !sch.meta) {\r\n          this._cache.delete(sch.schema)\r\n          delete schemas[keyRef]\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _addSchema(\r\n    schema: AnySchema,\r\n    meta?: boolean,\r\n    baseId?: string,\r\n    validateSchema = this.opts.validateSchema,\r\n    addSchema = this.opts.addUsedSchema\r\n  ): SchemaEnv {\r\n    let id: string | undefined\r\n    const {schemaId} = this.opts\r\n    if (typeof schema == \"object\") {\r\n      id = schema[schemaId]\r\n    } else {\r\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\r\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\r\n    }\r\n    let sch = this._cache.get(schema)\r\n    if (sch !== undefined) return sch\r\n\r\n    baseId = normalizeId(id || baseId)\r\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\r\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\r\n    this._cache.set(sch.schema, sch)\r\n    if (addSchema && !baseId.startsWith(\"#\")) {\r\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\r\n      if (baseId) this._checkUnique(baseId)\r\n      this.refs[baseId] = sch\r\n    }\r\n    if (validateSchema) this.validateSchema(schema, true)\r\n    return sch\r\n  }\r\n\r\n  private _checkUnique(id: string): void {\r\n    if (this.schemas[id] || this.refs[id]) {\r\n      throw new Error(`schema with key or id \"${id}\" already exists`)\r\n    }\r\n  }\r\n\r\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\r\n    if (sch.meta) this._compileMetaSchema(sch)\r\n    else compileSchema.call(this, sch)\r\n\r\n    /* istanbul ignore if */\r\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\r\n    return sch.validate\r\n  }\r\n\r\n  private _compileMetaSchema(sch: SchemaEnv): void {\r\n    const currentOpts = this.opts\r\n    this.opts = this._metaOpts\r\n    try {\r\n      compileSchema.call(this, sch)\r\n    } finally {\r\n      this.opts = currentOpts\r\n    }\r\n  }\r\n}\r\n\r\nexport interface ErrorsTextOptions {\r\n  separator?: string\r\n  dataVar?: string\r\n}\r\n\r\nfunction checkOptions(\r\n  this: Ajv,\r\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\r\n  options: Options & RemovedOptions,\r\n  msg: string,\r\n  log: \"warn\" | \"error\" = \"error\"\r\n): void {\r\n  for (const key in checkOpts) {\r\n    const opt = key as keyof typeof checkOpts\r\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\r\n  }\r\n}\r\n\r\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\r\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\r\n  return this.schemas[keyRef] || this.refs[keyRef]\r\n}\r\n\r\nfunction addInitialSchemas(this: Ajv): void {\r\n  const optsSchemas = this.opts.schemas\r\n  if (!optsSchemas) return\r\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\r\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\r\n}\r\n\r\nfunction addInitialFormats(this: Ajv): void {\r\n  for (const name in this.opts.formats) {\r\n    const format = this.opts.formats[name]\r\n    if (format) this.addFormat(name, format)\r\n  }\r\n}\r\n\r\nfunction addInitialKeywords(\r\n  this: Ajv,\r\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\r\n): void {\r\n  if (Array.isArray(defs)) {\r\n    this.addVocabulary(defs)\r\n    return\r\n  }\r\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\r\n  for (const keyword in defs) {\r\n    const def = defs[keyword] as KeywordDefinition\r\n    if (!def.keyword) def.keyword = keyword\r\n    this.addKeyword(def)\r\n  }\r\n}\r\n\r\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\r\n  const metaOpts = {...this.opts}\r\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\r\n  return metaOpts\r\n}\r\n\r\nconst noLogs = {log() {}, warn() {}, error() {}}\r\n\r\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\r\n  if (logger === false) return noLogs\r\n  if (logger === undefined) return console\r\n  if (logger.log && logger.warn && logger.error) return logger as Logger\r\n  throw new Error(\"logger must implement log, warn and error methods\")\r\n}\r\n\r\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\r\n\r\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\r\n  const {RULES} = this\r\n  eachItem(keyword, (kwd) => {\r\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\r\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\r\n  })\r\n  if (!def) return\r\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\r\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\r\n  }\r\n}\r\n\r\nfunction addRule(\r\n  this: Ajv,\r\n  keyword: string,\r\n  definition?: AddedKeywordDefinition,\r\n  dataType?: JSONType\r\n): void {\r\n  const post = definition?.post\r\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\r\n  const {RULES} = this\r\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\r\n  if (!ruleGroup) {\r\n    ruleGroup = {type: dataType, rules: []}\r\n    RULES.rules.push(ruleGroup)\r\n  }\r\n  RULES.keywords[keyword] = true\r\n  if (!definition) return\r\n\r\n  const rule: Rule = {\r\n    keyword,\r\n    definition: {\r\n      ...definition,\r\n      type: getJSONTypes(definition.type),\r\n      schemaType: getJSONTypes(definition.schemaType),\r\n    },\r\n  }\r\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\r\n  else ruleGroup.rules.push(rule)\r\n  RULES.all[keyword] = rule\r\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\r\n}\r\n\r\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\r\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\r\n  if (i >= 0) {\r\n    ruleGroup.rules.splice(i, 0, rule)\r\n  } else {\r\n    ruleGroup.rules.push(rule)\r\n    this.logger.warn(`rule ${before} is not defined`)\r\n  }\r\n}\r\n\r\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\r\n  let {metaSchema} = def\r\n  if (metaSchema === undefined) return\r\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\r\n  def.validateSchema = this.compile(metaSchema, true)\r\n}\r\n\r\nconst $dataRef = {\r\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\r\n}\r\n\r\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\r\n  return {anyOf: [schema, $dataRef]}\r\n}\r\n", "import type {CodeKeywordDefinition} from \"../../types\"\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"id\",\r\n  code() {\r\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport MissingRefError from \"../../compile/ref_error\"\r\nimport {callValidateCode} from \"../code\"\r\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\r\nimport N from \"../../compile/names\"\r\nimport {SchemaEnv, resolveRef} from \"../../compile\"\r\nimport {mergeEvaluated} from \"../../compile/util\"\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"$ref\",\r\n  schemaType: \"string\",\r\n  code(cxt: KeywordCxt): void {\r\n    const {gen, schema: $ref, it} = cxt\r\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\r\n    const {root} = env\r\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\r\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\r\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\r\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\r\n    return inlineRefSchema(schOrEnv)\r\n\r\n    function callRootRef(): void {\r\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\r\n      const rootName = gen.scopeValue(\"root\", {ref: root})\r\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\r\n    }\r\n\r\n    function callValidate(sch: SchemaEnv): void {\r\n      const v = getValidate(cxt, sch)\r\n      callRef(cxt, v, sch, sch.$async)\r\n    }\r\n\r\n    function inlineRefSchema(sch: AnySchema): void {\r\n      const schName = gen.scopeValue(\r\n        \"schema\",\r\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\r\n      )\r\n      const valid = gen.name(\"valid\")\r\n      const schCxt = cxt.subschema(\r\n        {\r\n          schema: sch,\r\n          dataTypes: [],\r\n          schemaPath: nil,\r\n          topSchemaRef: schName,\r\n          errSchemaPath: $ref,\r\n        },\r\n        valid\r\n      )\r\n      cxt.mergeEvaluated(schCxt)\r\n      cxt.ok(valid)\r\n    }\r\n  },\r\n}\r\n\r\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\r\n  const {gen} = cxt\r\n  return sch.validate\r\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\r\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\r\n}\r\n\r\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\r\n  const {gen, it} = cxt\r\n  const {allErrors, schemaEnv: env, opts} = it\r\n  const passCxt = opts.passContext ? N.this : nil\r\n  if ($async) callAsyncRef()\r\n  else callSyncRef()\r\n\r\n  function callAsyncRef(): void {\r\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\r\n    const valid = gen.let(\"valid\")\r\n    gen.try(\r\n      () => {\r\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\r\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\r\n        if (!allErrors) gen.assign(valid, true)\r\n      },\r\n      (e) => {\r\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\r\n        addErrorsFrom(e)\r\n        if (!allErrors) gen.assign(valid, false)\r\n      }\r\n    )\r\n    cxt.ok(valid)\r\n  }\r\n\r\n  function callSyncRef(): void {\r\n    cxt.result(\r\n      callValidateCode(cxt, v, passCxt),\r\n      () => addEvaluatedFrom(v),\r\n      () => addErrorsFrom(v)\r\n    )\r\n  }\r\n\r\n  function addErrorsFrom(source: Code): void {\r\n    const errs = _`${source}.errors`\r\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\r\n    gen.assign(N.errors, _`${N.vErrors}.length`)\r\n  }\r\n\r\n  function addEvaluatedFrom(source: Code): void {\r\n    if (!it.opts.unevaluated) return\r\n    const schEvaluated = sch?.validate?.evaluated\r\n    // TODO refactor\r\n    if (it.props !== true) {\r\n      if (schEvaluated && !schEvaluated.dynamicProps) {\r\n        if (schEvaluated.props !== undefined) {\r\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\r\n        }\r\n      } else {\r\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\r\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\r\n      }\r\n    }\r\n    if (it.items !== true) {\r\n      if (schEvaluated && !schEvaluated.dynamicItems) {\r\n        if (schEvaluated.items !== undefined) {\r\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\r\n        }\r\n      } else {\r\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\r\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default def\r\n", "import type {Vocabulary} from \"../../types\"\r\nimport idKeyword from \"./id\"\r\nimport refKeyword from \"./ref\"\r\n\r\nconst core: Vocabulary = [\r\n  \"$schema\",\r\n  \"$id\",\r\n  \"$defs\",\r\n  \"$vocabulary\",\r\n  {keyword: \"$comment\"},\r\n  \"definitions\",\r\n  idKeyword,\r\n  refKeyword,\r\n]\r\n\r\nexport default core\r\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str, operators, Code} from \"../../compile/codegen\"\r\n\r\nconst ops = operators\r\n\r\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\r\n\r\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\r\n\r\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\r\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\r\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\r\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\r\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\r\n}\r\n\r\nexport type LimitNumberError = ErrorObject<\r\n  Kwd,\r\n  {limit: number; comparison: Comparison},\r\n  number | {$data: string}\r\n>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\r\n  params: ({keyword, schemaCode}) =>\r\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: Object.keys(KWDs),\r\n  type: \"number\",\r\n  schemaType: \"number\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {keyword, data, schemaCode} = cxt\r\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str} from \"../../compile/codegen\"\r\n\r\nexport type MultipleOfError = ErrorObject<\r\n  \"multipleOf\",\r\n  {multipleOf: number},\r\n  number | {$data: string}\r\n>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\r\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"multipleOf\",\r\n  type: \"number\",\r\n  schemaType: \"number\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, data, schemaCode, it} = cxt\r\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\r\n    const prec = it.opts.multipleOfPrecision\r\n    const res = gen.let(\"res\")\r\n    const invalid = prec\r\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\r\n      : _`${res} !== parseInt(${res})`\r\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\r\n  },\r\n}\r\n\r\nexport default def\r\n", "// https://mathiasbynens.be/notes/javascript-encoding\r\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\r\nexport default function ucs2length(str: string): number {\r\n  const len = str.length\r\n  let length = 0\r\n  let pos = 0\r\n  let value: number\r\n  while (pos < len) {\r\n    length++\r\n    value = str.charCodeAt(pos++)\r\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\r\n      // high surrogate, and there is a next character\r\n      value = str.charCodeAt(pos)\r\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\r\n    }\r\n  }\r\n  return length\r\n}\r\n\r\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\r\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str, operators} from \"../../compile/codegen\"\r\nimport {useFunc} from \"../../compile/util\"\r\nimport ucs2length from \"../../runtime/ucs2length\"\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message({keyword, schemaCode}) {\r\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\r\n    return str`must NOT have ${comp} than ${schemaCode} characters`\r\n  },\r\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: [\"maxLength\", \"minLength\"],\r\n  type: \"string\",\r\n  schemaType: \"number\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {keyword, data, schemaCode, it} = cxt\r\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\r\n    const len =\r\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\r\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {usePattern} from \"../code\"\r\nimport {_, str} from \"../../compile/codegen\"\r\n\r\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\r\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"pattern\",\r\n  type: \"string\",\r\n  schemaType: \"string\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {data, $data, schema, schemaCode, it} = cxt\r\n    // TODO regexp should be wrapped in try/catchs\r\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\r\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\r\n    cxt.fail$data(_`!${regExp}.test(${data})`)\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str, operators} from \"../../compile/codegen\"\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message({keyword, schemaCode}) {\r\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\r\n    return str`must NOT have ${comp} than ${schemaCode} properties`\r\n  },\r\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: [\"maxProperties\", \"minProperties\"],\r\n  type: \"object\",\r\n  schemaType: \"number\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {keyword, data, schemaCode} = cxt\r\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\r\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {\r\n  checkReportMissingProp,\r\n  checkMissingProp,\r\n  reportMissingProp,\r\n  propertyInData,\r\n  noPropertyInData,\r\n} from \"../code\"\r\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\r\nimport {checkStrictMode} from \"../../compile/util\"\r\n\r\nexport type RequiredError = ErrorObject<\r\n  \"required\",\r\n  {missingProperty: string},\r\n  string[] | {$data: string}\r\n>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\r\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"required\",\r\n  type: \"object\",\r\n  schemaType: \"array\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, schema, schemaCode, data, $data, it} = cxt\r\n    const {opts} = it\r\n    if (!$data && schema.length === 0) return\r\n    const useLoop = schema.length >= opts.loopRequired\r\n    if (it.allErrors) allErrorsMode()\r\n    else exitOnErrorMode()\r\n\r\n    if (opts.strictRequired) {\r\n      const props = cxt.parentSchema.properties\r\n      const {definedProperties} = cxt.it\r\n      for (const requiredKey of schema) {\r\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\r\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\r\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\r\n          checkStrictMode(it, msg, it.opts.strictRequired)\r\n        }\r\n      }\r\n    }\r\n\r\n    function allErrorsMode(): void {\r\n      if (useLoop || $data) {\r\n        cxt.block$data(nil, loopAllRequired)\r\n      } else {\r\n        for (const prop of schema) {\r\n          checkReportMissingProp(cxt, prop)\r\n        }\r\n      }\r\n    }\r\n\r\n    function exitOnErrorMode(): void {\r\n      const missing = gen.let(\"missing\")\r\n      if (useLoop || $data) {\r\n        const valid = gen.let(\"valid\", true)\r\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\r\n        cxt.ok(valid)\r\n      } else {\r\n        gen.if(checkMissingProp(cxt, schema, missing))\r\n        reportMissingProp(cxt, missing)\r\n        gen.else()\r\n      }\r\n    }\r\n\r\n    function loopAllRequired(): void {\r\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\r\n        cxt.setParams({missingProperty: prop})\r\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\r\n      })\r\n    }\r\n\r\n    function loopUntilMissing(missing: Name, valid: Name): void {\r\n      cxt.setParams({missingProperty: missing})\r\n      gen.forOf(\r\n        missing,\r\n        schemaCode as Code,\r\n        () => {\r\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\r\n          gen.if(not(valid), () => {\r\n            cxt.error()\r\n            gen.break()\r\n          })\r\n        },\r\n        nil\r\n      )\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str, operators} from \"../../compile/codegen\"\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message({keyword, schemaCode}) {\r\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\r\n    return str`must NOT have ${comp} than ${schemaCode} items`\r\n  },\r\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: [\"maxItems\", \"minItems\"],\r\n  type: \"array\",\r\n  schemaType: \"number\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {keyword, data, schemaCode} = cxt\r\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\r\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\r\n  },\r\n}\r\n\r\nexport default def\r\n", "// https://github.com/ajv-validator/ajv/issues/889\r\nimport * as equal from \"fast-deep-equal\"\r\n\r\ntype Equal = typeof equal & {code: string}\r\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\r\n\r\nexport default equal as Equal\r\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\r\nimport {_, str, Name} from \"../../compile/codegen\"\r\nimport {useFunc} from \"../../compile/util\"\r\nimport equal from \"../../runtime/equal\"\r\n\r\nexport type UniqueItemsError = ErrorObject<\r\n  \"uniqueItems\",\r\n  {i: number; j: number},\r\n  boolean | {$data: string}\r\n>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({params: {i, j}}) =>\r\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\r\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"uniqueItems\",\r\n  type: \"array\",\r\n  schemaType: \"boolean\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\r\n    if (!$data && !schema) return\r\n    const valid = gen.let(\"valid\")\r\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\r\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\r\n    cxt.ok(valid)\r\n\r\n    function validateUniqueItems(): void {\r\n      const i = gen.let(\"i\", _`${data}.length`)\r\n      const j = gen.let(\"j\")\r\n      cxt.setParams({i, j})\r\n      gen.assign(valid, true)\r\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\r\n    }\r\n\r\n    function canOptimize(): boolean {\r\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\r\n    }\r\n\r\n    function loopN(i: Name, j: Name): void {\r\n      const item = gen.name(\"item\")\r\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\r\n      const indices = gen.const(\"indices\", _`{}`)\r\n      gen.for(_`;${i}--;`, () => {\r\n        gen.let(item, _`${data}[${i}]`)\r\n        gen.if(wrongType, _`continue`)\r\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\r\n        gen\r\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\r\n            gen.assign(j, _`${indices}[${item}]`)\r\n            cxt.error()\r\n            gen.assign(valid, false).break()\r\n          })\r\n          .code(_`${indices}[${item}] = ${i}`)\r\n      })\r\n    }\r\n\r\n    function loopN2(i: Name, j: Name): void {\r\n      const eql = useFunc(gen, equal)\r\n      const outer = gen.name(\"outer\")\r\n      gen.label(outer).for(_`;${i}--;`, () =>\r\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\r\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\r\n            cxt.error()\r\n            gen.assign(valid, false).break(outer)\r\n          })\r\n        )\r\n      )\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_} from \"../../compile/codegen\"\r\nimport {useFunc} from \"../../compile/util\"\r\nimport equal from \"../../runtime/equal\"\r\n\r\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: \"must be equal to constant\",\r\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"const\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, data, $data, schemaCode, schema} = cxt\r\n    if ($data || (schema && typeof schema == \"object\")) {\r\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\r\n    } else {\r\n      cxt.fail(_`${schema} !== ${data}`)\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, or, Name, Code} from \"../../compile/codegen\"\r\nimport {useFunc} from \"../../compile/util\"\r\nimport equal from \"../../runtime/equal\"\r\n\r\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: \"must be equal to one of the allowed values\",\r\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"enum\",\r\n  schemaType: \"array\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, data, $data, schema, schemaCode, it} = cxt\r\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\r\n    const useLoop = schema.length >= it.opts.loopEnum\r\n    let eql: Name | undefined\r\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\r\n\r\n    let valid: Code\r\n    if (useLoop || $data) {\r\n      valid = gen.let(\"valid\")\r\n      cxt.block$data(valid, loopEnum)\r\n    } else {\r\n      /* istanbul ignore if */\r\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\r\n      const vSchema = gen.const(\"vSchema\", schemaCode)\r\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\r\n    }\r\n    cxt.pass(valid)\r\n\r\n    function loopEnum(): void {\r\n      gen.assign(valid, false)\r\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\r\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\r\n      )\r\n    }\r\n\r\n    function equalCode(vSchema: Name, i: number): Code {\r\n      const sch = schema[i]\r\n      return typeof sch === \"object\" && sch !== null\r\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\r\n        : _`${data} === ${sch}`\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {ErrorObject, Vocabulary} from \"../../types\"\r\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\r\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\r\nimport limitLength from \"./limitLength\"\r\nimport pattern, {PatternError} from \"./pattern\"\r\nimport limitProperties from \"./limitProperties\"\r\nimport required, {RequiredError} from \"./required\"\r\nimport limitItems from \"./limitItems\"\r\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\r\nimport constKeyword, {ConstError} from \"./const\"\r\nimport enumKeyword, {EnumError} from \"./enum\"\r\n\r\nconst validation: Vocabulary = [\r\n  // number\r\n  limitNumber,\r\n  multipleOf,\r\n  // string\r\n  limitLength,\r\n  pattern,\r\n  // object\r\n  limitProperties,\r\n  required,\r\n  // array\r\n  limitItems,\r\n  uniqueItems,\r\n  // any\r\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\r\n  {keyword: \"nullable\", schemaType: \"boolean\"},\r\n  constKeyword,\r\n  enumKeyword,\r\n]\r\n\r\nexport default validation\r\n\r\ntype LimitError = ErrorObject<\r\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\r\n  {limit: number},\r\n  number | {$data: string}\r\n>\r\n\r\nexport type ValidationKeywordError =\r\n  | LimitError\r\n  | LimitNumberError\r\n  | MultipleOfError\r\n  | PatternError\r\n  | RequiredError\r\n  | UniqueItemsError\r\n  | ConstError\r\n  | EnumError\r\n", "import type {\r\n  CodeKeywordDefinition,\r\n  ErrorObject,\r\n  KeywordErrorDefinition,\r\n  AnySchema,\r\n} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str, not, Name} from \"../../compile/codegen\"\r\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\r\n\r\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\r\n  params: ({params: {len}}) => _`{limit: ${len}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"additionalItems\" as const,\r\n  type: \"array\",\r\n  schemaType: [\"boolean\", \"object\"],\r\n  before: \"uniqueItems\",\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {parentSchema, it} = cxt\r\n    const {items} = parentSchema\r\n    if (!Array.isArray(items)) {\r\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\r\n      return\r\n    }\r\n    validateAdditionalItems(cxt, items)\r\n  },\r\n}\r\n\r\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\r\n  const {gen, schema, data, keyword, it} = cxt\r\n  it.items = true\r\n  const len = gen.const(\"len\", _`${data}.length`)\r\n  if (schema === false) {\r\n    cxt.setParams({len: items.length})\r\n    cxt.pass(_`${len} <= ${items.length}`)\r\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\r\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\r\n    gen.if(not(valid), () => validateItems(valid))\r\n    cxt.ok(valid)\r\n  }\r\n\r\n  function validateItems(valid: Name): void {\r\n    gen.forRange(\"i\", items.length, len, (i) => {\r\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\r\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\r\n    })\r\n  }\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_} from \"../../compile/codegen\"\r\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\r\nimport {validateArray} from \"../code\"\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"items\",\r\n  type: \"array\",\r\n  schemaType: [\"object\", \"array\", \"boolean\"],\r\n  before: \"uniqueItems\",\r\n  code(cxt: KeywordCxt) {\r\n    const {schema, it} = cxt\r\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\r\n    it.items = true\r\n    if (alwaysValidSchema(it, schema)) return\r\n    cxt.ok(validateArray(cxt))\r\n  },\r\n}\r\n\r\nexport function validateTuple(\r\n  cxt: KeywordCxt,\r\n  extraItems: string,\r\n  schArr: AnySchema[] = cxt.schema\r\n): void {\r\n  const {gen, parentSchema, data, keyword, it} = cxt\r\n  checkStrictTuple(parentSchema)\r\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\r\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\r\n  }\r\n  const valid = gen.name(\"valid\")\r\n  const len = gen.const(\"len\", _`${data}.length`)\r\n  schArr.forEach((sch: AnySchema, i: number) => {\r\n    if (alwaysValidSchema(it, sch)) return\r\n    gen.if(_`${len} > ${i}`, () =>\r\n      cxt.subschema(\r\n        {\r\n          keyword,\r\n          schemaProp: i,\r\n          dataProp: i,\r\n        },\r\n        valid\r\n      )\r\n    )\r\n    cxt.ok(valid)\r\n  })\r\n\r\n  function checkStrictTuple(sch: AnySchemaObject): void {\r\n    const {opts, errSchemaPath} = it\r\n    const l = schArr.length\r\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\r\n    if (opts.strictTuples && !fullTuple) {\r\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\r\n      checkStrictMode(it, msg, opts.strictTuples)\r\n    }\r\n  }\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition} from \"../../types\"\r\nimport {validateTuple} from \"./items\"\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"prefixItems\",\r\n  type: \"array\",\r\n  schemaType: [\"array\"],\r\n  before: \"uniqueItems\",\r\n  code: (cxt) => validateTuple(cxt, \"items\"),\r\n}\r\n\r\nexport default def\r\n", "import type {\r\n  CodeKeywordDefinition,\r\n  KeywordErrorDefinition,\r\n  ErrorObject,\r\n  AnySchema,\r\n} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str} from \"../../compile/codegen\"\r\nimport {alwaysValidSchema} from \"../../compile/util\"\r\nimport {validateArray} from \"../code\"\r\nimport {validateAdditionalItems} from \"./additionalItems\"\r\n\r\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\r\n  params: ({params: {len}}) => _`{limit: ${len}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"items\",\r\n  type: \"array\",\r\n  schemaType: [\"object\", \"boolean\"],\r\n  before: \"uniqueItems\",\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {schema, parentSchema, it} = cxt\r\n    const {prefixItems} = parentSchema\r\n    it.items = true\r\n    if (alwaysValidSchema(it, schema)) return\r\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\r\n    else cxt.ok(validateArray(cxt))\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {\r\n  CodeKeywordDefinition,\r\n  KeywordErrorDefinition,\r\n  ErrorObject,\r\n  AnySchema,\r\n} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str, Name} from \"../../compile/codegen\"\r\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\r\n\r\nexport type ContainsError = ErrorObject<\r\n  \"contains\",\r\n  {minContains: number; maxContains?: number},\r\n  AnySchema\r\n>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({params: {min, max}}) =>\r\n    max === undefined\r\n      ? str`must contain at least ${min} valid item(s)`\r\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\r\n  params: ({params: {min, max}}) =>\r\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"contains\",\r\n  type: \"array\",\r\n  schemaType: [\"object\", \"boolean\"],\r\n  before: \"uniqueItems\",\r\n  trackErrors: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, schema, parentSchema, data, it} = cxt\r\n    let min: number\r\n    let max: number | undefined\r\n    const {minContains, maxContains} = parentSchema\r\n    if (it.opts.next) {\r\n      min = minContains === undefined ? 1 : minContains\r\n      max = maxContains\r\n    } else {\r\n      min = 1\r\n    }\r\n    const len = gen.const(\"len\", _`${data}.length`)\r\n    cxt.setParams({min, max})\r\n    if (max === undefined && min === 0) {\r\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\r\n      return\r\n    }\r\n    if (max !== undefined && min > max) {\r\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\r\n      cxt.fail()\r\n      return\r\n    }\r\n    if (alwaysValidSchema(it, schema)) {\r\n      let cond = _`${len} >= ${min}`\r\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\r\n      cxt.pass(cond)\r\n      return\r\n    }\r\n\r\n    it.items = true\r\n    const valid = gen.name(\"valid\")\r\n    if (max === undefined && min === 1) {\r\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\r\n    } else if (min === 0) {\r\n      gen.let(valid, true)\r\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\r\n    } else {\r\n      gen.let(valid, false)\r\n      validateItemsWithCount()\r\n    }\r\n    cxt.result(valid, () => cxt.reset())\r\n\r\n    function validateItemsWithCount(): void {\r\n      const schValid = gen.name(\"_valid\")\r\n      const count = gen.let(\"count\", 0)\r\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\r\n    }\r\n\r\n    function validateItems(_valid: Name, block: () => void): void {\r\n      gen.forRange(\"i\", 0, len, (i) => {\r\n        cxt.subschema(\r\n          {\r\n            keyword: \"contains\",\r\n            dataProp: i,\r\n            dataPropType: Type.Num,\r\n            compositeRule: true,\r\n          },\r\n          _valid\r\n        )\r\n        block()\r\n      })\r\n    }\r\n\r\n    function checkLimits(count: Name): void {\r\n      gen.code(_`${count}++`)\r\n      if (max === undefined) {\r\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\r\n      } else {\r\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\r\n        if (min === 1) gen.assign(valid, true)\r\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {\r\n  CodeKeywordDefinition,\r\n  ErrorObject,\r\n  KeywordErrorDefinition,\r\n  SchemaMap,\r\n  AnySchema,\r\n} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str} from \"../../compile/codegen\"\r\nimport {alwaysValidSchema} from \"../../compile/util\"\r\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\r\n\r\nexport type PropertyDependencies = {[K in string]?: string[]}\r\n\r\nexport interface DependenciesErrorParams {\r\n  property: string\r\n  missingProperty: string\r\n  depsCount: number\r\n  deps: string // TODO change to string[]\r\n}\r\n\r\ntype SchemaDependencies = SchemaMap\r\n\r\nexport type DependenciesError = ErrorObject<\r\n  \"dependencies\",\r\n  DependenciesErrorParams,\r\n  {[K in string]?: string[] | AnySchema}\r\n>\r\n\r\nexport const error: KeywordErrorDefinition = {\r\n  message: ({params: {property, depsCount, deps}}) => {\r\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\r\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\r\n  },\r\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\r\n    _`{property: ${property},\r\n    missingProperty: ${missingProperty},\r\n    depsCount: ${depsCount},\r\n    deps: ${deps}}`, // TODO change to reference\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"dependencies\",\r\n  type: \"object\",\r\n  schemaType: \"object\",\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const [propDeps, schDeps] = splitDependencies(cxt)\r\n    validatePropertyDeps(cxt, propDeps)\r\n    validateSchemaDeps(cxt, schDeps)\r\n  },\r\n}\r\n\r\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\r\n  const propertyDeps: PropertyDependencies = {}\r\n  const schemaDeps: SchemaDependencies = {}\r\n  for (const key in schema) {\r\n    if (key === \"__proto__\") continue\r\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\r\n    deps[key] = schema[key]\r\n  }\r\n  return [propertyDeps, schemaDeps]\r\n}\r\n\r\nexport function validatePropertyDeps(\r\n  cxt: KeywordCxt,\r\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\r\n): void {\r\n  const {gen, data, it} = cxt\r\n  if (Object.keys(propertyDeps).length === 0) return\r\n  const missing = gen.let(\"missing\")\r\n  for (const prop in propertyDeps) {\r\n    const deps = propertyDeps[prop] as string[]\r\n    if (deps.length === 0) continue\r\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\r\n    cxt.setParams({\r\n      property: prop,\r\n      depsCount: deps.length,\r\n      deps: deps.join(\", \"),\r\n    })\r\n    if (it.allErrors) {\r\n      gen.if(hasProperty, () => {\r\n        for (const depProp of deps) {\r\n          checkReportMissingProp(cxt, depProp)\r\n        }\r\n      })\r\n    } else {\r\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\r\n      reportMissingProp(cxt, missing)\r\n      gen.else()\r\n    }\r\n  }\r\n}\r\n\r\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\r\n  const {gen, data, keyword, it} = cxt\r\n  const valid = gen.name(\"valid\")\r\n  for (const prop in schemaDeps) {\r\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\r\n    gen.if(\r\n      propertyInData(gen, data, prop, it.opts.ownProperties),\r\n      () => {\r\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\r\n        cxt.mergeValidEvaluated(schCxt, valid)\r\n      },\r\n      () => gen.var(valid, true) // TODO var\r\n    )\r\n    cxt.ok(valid)\r\n  }\r\n}\r\n\r\nexport default def\r\n", "import type {\r\n  CodeKeywordDefinition,\r\n  ErrorObject,\r\n  KeywordErrorDefinition,\r\n  AnySchema,\r\n} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, not} from \"../../compile/codegen\"\r\nimport {alwaysValidSchema} from \"../../compile/util\"\r\n\r\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: \"property name must be valid\",\r\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"propertyNames\",\r\n  type: \"object\",\r\n  schemaType: [\"object\", \"boolean\"],\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, schema, data, it} = cxt\r\n    if (alwaysValidSchema(it, schema)) return\r\n    const valid = gen.name(\"valid\")\r\n\r\n    gen.forIn(\"key\", data, (key) => {\r\n      cxt.setParams({propertyName: key})\r\n      cxt.subschema(\r\n        {\r\n          keyword: \"propertyNames\",\r\n          data: key,\r\n          dataTypes: [\"string\"],\r\n          propertyName: key,\r\n          compositeRule: true,\r\n        },\r\n        valid\r\n      )\r\n      gen.if(not(valid), () => {\r\n        cxt.error(true)\r\n        if (!it.allErrors) gen.break()\r\n      })\r\n    })\r\n\r\n    cxt.ok(valid)\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {\r\n  CodeKeywordDefinition,\r\n  AddedKeywordDefinition,\r\n  ErrorObject,\r\n  KeywordErrorDefinition,\r\n  AnySchema,\r\n} from \"../../types\"\r\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\r\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\r\nimport N from \"../../compile/names\"\r\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\r\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\r\n\r\nexport type AdditionalPropertiesError = ErrorObject<\r\n  \"additionalProperties\",\r\n  {additionalProperty: string},\r\n  AnySchema\r\n>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: \"must NOT have additional properties\",\r\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\r\n  keyword: \"additionalProperties\",\r\n  type: [\"object\"],\r\n  schemaType: [\"boolean\", \"object\"],\r\n  allowUndefined: true,\r\n  trackErrors: true,\r\n  error,\r\n  code(cxt) {\r\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\r\n    /* istanbul ignore if */\r\n    if (!errsCount) throw new Error(\"ajv implementation error\")\r\n    const {allErrors, opts} = it\r\n    it.props = true\r\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\r\n    const props = allSchemaProperties(parentSchema.properties)\r\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\r\n    checkAdditionalProperties()\r\n    cxt.ok(_`${errsCount} === ${N.errors}`)\r\n\r\n    function checkAdditionalProperties(): void {\r\n      gen.forIn(\"key\", data, (key: Name) => {\r\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\r\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\r\n      })\r\n    }\r\n\r\n    function isAdditional(key: Name): Code {\r\n      let definedProp: Code\r\n      if (props.length > 8) {\r\n        // TODO maybe an option instead of hard-coded 8?\r\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\r\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\r\n      } else if (props.length) {\r\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\r\n      } else {\r\n        definedProp = nil\r\n      }\r\n      if (patProps.length) {\r\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\r\n      }\r\n      return not(definedProp)\r\n    }\r\n\r\n    function deleteAdditional(key: Name): void {\r\n      gen.code(_`delete ${data}[${key}]`)\r\n    }\r\n\r\n    function additionalPropertyCode(key: Name): void {\r\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\r\n        deleteAdditional(key)\r\n        return\r\n      }\r\n\r\n      if (schema === false) {\r\n        cxt.setParams({additionalProperty: key})\r\n        cxt.error()\r\n        if (!allErrors) gen.break()\r\n        return\r\n      }\r\n\r\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\r\n        const valid = gen.name(\"valid\")\r\n        if (opts.removeAdditional === \"failing\") {\r\n          applyAdditionalSchema(key, valid, false)\r\n          gen.if(not(valid), () => {\r\n            cxt.reset()\r\n            deleteAdditional(key)\r\n          })\r\n        } else {\r\n          applyAdditionalSchema(key, valid)\r\n          if (!allErrors) gen.if(not(valid), () => gen.break())\r\n        }\r\n      }\r\n    }\r\n\r\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\r\n      const subschema: SubschemaArgs = {\r\n        keyword: \"additionalProperties\",\r\n        dataProp: key,\r\n        dataPropType: Type.Str,\r\n      }\r\n      if (errors === false) {\r\n        Object.assign(subschema, {\r\n          compositeRule: true,\r\n          createErrors: false,\r\n          allErrors: false,\r\n        })\r\n      }\r\n      cxt.subschema(subschema, valid)\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition} from \"../../types\"\r\nimport {KeywordCxt} from \"../../compile/validate\"\r\nimport {propertyInData, allSchemaProperties} from \"../code\"\r\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\r\nimport apDef from \"./additionalProperties\"\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"properties\",\r\n  type: \"object\",\r\n  schemaType: \"object\",\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, schema, parentSchema, data, it} = cxt\r\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\r\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\r\n    }\r\n    const allProps = allSchemaProperties(schema)\r\n    for (const prop of allProps) {\r\n      it.definedProperties.add(prop)\r\n    }\r\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\r\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\r\n    }\r\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\r\n    if (properties.length === 0) return\r\n    const valid = gen.name(\"valid\")\r\n\r\n    for (const prop of properties) {\r\n      if (hasDefault(prop)) {\r\n        applyPropertySchema(prop)\r\n      } else {\r\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\r\n        applyPropertySchema(prop)\r\n        if (!it.allErrors) gen.else().var(valid, true)\r\n        gen.endIf()\r\n      }\r\n      cxt.it.definedProperties.add(prop)\r\n      cxt.ok(valid)\r\n    }\r\n\r\n    function hasDefault(prop: string): boolean | undefined {\r\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\r\n    }\r\n\r\n    function applyPropertySchema(prop: string): void {\r\n      cxt.subschema(\r\n        {\r\n          keyword: \"properties\",\r\n          schemaProp: prop,\r\n          dataProp: prop,\r\n        },\r\n        valid\r\n      )\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {allSchemaProperties, usePattern} from \"../code\"\r\nimport {_, not, Name} from \"../../compile/codegen\"\r\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\r\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\r\nimport {AnySchema} from \"../../types\"\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"patternProperties\",\r\n  type: \"object\",\r\n  schemaType: \"object\",\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, schema, data, parentSchema, it} = cxt\r\n    const {opts} = it\r\n    const patterns = allSchemaProperties(schema)\r\n    const alwaysValidPatterns = patterns.filter((p) =>\r\n      alwaysValidSchema(it, schema[p] as AnySchema)\r\n    )\r\n\r\n    if (\r\n      patterns.length === 0 ||\r\n      (alwaysValidPatterns.length === patterns.length &&\r\n        (!it.opts.unevaluated || it.props === true))\r\n    ) {\r\n      return\r\n    }\r\n\r\n    const checkProperties =\r\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\r\n    const valid = gen.name(\"valid\")\r\n    if (it.props !== true && !(it.props instanceof Name)) {\r\n      it.props = evaluatedPropsToName(gen, it.props)\r\n    }\r\n    const {props} = it\r\n    validatePatternProperties()\r\n\r\n    function validatePatternProperties(): void {\r\n      for (const pat of patterns) {\r\n        if (checkProperties) checkMatchingProperties(pat)\r\n        if (it.allErrors) {\r\n          validateProperties(pat)\r\n        } else {\r\n          gen.var(valid, true) // TODO var\r\n          validateProperties(pat)\r\n          gen.if(valid)\r\n        }\r\n      }\r\n    }\r\n\r\n    function checkMatchingProperties(pat: string): void {\r\n      for (const prop in checkProperties) {\r\n        if (new RegExp(pat).test(prop)) {\r\n          checkStrictMode(\r\n            it,\r\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\r\n          )\r\n        }\r\n      }\r\n    }\r\n\r\n    function validateProperties(pat: string): void {\r\n      gen.forIn(\"key\", data, (key) => {\r\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\r\n          const alwaysValid = alwaysValidPatterns.includes(pat)\r\n          if (!alwaysValid) {\r\n            cxt.subschema(\r\n              {\r\n                keyword: \"patternProperties\",\r\n                schemaProp: pat,\r\n                dataProp: key,\r\n                dataPropType: Type.Str,\r\n              },\r\n              valid\r\n            )\r\n          }\r\n\r\n          if (it.opts.unevaluated && props !== true) {\r\n            gen.assign(_`${props}[${key}]`, true)\r\n          } else if (!alwaysValid && !it.allErrors) {\r\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\r\n            // or if all properties were evaluated (props === true)\r\n            gen.if(not(valid), () => gen.break())\r\n          }\r\n        })\r\n      })\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {alwaysValidSchema} from \"../../compile/util\"\r\n\r\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"not\",\r\n  schemaType: [\"object\", \"boolean\"],\r\n  trackErrors: true,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, schema, it} = cxt\r\n    if (alwaysValidSchema(it, schema)) {\r\n      cxt.fail()\r\n      return\r\n    }\r\n\r\n    const valid = gen.name(\"valid\")\r\n    cxt.subschema(\r\n      {\r\n        keyword: \"not\",\r\n        compositeRule: true,\r\n        createErrors: false,\r\n        allErrors: false,\r\n      },\r\n      valid\r\n    )\r\n\r\n    cxt.failResult(\r\n      valid,\r\n      () => cxt.reset(),\r\n      () => cxt.error()\r\n    )\r\n  },\r\n  error: {message: \"must NOT be valid\"},\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\r\nimport {validateUnion} from \"../code\"\r\n\r\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"anyOf\",\r\n  schemaType: \"array\",\r\n  trackErrors: true,\r\n  code: validateUnion,\r\n  error: {message: \"must match a schema in anyOf\"},\r\n}\r\n\r\nexport default def\r\n", "import type {\r\n  CodeKeywordDefinition,\r\n  ErrorObject,\r\n  KeywordErrorDefinition,\r\n  AnySchema,\r\n} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, Name} from \"../../compile/codegen\"\r\nimport {alwaysValidSchema} from \"../../compile/util\"\r\nimport {SchemaCxt} from \"../../compile\"\r\n\r\nexport type OneOfError = ErrorObject<\r\n  \"oneOf\",\r\n  {passingSchemas: [number, number] | null},\r\n  AnySchema[]\r\n>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: \"must match exactly one schema in oneOf\",\r\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"oneOf\",\r\n  schemaType: \"array\",\r\n  trackErrors: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, schema, parentSchema, it} = cxt\r\n    /* istanbul ignore if */\r\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\r\n    if (it.opts.discriminator && parentSchema.discriminator) return\r\n    const schArr: AnySchema[] = schema\r\n    const valid = gen.let(\"valid\", false)\r\n    const passing = gen.let(\"passing\", null)\r\n    const schValid = gen.name(\"_valid\")\r\n    cxt.setParams({passing})\r\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\r\n\r\n    gen.block(validateOneOf)\r\n\r\n    cxt.result(\r\n      valid,\r\n      () => cxt.reset(),\r\n      () => cxt.error(true)\r\n    )\r\n\r\n    function validateOneOf(): void {\r\n      schArr.forEach((sch: AnySchema, i: number) => {\r\n        let schCxt: SchemaCxt | undefined\r\n        if (alwaysValidSchema(it, sch)) {\r\n          gen.var(schValid, true)\r\n        } else {\r\n          schCxt = cxt.subschema(\r\n            {\r\n              keyword: \"oneOf\",\r\n              schemaProp: i,\r\n              compositeRule: true,\r\n            },\r\n            schValid\r\n          )\r\n        }\r\n\r\n        if (i > 0) {\r\n          gen\r\n            .if(_`${schValid} && ${valid}`)\r\n            .assign(valid, false)\r\n            .assign(passing, _`[${passing}, ${i}]`)\r\n            .else()\r\n        }\r\n\r\n        gen.if(schValid, () => {\r\n          gen.assign(valid, true)\r\n          gen.assign(passing, i)\r\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\r\n        })\r\n      })\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {alwaysValidSchema} from \"../../compile/util\"\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"allOf\",\r\n  schemaType: \"array\",\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, schema, it} = cxt\r\n    /* istanbul ignore if */\r\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\r\n    const valid = gen.name(\"valid\")\r\n    schema.forEach((sch: AnySchema, i: number) => {\r\n      if (alwaysValidSchema(it, sch)) return\r\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\r\n      cxt.ok(valid)\r\n      cxt.mergeEvaluated(schCxt)\r\n    })\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {\r\n  CodeKeywordDefinition,\r\n  ErrorObject,\r\n  KeywordErrorDefinition,\r\n  AnySchema,\r\n} from \"../../types\"\r\nimport type {SchemaObjCxt} from \"../../compile\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str, not, Name} from \"../../compile/codegen\"\r\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\r\n\r\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\r\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"if\",\r\n  schemaType: [\"object\", \"boolean\"],\r\n  trackErrors: true,\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, parentSchema, it} = cxt\r\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\r\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\r\n    }\r\n    const hasThen = hasSchema(it, \"then\")\r\n    const hasElse = hasSchema(it, \"else\")\r\n    if (!hasThen && !hasElse) return\r\n\r\n    const valid = gen.let(\"valid\", true)\r\n    const schValid = gen.name(\"_valid\")\r\n    validateIf()\r\n    cxt.reset()\r\n\r\n    if (hasThen && hasElse) {\r\n      const ifClause = gen.let(\"ifClause\")\r\n      cxt.setParams({ifClause})\r\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\r\n    } else if (hasThen) {\r\n      gen.if(schValid, validateClause(\"then\"))\r\n    } else {\r\n      gen.if(not(schValid), validateClause(\"else\"))\r\n    }\r\n\r\n    cxt.pass(valid, () => cxt.error(true))\r\n\r\n    function validateIf(): void {\r\n      const schCxt = cxt.subschema(\r\n        {\r\n          keyword: \"if\",\r\n          compositeRule: true,\r\n          createErrors: false,\r\n          allErrors: false,\r\n        },\r\n        schValid\r\n      )\r\n      cxt.mergeEvaluated(schCxt)\r\n    }\r\n\r\n    function validateClause(keyword: string, ifClause?: Name): () => void {\r\n      return () => {\r\n        const schCxt = cxt.subschema({keyword}, schValid)\r\n        gen.assign(valid, schValid)\r\n        cxt.mergeValidEvaluated(schCxt, valid)\r\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\r\n        else cxt.setParams({ifClause: keyword})\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\r\n  const schema = it.schema[keyword]\r\n  return schema !== undefined && !alwaysValidSchema(it, schema)\r\n}\r\n\r\nexport default def\r\n", "import type {CodeKeywordDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {checkStrictMode} from \"../../compile/util\"\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: [\"then\", \"else\"],\r\n  schemaType: [\"object\", \"boolean\"],\r\n  code({keyword, parentSchema, it}: KeywordCxt) {\r\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {ErrorNoParams, Vocabulary} from \"../../types\"\r\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\r\nimport prefixItems from \"./prefixItems\"\r\nimport items from \"./items\"\r\nimport items2020, {ItemsError} from \"./items2020\"\r\nimport contains, {ContainsError} from \"./contains\"\r\nimport dependencies, {DependenciesError} from \"./dependencies\"\r\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\r\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\r\nimport properties from \"./properties\"\r\nimport patternProperties from \"./patternProperties\"\r\nimport notKeyword, {NotKeywordError} from \"./not\"\r\nimport anyOf, {AnyOfError} from \"./anyOf\"\r\nimport oneOf, {OneOfError} from \"./oneOf\"\r\nimport allOf from \"./allOf\"\r\nimport ifKeyword, {IfKeywordError} from \"./if\"\r\nimport thenElse from \"./thenElse\"\r\n\r\nexport default function getApplicator(draft2020 = false): Vocabulary {\r\n  const applicator = [\r\n    // any\r\n    notKeyword,\r\n    anyOf,\r\n    oneOf,\r\n    allOf,\r\n    ifKeyword,\r\n    thenElse,\r\n    // object\r\n    propertyNames,\r\n    additionalProperties,\r\n    dependencies,\r\n    properties,\r\n    patternProperties,\r\n  ]\r\n  // array\r\n  if (draft2020) applicator.push(prefixItems, items2020)\r\n  else applicator.push(additionalItems, items)\r\n  applicator.push(contains)\r\n  return applicator\r\n}\r\n\r\nexport type ApplicatorKeywordError =\r\n  | ErrorNoParams<\"false schema\">\r\n  | AdditionalItemsError\r\n  | ItemsError\r\n  | ContainsError\r\n  | AdditionalPropertiesError\r\n  | DependenciesError\r\n  | IfKeywordError\r\n  | AnyOfError\r\n  | OneOfError\r\n  | NotKeywordError\r\n  | PropertyNamesError\r\n", "import type {\r\n  AddedFormat,\r\n  FormatValidator,\r\n  AsyncFormatValidator,\r\n  CodeKeywordDefinition,\r\n  KeywordErrorDefinition,\r\n  ErrorObject,\r\n} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\r\n\r\ntype FormatValidate =\r\n  | FormatValidator<string>\r\n  | FormatValidator<number>\r\n  | AsyncFormatValidator<string>\r\n  | AsyncFormatValidator<number>\r\n  | RegExp\r\n  | string\r\n  | true\r\n\r\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\r\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"format\",\r\n  type: [\"number\", \"string\"],\r\n  schemaType: \"string\",\r\n  $data: true,\r\n  error,\r\n  code(cxt: KeywordCxt, ruleType?: string) {\r\n    const {gen, data, $data, schema, schemaCode, it} = cxt\r\n    const {opts, errSchemaPath, schemaEnv, self} = it\r\n    if (!opts.validateFormats) return\r\n\r\n    if ($data) validate$DataFormat()\r\n    else validateFormat()\r\n\r\n    function validate$DataFormat(): void {\r\n      const fmts = gen.scopeValue(\"formats\", {\r\n        ref: self.formats,\r\n        code: opts.code.formats,\r\n      })\r\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\r\n      const fType = gen.let(\"fType\")\r\n      const format = gen.let(\"format\")\r\n      // TODO simplify\r\n      gen.if(\r\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\r\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\r\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\r\n      )\r\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\r\n\r\n      function unknownFmt(): Code {\r\n        if (opts.strictSchema === false) return nil\r\n        return _`${schemaCode} && !${format}`\r\n      }\r\n\r\n      function invalidFmt(): Code {\r\n        const callFormat = schemaEnv.$async\r\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\r\n          : _`${format}(${data})`\r\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\r\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\r\n      }\r\n    }\r\n\r\n    function validateFormat(): void {\r\n      const formatDef: AddedFormat | undefined = self.formats[schema]\r\n      if (!formatDef) {\r\n        unknownFormat()\r\n        return\r\n      }\r\n      if (formatDef === true) return\r\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\r\n      if (fmtType === ruleType) cxt.pass(validCondition())\r\n\r\n      function unknownFormat(): void {\r\n        if (opts.strictSchema === false) {\r\n          self.logger.warn(unknownMsg())\r\n          return\r\n        }\r\n        throw new Error(unknownMsg())\r\n\r\n        function unknownMsg(): string {\r\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\r\n        }\r\n      }\r\n\r\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\r\n        const code =\r\n          fmtDef instanceof RegExp\r\n            ? regexpCode(fmtDef)\r\n            : opts.code.formats\r\n            ? _`${opts.code.formats}${getProperty(schema)}`\r\n            : undefined\r\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\r\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\r\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\r\n        }\r\n\r\n        return [\"string\", fmtDef, fmt]\r\n      }\r\n\r\n      function validCondition(): Code {\r\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\r\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\r\n          return _`await ${fmtRef}(${data})`\r\n        }\r\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "import type {Vocabulary} from \"../../types\"\r\nimport formatKeyword from \"./format\"\r\n\r\nconst format: Vocabulary = [formatKeyword]\r\n\r\nexport default format\r\n", "import type {Vocabulary} from \"../types\"\r\n\r\nexport const metadataVocabulary: Vocabulary = [\r\n  \"title\",\r\n  \"description\",\r\n  \"default\",\r\n  \"deprecated\",\r\n  \"readOnly\",\r\n  \"writeOnly\",\r\n  \"examples\",\r\n]\r\n\r\nexport const contentVocabulary: Vocabulary = [\r\n  \"contentMediaType\",\r\n  \"contentEncoding\",\r\n  \"contentSchema\",\r\n]\r\n", "import type {Vocabulary} from \"../types\"\r\nimport coreVocabulary from \"./core\"\r\nimport validationVocabulary from \"./validation\"\r\nimport getApplicatorVocabulary from \"./applicator\"\r\nimport formatVocabulary from \"./format\"\r\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\r\n\r\nconst draft7Vocabularies: Vocabulary[] = [\r\n  coreVocabulary,\r\n  validationVocabulary,\r\n  getApplicatorVocabulary(),\r\n  formatVocabulary,\r\n  metadataVocabulary,\r\n  contentVocabulary,\r\n]\r\n\r\nexport default draft7Vocabularies\r\n", "import type {ErrorObject} from \"../../types\"\r\n\r\nexport enum DiscrError {\r\n  Tag = \"tag\",\r\n  Mapping = \"mapping\",\r\n}\r\n\r\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\r\n  \"discriminator\",\r\n  {error: E; tag: string; tagValue: unknown},\r\n  string\r\n>\r\n", "import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\r\nimport type {KeywordCxt} from \"../../compile/validate\"\r\nimport {_, getProperty, Name} from \"../../compile/codegen\"\r\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\r\nimport {resolveRef, SchemaEnv} from \"../../compile\"\r\nimport MissingRefError from \"../../compile/ref_error\"\r\nimport {schemaHasRulesButRef} from \"../../compile/util\"\r\n\r\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\r\n\r\nconst error: KeywordErrorDefinition = {\r\n  message: ({params: {discrError, tagName}}) =>\r\n    discrError === DiscrError.Tag\r\n      ? `tag \"${tagName}\" must be string`\r\n      : `value of tag \"${tagName}\" must be in oneOf`,\r\n  params: ({params: {discrError, tag, tagName}}) =>\r\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\r\n}\r\n\r\nconst def: CodeKeywordDefinition = {\r\n  keyword: \"discriminator\",\r\n  type: \"object\",\r\n  schemaType: \"object\",\r\n  error,\r\n  code(cxt: KeywordCxt) {\r\n    const {gen, data, schema, parentSchema, it} = cxt\r\n    const {oneOf} = parentSchema\r\n    if (!it.opts.discriminator) {\r\n      throw new Error(\"discriminator: requires discriminator option\")\r\n    }\r\n    const tagName = schema.propertyName\r\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\r\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\r\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\r\n    const valid = gen.let(\"valid\", false)\r\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\r\n    gen.if(\r\n      _`typeof ${tag} == \"string\"`,\r\n      () => validateMapping(),\r\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\r\n    )\r\n    cxt.ok(valid)\r\n\r\n    function validateMapping(): void {\r\n      const mapping = getMapping()\r\n      gen.if(false)\r\n      for (const tagValue in mapping) {\r\n        gen.elseIf(_`${tag} === ${tagValue}`)\r\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\r\n      }\r\n      gen.else()\r\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\r\n      gen.endIf()\r\n    }\r\n\r\n    function applyTagSchema(schemaProp?: number): Name {\r\n      const _valid = gen.name(\"valid\")\r\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\r\n      cxt.mergeEvaluated(schCxt, Name)\r\n      return _valid\r\n    }\r\n\r\n    function getMapping(): {[T in string]?: number} {\r\n      const oneOfMapping: {[T in string]?: number} = {}\r\n      const topRequired = hasRequired(parentSchema)\r\n      let tagRequired = true\r\n      for (let i = 0; i < oneOf.length; i++) {\r\n        let sch = oneOf[i]\r\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\r\n          const ref = sch.$ref\r\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)\r\n          if (sch instanceof SchemaEnv) sch = sch.schema\r\n          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)\r\n        }\r\n        const propSch = sch?.properties?.[tagName]\r\n        if (typeof propSch != \"object\") {\r\n          throw new Error(\r\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\r\n          )\r\n        }\r\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\r\n        addMappings(propSch, i)\r\n      }\r\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\r\n      return oneOfMapping\r\n\r\n      function hasRequired({required}: AnySchemaObject): boolean {\r\n        return Array.isArray(required) && required.includes(tagName)\r\n      }\r\n\r\n      function addMappings(sch: AnySchemaObject, i: number): void {\r\n        if (sch.const) {\r\n          addMapping(sch.const, i)\r\n        } else if (sch.enum) {\r\n          for (const tagValue of sch.enum) {\r\n            addMapping(tagValue, i)\r\n          }\r\n        } else {\r\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\r\n        }\r\n      }\r\n\r\n      function addMapping(tagValue: unknown, i: number): void {\r\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\r\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\r\n        }\r\n        oneOfMapping[tagValue] = i\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\nexport default def\r\n", "{\r\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r\n  \"$id\": \"http://json-schema.org/draft-07/schema#\",\r\n  \"title\": \"Core schema meta-schema\",\r\n  \"definitions\": {\r\n    \"schemaArray\": {\r\n      \"type\": \"array\",\r\n      \"minItems\": 1,\r\n      \"items\": {\"$ref\": \"#\"}\r\n    },\r\n    \"nonNegativeInteger\": {\r\n      \"type\": \"integer\",\r\n      \"minimum\": 0\r\n    },\r\n    \"nonNegativeIntegerDefault0\": {\r\n      \"allOf\": [{\"$ref\": \"#/definitions/nonNegativeInteger\"}, {\"default\": 0}]\r\n    },\r\n    \"simpleTypes\": {\r\n      \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\r\n    },\r\n    \"stringArray\": {\r\n      \"type\": \"array\",\r\n      \"items\": {\"type\": \"string\"},\r\n      \"uniqueItems\": true,\r\n      \"default\": []\r\n    }\r\n  },\r\n  \"type\": [\"object\", \"boolean\"],\r\n  \"properties\": {\r\n    \"$id\": {\r\n      \"type\": \"string\",\r\n      \"format\": \"uri-reference\"\r\n    },\r\n    \"$schema\": {\r\n      \"type\": \"string\",\r\n      \"format\": \"uri\"\r\n    },\r\n    \"$ref\": {\r\n      \"type\": \"string\",\r\n      \"format\": \"uri-reference\"\r\n    },\r\n    \"$comment\": {\r\n      \"type\": \"string\"\r\n    },\r\n    \"title\": {\r\n      \"type\": \"string\"\r\n    },\r\n    \"description\": {\r\n      \"type\": \"string\"\r\n    },\r\n    \"default\": true,\r\n    \"readOnly\": {\r\n      \"type\": \"boolean\",\r\n      \"default\": false\r\n    },\r\n    \"examples\": {\r\n      \"type\": \"array\",\r\n      \"items\": true\r\n    },\r\n    \"multipleOf\": {\r\n      \"type\": \"number\",\r\n      \"exclusiveMinimum\": 0\r\n    },\r\n    \"maximum\": {\r\n      \"type\": \"number\"\r\n    },\r\n    \"exclusiveMaximum\": {\r\n      \"type\": \"number\"\r\n    },\r\n    \"minimum\": {\r\n      \"type\": \"number\"\r\n    },\r\n    \"exclusiveMinimum\": {\r\n      \"type\": \"number\"\r\n    },\r\n    \"maxLength\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\r\n    \"minLength\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\r\n    \"pattern\": {\r\n      \"type\": \"string\",\r\n      \"format\": \"regex\"\r\n    },\r\n    \"additionalItems\": {\"$ref\": \"#\"},\r\n    \"items\": {\r\n      \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/schemaArray\"}],\r\n      \"default\": true\r\n    },\r\n    \"maxItems\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\r\n    \"minItems\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\r\n    \"uniqueItems\": {\r\n      \"type\": \"boolean\",\r\n      \"default\": false\r\n    },\r\n    \"contains\": {\"$ref\": \"#\"},\r\n    \"maxProperties\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\r\n    \"minProperties\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\r\n    \"required\": {\"$ref\": \"#/definitions/stringArray\"},\r\n    \"additionalProperties\": {\"$ref\": \"#\"},\r\n    \"definitions\": {\r\n      \"type\": \"object\",\r\n      \"additionalProperties\": {\"$ref\": \"#\"},\r\n      \"default\": {}\r\n    },\r\n    \"properties\": {\r\n      \"type\": \"object\",\r\n      \"additionalProperties\": {\"$ref\": \"#\"},\r\n      \"default\": {}\r\n    },\r\n    \"patternProperties\": {\r\n      \"type\": \"object\",\r\n      \"additionalProperties\": {\"$ref\": \"#\"},\r\n      \"propertyNames\": {\"format\": \"regex\"},\r\n      \"default\": {}\r\n    },\r\n    \"dependencies\": {\r\n      \"type\": \"object\",\r\n      \"additionalProperties\": {\r\n        \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/stringArray\"}]\r\n      }\r\n    },\r\n    \"propertyNames\": {\"$ref\": \"#\"},\r\n    \"const\": true,\r\n    \"enum\": {\r\n      \"type\": \"array\",\r\n      \"items\": true,\r\n      \"minItems\": 1,\r\n      \"uniqueItems\": true\r\n    },\r\n    \"type\": {\r\n      \"anyOf\": [\r\n        {\"$ref\": \"#/definitions/simpleTypes\"},\r\n        {\r\n          \"type\": \"array\",\r\n          \"items\": {\"$ref\": \"#/definitions/simpleTypes\"},\r\n          \"minItems\": 1,\r\n          \"uniqueItems\": true\r\n        }\r\n      ]\r\n    },\r\n    \"format\": {\"type\": \"string\"},\r\n    \"contentMediaType\": {\"type\": \"string\"},\r\n    \"contentEncoding\": {\"type\": \"string\"},\r\n    \"if\": {\"$ref\": \"#\"},\r\n    \"then\": {\"$ref\": \"#\"},\r\n    \"else\": {\"$ref\": \"#\"},\r\n    \"allOf\": {\"$ref\": \"#/definitions/schemaArray\"},\r\n    \"anyOf\": {\"$ref\": \"#/definitions/schemaArray\"},\r\n    \"oneOf\": {\"$ref\": \"#/definitions/schemaArray\"},\r\n    \"not\": {\"$ref\": \"#\"}\r\n  },\r\n  \"default\": true\r\n}\r\n", "import type {AnySchemaObject} from \"./types\"\r\nimport AjvCore from \"./core\"\r\nimport draft7Vocabularies from \"./vocabularies/draft7\"\r\nimport discriminator from \"./vocabularies/discriminator\"\r\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\r\n\r\nconst META_SUPPORT_DATA = [\"/properties\"]\r\n\r\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\r\n\r\nexport class Ajv extends AjvCore {\r\n  _addVocabularies(): void {\r\n    super._addVocabularies()\r\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\r\n    if (this.opts.discriminator) this.addKeyword(discriminator)\r\n  }\r\n\r\n  _addDefaultMetaSchema(): void {\r\n    super._addDefaultMetaSchema()\r\n    if (!this.opts.meta) return\r\n    const metaSchema = this.opts.$data\r\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\r\n      : draft7MetaSchema\r\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\r\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\r\n  }\r\n\r\n  defaultMeta(): string | AnySchemaObject | undefined {\r\n    return (this.opts.defaultMeta =\r\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\r\n  }\r\n}\r\n\r\nmodule.exports = exports = Ajv\r\nmodule.exports.Ajv = Ajv\r\nObject.defineProperty(exports, \"__esModule\", {value: true})\r\n\r\nexport default Ajv\r\n\r\nexport {\r\n  Format,\r\n  FormatDefinition,\r\n  AsyncFormatDefinition,\r\n  KeywordDefinition,\r\n  KeywordErrorDefinition,\r\n  CodeKeywordDefinition,\r\n  MacroKeywordDefinition,\r\n  FuncKeywordDefinition,\r\n  Vocabulary,\r\n  Schema,\r\n  SchemaObject,\r\n  AnySchemaObject,\r\n  AsyncSchema,\r\n  AnySchema,\r\n  ValidateFunction,\r\n  AsyncValidateFunction,\r\n  SchemaValidateFunction,\r\n  ErrorObject,\r\n  ErrorNoParams,\r\n} from \"./types\"\r\n\r\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\r\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\r\nexport {KeywordCxt} from \"./compile/validate\"\r\nexport {DefinedError} from \"./vocabularies/errors\"\r\nexport {JSONType} from \"./compile/rules\"\r\nexport {JSONSchemaType} from \"./types/json-schema\"\r\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\r\nexport {default as ValidationError} from \"./runtime/validation_error\"\r\nexport {default as MissingRefError} from \"./compile/ref_error\"\r\n"],
  "mappings": "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",
  "names": ["UsedValueState", "Type", "DataType", "_a", "DiscrError"]
}
