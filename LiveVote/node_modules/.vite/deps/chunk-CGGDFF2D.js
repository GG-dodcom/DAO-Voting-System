import {
  BigNumber,
  proxyMap,
  require_dayjs_min,
  require_en,
  require_relativeTime,
  require_updateLocale,
  subscribeKey,
  z
} from "./chunk-V72YPPB4.js";
import {
  A,
  E,
  k
} from "./chunk-METRIUFS.js";
import {
  require_buffer
} from "./chunk-PVWKNNEO.js";
import {
  proxy,
  ref,
  snapshot,
  subscribe
} from "./chunk-EELTKYKY.js";
import {
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/@web3modal/polyfills/dist/esm/index.js
var import_buffer = __toESM(require_buffer());
var _a;
if (typeof window !== "undefined") {
  if (!window.Buffer) {
    window.Buffer = import_buffer.Buffer;
  }
  if (!window.global) {
    window.global = window;
  }
  if (!window.process) {
    window.process = {};
  }
  if (!((_a = window.process) == null ? void 0 : _a.env)) {
    window.process = { env: {} };
  }
}

// node_modules/@web3modal/common/dist/esm/src/utils/DateUtil.js
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_en = __toESM(require_en(), 1);
var import_relativeTime = __toESM(require_relativeTime(), 1);
var import_updateLocale = __toESM(require_updateLocale(), 1);
import_dayjs.default.extend(import_relativeTime.default);
import_dayjs.default.extend(import_updateLocale.default);
var localeObject = {
  ...import_en.default,
  name: "en-web3-modal",
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "%d sec",
    m: "1 min",
    mm: "%d min",
    h: "1 hr",
    hh: "%d hrs",
    d: "1 d",
    dd: "%d d",
    M: "1 mo",
    MM: "%d mo",
    y: "1 yr",
    yy: "%d yr"
  }
};
import_dayjs.default.locale("en-web3-modal", localeObject);
var DateUtil = {
  getYear(date = (/* @__PURE__ */ new Date()).toISOString()) {
    return (0, import_dayjs.default)(date).year();
  },
  getRelativeDateFromNow(date) {
    return (0, import_dayjs.default)(date).locale("en-web3-modal").fromNow(true);
  },
  formatDate(date, format = "DD MMM") {
    return (0, import_dayjs.default)(date).format(format);
  }
};

// node_modules/@web3modal/common/dist/esm/src/utils/NetworkUtil.js
var NetworkUtil = {
  caipNetworkIdToNumber(caipnetworkId) {
    return caipnetworkId ? Number(caipnetworkId.split(":")[1]) : void 0;
  },
  parseEvmChainId(chainId) {
    return typeof chainId === "string" ? this.caipNetworkIdToNumber(chainId) : chainId;
  }
};

// node_modules/@web3modal/common/dist/esm/src/utils/NumberUtil.js
var NumberUtil = {
  bigNumber(value) {
    return new BigNumber(value);
  },
  multiply(a, b) {
    if (a === void 0 || b === void 0) {
      return BigNumber(0);
    }
    const aBigNumber = new BigNumber(a);
    const bBigNumber = new BigNumber(b);
    return aBigNumber.multipliedBy(bBigNumber);
  },
  formatNumberToLocalString(value, decimals = 2) {
    if (value === void 0) {
      return "0.00";
    }
    if (typeof value === "number") {
      return value.toLocaleString("en-US", {
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals
      });
    }
    return parseFloat(value).toLocaleString("en-US", {
      maximumFractionDigits: decimals,
      minimumFractionDigits: decimals
    });
  }
};

// node_modules/@web3modal/common/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil = {
  WC_NAME_SUFFIX: ".wcn.id",
  BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
  PULSE_API_URL: "https://pulse.walletconnect.org",
  W3M_API_URL: "https://api.web3modal.org",
  CHAIN: {
    EVM: "evm",
    SOLANA: "solana"
  },
  CHAIN_NAME_MAP: {
    evm: "Ethereum",
    solana: "Solana"
  }
};

// node_modules/@web3modal/common/dist/esm/src/utils/ThemeUtil.js
function getW3mThemeVariables(themeVariables, themeType) {
  if (themeType === "light") {
    return {
      "--w3m-accent": (themeVariables == null ? void 0 : themeVariables["--w3m-accent"]) || "hsla(231, 100%, 70%, 1)",
      "--w3m-background": "#fff"
    };
  }
  return {
    "--w3m-accent": (themeVariables == null ? void 0 : themeVariables["--w3m-accent"]) || "hsla(230, 100%, 67%, 1)",
    "--w3m-background": "#121313"
  };
}

// node_modules/@web3modal/common/dist/esm/src/utils/InputUtil.js
var InputUtil = {
  numericInputKeyDown(event, currentValue, onChange) {
    const allowedKeys = [
      "Backspace",
      "Meta",
      "Ctrl",
      "a",
      "A",
      "c",
      "C",
      "x",
      "X",
      "v",
      "V",
      "ArrowLeft",
      "ArrowRight",
      "Tab"
    ];
    const controlPressed = event.metaKey || event.ctrlKey;
    const eventKey = event.key;
    const lowercaseEventKey = eventKey.toLocaleLowerCase();
    const selectAll = lowercaseEventKey === "a";
    const copyKey = lowercaseEventKey === "c";
    const pasteKey = lowercaseEventKey === "v";
    const cutKey = lowercaseEventKey === "x";
    const isComma = eventKey === ",";
    const isDot = eventKey === ".";
    const isNumericKey = eventKey >= "0" && eventKey <= "9";
    if (!controlPressed && (selectAll || copyKey || pasteKey || cutKey)) {
      event.preventDefault();
    }
    if (currentValue === "0" && !isComma && !isDot && eventKey === "0") {
      event.preventDefault();
    }
    if (currentValue === "0" && isNumericKey) {
      onChange(eventKey);
      event.preventDefault();
    }
    if (isComma || isDot) {
      if (!currentValue) {
        onChange("0.");
        event.preventDefault();
      }
      if ((currentValue == null ? void 0 : currentValue.includes(".")) || (currentValue == null ? void 0 : currentValue.includes(","))) {
        event.preventDefault();
      }
    }
    if (!isNumericKey && !allowedKeys.includes(eventKey) && !isDot && !isComma) {
      event.preventDefault();
    }
  }
};

// node_modules/@web3modal/common/dist/esm/src/contracts/erc20.js
var erc20ABI = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  }
];

// node_modules/@web3modal/common/dist/esm/src/utils/NavigationUtil.js
var NavigationUtil = {
  URLS: {
    FAQ: "https://walletconnect.com/faq"
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/ConstantsUtil.js
var SECURE_SITE = "https://secure.walletconnect.org";
var ONRAMP_PROVIDERS = [
  {
    label: "Coinbase",
    name: "coinbase",
    feeRange: "1-2%",
    url: "",
    supportedChains: ["evm"]
  },
  {
    label: "Meld.io",
    name: "meld",
    feeRange: "1-2%",
    url: "https://meldcrypto.com",
    supportedChains: ["evm", "solana"]
  }
];
var MELD_DEV_PUBLIC_KEY = "WXETMsajb7XcQBm7mcxAab:q3MtzJpiEMtXVNXsqYkAnAaBkgStybGVtZ";
var ConstantsUtil2 = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  ONE_SEC_MS: 1e3,
  SECURE_SITE,
  SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
  SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
  RESTRICTED_TIMEZONES: [
    "ASIA/SHANGHAI",
    "ASIA/URUMQI",
    "ASIA/CHONGQING",
    "ASIA/HARBIN",
    "ASIA/KASHGAR",
    "ASIA/MACAU",
    "ASIA/HONG_KONG",
    "ASIA/MACAO",
    "ASIA/BEIJING",
    "ASIA/HARBIN"
  ],
  /**
   * Network name to Coinbase Pay SDK chain name map object
   * @see supported chain names on Coinbase for Pay SDK: https://github.com/coinbase/cbpay-js/blob/d4bda2c05c4d5917c8db6a05476b603546046394/src/types/onramp.ts
   */
  WC_COINBASE_PAY_SDK_CHAINS: [
    "ethereum",
    "arbitrum",
    "polygon",
    "avalanche-c-chain",
    "optimism",
    "celo",
    "base"
  ],
  WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
  WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
    Ethereum: "ethereum",
    "Arbitrum One": "arbitrum",
    Polygon: "polygon",
    Avalanche: "avalanche-c-chain",
    "OP Mainnet": "optimism",
    Celo: "celo",
    Base: "base"
  },
  WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e",
  SWAP_SUGGESTED_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP"
  ],
  SWAP_POPULAR_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP",
    "METAL",
    "DAI",
    "CHAMP",
    "WOLF",
    "SALE",
    "BAL",
    "BUSD",
    "MUST",
    "BTCpx",
    "ROUTE",
    "HEX",
    "WELT",
    "amDAI",
    "VSQ",
    "VISION",
    "AURUM",
    "pSP",
    "SNX",
    "VC",
    "LINK",
    "CHP",
    "amUSDT",
    "SPHERE",
    "FOX",
    "GIDDY",
    "GFC",
    "OMEN",
    "OX_OLD",
    "DE",
    "WNT"
  ],
  SWAP_SUPPORTED_NETWORKS: [
    // Ethereum'
    "eip155:1",
    // Arbitrum One'
    "eip155:42161",
    // Optimism'
    "eip155:10",
    // ZKSync Era'
    "eip155:324",
    // Base'
    "eip155:8453",
    // BNB Smart Chain'
    "eip155:56",
    // Polygon'
    "eip155:137",
    // Gnosis'
    "eip155:100",
    // Avalanche'
    "eip155:43114",
    // Fantom'
    "eip155:250",
    // Klaytn'
    "eip155:8217",
    // Aurora
    "eip155:1313161554"
  ],
  NATIVE_TOKEN_ADDRESS: {
    evm: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    solana: "So11111111111111111111111111111111111111111"
  },
  CONVERT_SLIPPAGE_TOLERANCE: 1,
  DEFAULT_FEATURES: {
    swaps: true,
    onramp: true,
    analytics: true,
    allWallets: "SHOW",
    disableAppend: false,
    enableEIP6963: false
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil = {
  isMobile() {
    if (typeof window !== "undefined") {
      return Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
    }
    return false;
  },
  checkCaipNetwork(network, networkName = "") {
    return network == null ? void 0 : network.id.toLocaleLowerCase().includes(networkName.toLowerCase());
  },
  isAndroid() {
    const ua = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && ua.includes("android");
  },
  isIos() {
    const ua = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && (ua.includes("iphone") || ua.includes("ipad"));
  },
  isClient() {
    return typeof window !== "undefined";
  },
  isPairingExpired(expiry) {
    return expiry ? expiry - Date.now() <= ConstantsUtil2.TEN_SEC_MS : true;
  },
  isAllowedRetry(lastRetry) {
    return Date.now() - lastRetry >= ConstantsUtil2.ONE_SEC_MS;
  },
  copyToClopboard(text) {
    navigator.clipboard.writeText(text);
  },
  getPairingExpiry() {
    return Date.now() + ConstantsUtil2.FOUR_MINUTES_MS;
  },
  getNetworkId(caipAddress) {
    return caipAddress == null ? void 0 : caipAddress.split(":")[1];
  },
  getPlainAddress(caipAddress) {
    return caipAddress == null ? void 0 : caipAddress.split(":")[2];
  },
  async wait(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  debounce(func, timeout = 500) {
    let timer = void 0;
    return (...args) => {
      function next() {
        func(...args);
      }
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(next, timeout);
    };
  },
  isHttpUrl(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  },
  formatNativeUrl(appUrl, wcUri) {
    if (CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.includes("://")) {
      safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
      safeAppUrl = `${safeAppUrl}://`;
    }
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  formatUniversalUrl(appUrl, wcUri) {
    if (!CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  openHref(href, target, features) {
    window.open(href, target, features || "noreferrer noopener");
  },
  returnOpenHref(href, target, features) {
    return window.open(href, target, features || "noreferrer noopener");
  },
  async preloadImage(src) {
    const imagePromise = new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = resolve;
      image.onerror = reject;
      image.crossOrigin = "anonymous";
      image.src = src;
    });
    return Promise.race([imagePromise, CoreHelperUtil.wait(2e3)]);
  },
  formatBalance(balance, symbol) {
    let formattedBalance = "0.000";
    if (typeof balance === "string") {
      const number = Number(balance);
      if (number) {
        const formattedValue = Math.floor(number * 1e3) / 1e3;
        if (formattedValue) {
          formattedBalance = formattedValue.toString();
        }
      }
    }
    return `${formattedBalance}${symbol ? ` ${symbol}` : ""}`;
  },
  formatBalance2(balance, symbol) {
    var _a2;
    let formattedBalance = void 0;
    if (balance === "0") {
      formattedBalance = "0";
    } else if (typeof balance === "string") {
      const number = Number(balance);
      if (number) {
        formattedBalance = (_a2 = number.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : _a2[0];
      }
    }
    return {
      value: formattedBalance ?? "0",
      rest: formattedBalance === "0" ? "000" : "",
      symbol
    };
  },
  getApiUrl() {
    return ConstantsUtil.W3M_API_URL;
  },
  getBlockchainApiUrl() {
    return ConstantsUtil.BLOCKCHAIN_API_RPC_URL;
  },
  getAnalyticsUrl() {
    return ConstantsUtil.PULSE_API_URL;
  },
  getUUID() {
    if (crypto == null ? void 0 : crypto.randomUUID) {
      return crypto.randomUUID();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parseError(error) {
    var _a2, _b;
    if (typeof error === "string") {
      return error;
    } else if (typeof ((_b = (_a2 = error == null ? void 0 : error.issues) == null ? void 0 : _a2[0]) == null ? void 0 : _b.message) === "string") {
      return error.issues[0].message;
    } else if (error instanceof Error) {
      return error.message;
    }
    return "Unknown error";
  },
  sortRequestedNetworks(approvedIds, requestedNetworks = []) {
    const approvedIndexMap = {};
    if (requestedNetworks && approvedIds) {
      approvedIds.forEach((id, index) => {
        approvedIndexMap[id] = index;
      });
      requestedNetworks.sort((a, b) => {
        const indexA = approvedIndexMap[a.id];
        const indexB = approvedIndexMap[b.id];
        if (indexA !== void 0 && indexB !== void 0) {
          return indexA - indexB;
        } else if (indexA !== void 0) {
          return -1;
        } else if (indexB !== void 0) {
          return 1;
        }
        return 0;
      });
    }
    return requestedNetworks;
  },
  calculateBalance(array) {
    let sum = 0;
    for (const item of array) {
      sum += item.value ?? 0;
    }
    return sum;
  },
  formatTokenBalance(number) {
    const roundedNumber = number.toFixed(2);
    const [dollars, pennies] = roundedNumber.split(".");
    return { dollars, pennies };
  },
  isAddress(address, chain = "evm") {
    switch (chain) {
      case "evm":
        if (!/^(?:0x)?[0-9a-f]{40}$/iu.test(address)) {
          return false;
        } else if (/^(?:0x)?[0-9a-f]{40}$/iu.test(address) || /^(?:0x)?[0-9A-F]{40}$/iu.test(address)) {
          return true;
        }
        return false;
      case "solana":
        return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(address);
      default:
        return false;
    }
  },
  uniqueBy(arr, key) {
    const set = /* @__PURE__ */ new Set();
    return arr.filter((item) => {
      const keyValue = item[key];
      if (set.has(keyValue)) {
        return false;
      }
      set.add(keyValue);
      return true;
    });
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/StorageUtil.js
var WC_DEEPLINK = "WALLETCONNECT_DEEPLINK_CHOICE";
var W3M_RECENT = "@w3m/recent";
var W3M_CONNECTED_CONNECTOR = "@w3m/connected_connector";
var W3M_CONNECTED_SOCIAL = "@w3m/connected_social";
var W3M_CONNECTED_SOCIAL_USERNAME = "@w3m-storage/SOCIAL_USERNAME";
var StorageUtil = {
  setWalletConnectDeepLink({ href, name }) {
    try {
      localStorage.setItem(WC_DEEPLINK, JSON.stringify({ href, name }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const deepLink = localStorage.getItem(WC_DEEPLINK);
      if (deepLink) {
        return JSON.parse(deepLink);
      }
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
    return void 0;
  },
  deleteWalletConnectDeepLink() {
    try {
      localStorage.removeItem(WC_DEEPLINK);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setWeb3ModalRecent(wallet) {
    try {
      const recentWallets = StorageUtil.getRecentWallets();
      const exists = recentWallets.find((w) => w.id === wallet.id);
      if (!exists) {
        recentWallets.unshift(wallet);
        if (recentWallets.length > 2) {
          recentWallets.pop();
        }
        localStorage.setItem(W3M_RECENT, JSON.stringify(recentWallets));
      }
    } catch {
      console.info("Unable to set Web3Modal recent");
    }
  },
  getRecentWallets() {
    try {
      const recent = localStorage.getItem(W3M_RECENT);
      return recent ? JSON.parse(recent) : [];
    } catch {
      console.info("Unable to get Web3Modal recent");
    }
    return [];
  },
  setConnectedConnector(connectorType) {
    try {
      localStorage.setItem(W3M_CONNECTED_CONNECTOR, connectorType);
    } catch {
      console.info("Unable to set Connected Connector");
    }
  },
  getConnectedConnector() {
    try {
      return localStorage.getItem(W3M_CONNECTED_CONNECTOR);
    } catch {
      console.info("Unable to get Connected Connector");
    }
    return void 0;
  },
  setConnectedSocialProvider(socialProvider) {
    try {
      localStorage.setItem(W3M_CONNECTED_SOCIAL, socialProvider);
    } catch {
      console.info("Unable to set Connected Social Provider");
    }
  },
  getConnectedSocialProvider() {
    try {
      return localStorage.getItem(W3M_CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to get Connected Social Provider");
    }
    return void 0;
  },
  getConnectedSocialUsername() {
    try {
      return localStorage.getItem(W3M_CONNECTED_SOCIAL_USERNAME);
    } catch {
      console.info("Unable to get Connected Social Username");
    }
    return void 0;
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/FetchUtil.js
async function fetchData(...args) {
  const response = await fetch(...args);
  if (!response.ok) {
    const err = new Error(`HTTP status code: ${response.status}`, {
      cause: response
    });
    throw err;
  }
  return response;
}
var FetchUtil = class {
  constructor({ baseUrl: baseUrl4, clientId }) {
    this.baseUrl = baseUrl4;
    this.clientId = clientId;
  }
  async get({ headers, signal, cache, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, { method: "GET", headers, signal, cache });
    return response.json();
  }
  async getBlob({ headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, { method: "GET", headers, signal });
    return response.blob();
  }
  async post({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "POST",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  async put({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "PUT",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  async delete({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "DELETE",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  createUrl({ path, params }) {
    const url = new URL(path, this.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value) {
          url.searchParams.append(key, value);
        }
      });
    }
    if (this.clientId) {
      url.searchParams.append("clientId", this.clientId);
    }
    return url;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/AssetController.js
var state = proxy({
  walletImages: {},
  networkImages: {},
  chainImages: {},
  connectorImages: {},
  tokenImages: {},
  currencyImages: {}
});
var AssetController = {
  state,
  subscribeNetworkImages(callback) {
    return subscribe(state.networkImages, () => callback(state.networkImages));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state, key, callback);
  },
  subscribe(callback) {
    return subscribe(state, () => callback(state));
  },
  setWalletImage(key, value) {
    state.walletImages[key] = value;
  },
  setNetworkImage(key, value) {
    state.networkImages[key] = value;
  },
  setChainImage(key, value) {
    state.chainImages[key] = value;
  },
  setConnectorImage(key, value) {
    state.connectorImages[key] = value;
  },
  setTokenImage(key, value) {
    state.tokenImages[key] = value;
  },
  setCurrencyImage(key, value) {
    state.currencyImages[key] = value;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/EventsController.js
var baseUrl = CoreHelperUtil.getAnalyticsUrl();
var api = new FetchUtil({ baseUrl, clientId: null });
var excluded = ["MODAL_CREATED"];
var state2 = proxy({
  timestamp: Date.now(),
  data: {
    type: "track",
    event: "MODAL_CREATED"
  }
});
var EventsController = {
  state: state2,
  subscribe(callback) {
    return subscribe(state2, () => callback(state2));
  },
  _getApiHeaders() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  async _sendAnalyticsEvent(payload) {
    try {
      if (excluded.includes(payload.data.event) || typeof window === "undefined") {
        return;
      }
      await api.post({
        path: "/e",
        headers: EventsController._getApiHeaders(),
        body: {
          eventId: CoreHelperUtil.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: payload.timestamp,
          props: payload.data
        }
      });
    } catch {
    }
  },
  sendEvent(data) {
    state2.timestamp = Date.now();
    state2.data = data;
    if (OptionsController.state.enableAnalytics) {
      EventsController._sendAnalyticsEvent(state2);
    }
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/BlockchainApiController.js
var DEFAULT_OPTIONS = {
  purchaseCurrencies: [
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "USD Coin",
      symbol: "USDC",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    },
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "Ether",
      symbol: "ETH",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    }
  ],
  paymentCurrencies: [
    {
      id: "USD",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    },
    {
      id: "EUR",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    }
  ]
};
var baseUrl2 = CoreHelperUtil.getBlockchainApiUrl();
var state3 = proxy({
  clientId: null,
  api: new FetchUtil({ baseUrl: baseUrl2, clientId: null })
});
var BlockchainApiController = {
  state: state3,
  fetchIdentity({ address }) {
    return state3.api.get({
      path: `/v1/identity/${address}`,
      params: {
        projectId: OptionsController.state.projectId,
        sender: AccountController.state.address
      }
    });
  },
  fetchTransactions({ account, projectId, cursor, onramp, signal, cache, chainId }) {
    return state3.api.get({
      path: `/v1/account/${account}/history`,
      params: {
        projectId,
        cursor,
        onramp,
        chainId
      },
      signal,
      cache
    });
  },
  fetchSwapQuote({ projectId, amount, userAddress, from, to, gasPrice }) {
    return state3.api.get({
      path: `/v1/convert/quotes`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        projectId,
        amount,
        userAddress,
        from,
        to,
        gasPrice
      }
    });
  },
  fetchSwapTokens({ projectId, chainId }) {
    return state3.api.get({
      path: `/v1/convert/tokens`,
      params: {
        projectId,
        chainId
      }
    });
  },
  fetchTokenPrice({ projectId, addresses }) {
    return state3.api.post({
      path: "/v1/fungible/price",
      body: {
        projectId,
        currency: "usd",
        addresses
      },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  fetchSwapAllowance({ projectId, tokenAddress, userAddress }) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return state3.api.get({
      path: `/v1/convert/allowance`,
      params: {
        projectId,
        tokenAddress,
        userAddress
      },
      headers: {
        "Content-Type": "application/json",
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      }
    });
  },
  fetchGasPrice({ projectId, chainId }) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return state3.api.get({
      path: `/v1/convert/gas-price`,
      headers: {
        "Content-Type": "application/json",
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      },
      params: {
        projectId,
        chainId
      }
    });
  },
  generateSwapCalldata({ amount, from, projectId, to, userAddress }) {
    return state3.api.post({
      path: "/v1/convert/build-transaction",
      headers: {
        "Content-Type": "application/json"
      },
      body: {
        amount,
        eip155: {
          slippage: ConstantsUtil2.CONVERT_SLIPPAGE_TOLERANCE
        },
        from,
        projectId,
        to,
        userAddress
      }
    });
  },
  generateApproveCalldata({ from, projectId, to, userAddress }) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return state3.api.get({
      path: `/v1/convert/build-approve`,
      headers: {
        "Content-Type": "application/json",
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      },
      params: {
        projectId,
        userAddress,
        from,
        to
      }
    });
  },
  async getBalance(address, chainId, forceUpdate) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return state3.api.get({
      path: `/v1/account/${address}/balance`,
      headers: {
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      },
      params: {
        currency: "usd",
        projectId: OptionsController.state.projectId,
        chainId,
        forceUpdate
      }
    });
  },
  async lookupEnsName(name) {
    return state3.api.get({
      path: `/v1/profile/account/${name}${ConstantsUtil.WC_NAME_SUFFIX}`,
      params: {
        projectId: OptionsController.state.projectId,
        apiVersion: "2"
      }
    });
  },
  async reverseLookupEnsName({ address }) {
    return state3.api.get({
      path: `/v1/profile/reverse/${address}`,
      params: {
        sender: AccountController.state.address,
        projectId: OptionsController.state.projectId,
        apiVersion: "2"
      }
    });
  },
  async getEnsNameSuggestions(name) {
    return state3.api.get({
      path: `/v1/profile/suggestions/${name}`,
      params: {
        projectId: OptionsController.state.projectId
      }
    });
  },
  async registerEnsName({ coinType, address, message, signature }) {
    return state3.api.post({
      path: `/v1/profile/account`,
      body: { coin_type: coinType, address, message, signature },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  async generateOnRampURL({ destinationWallets, partnerUserId, defaultNetwork, purchaseAmount, paymentAmount }) {
    const response = await state3.api.post({
      path: `/v1/generators/onrampurl`,
      params: {
        projectId: OptionsController.state.projectId
      },
      body: {
        destinationWallets,
        defaultNetwork,
        partnerUserId,
        defaultExperience: "buy",
        presetCryptoAmount: purchaseAmount,
        presetFiatAmount: paymentAmount
      }
    });
    return response.url;
  },
  async getOnrampOptions() {
    try {
      const response = await state3.api.get({
        path: `/v1/onramp/options`,
        params: {
          projectId: OptionsController.state.projectId
        }
      });
      return response;
    } catch (e) {
      return DEFAULT_OPTIONS;
    }
  },
  async getOnrampQuote({ purchaseCurrency, paymentCurrency, amount, network }) {
    try {
      const response = await state3.api.post({
        path: `/v1/onramp/quote`,
        params: {
          projectId: OptionsController.state.projectId
        },
        body: {
          purchaseCurrency,
          paymentCurrency,
          amount,
          network
        }
      });
      return response;
    } catch (e) {
      return {
        coinbaseFee: { amount, currency: paymentCurrency.id },
        networkFee: { amount, currency: paymentCurrency.id },
        paymentSubtotal: { amount, currency: paymentCurrency.id },
        paymentTotal: { amount, currency: paymentCurrency.id },
        purchaseAmount: { amount, currency: paymentCurrency.id },
        quoteId: "mocked-quote-id"
      };
    }
  },
  setClientId(clientId) {
    state3.clientId = clientId;
    state3.api = new FetchUtil({ baseUrl: baseUrl2, clientId });
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/SnackController.js
var state4 = proxy({
  message: "",
  variant: "success",
  open: false
});
var SnackController = {
  state: state4,
  subscribeKey(key, callback) {
    return subscribeKey(state4, key, callback);
  },
  showLoading(message) {
    state4.message = message;
    state4.variant = "loading";
    state4.open = true;
  },
  showSuccess(message) {
    state4.message = message;
    state4.variant = "success";
    state4.open = true;
  },
  showError(message) {
    const errorMessage = CoreHelperUtil.parseError(message);
    state4.message = errorMessage;
    state4.variant = "error";
    state4.open = true;
  },
  hide() {
    state4.open = false;
  }
};

// node_modules/@web3modal/wallet/dist/esm/src/W3mFrameConstants.js
var SECURE_SITE_SDK = process.env["NEXT_PUBLIC_SECURE_SITE_SDK_URL"] || "https://secure.walletconnect.org/sdk";
var DEFAULT_LOG_LEVEL = process.env["NEXT_PUBLIC_DEFAULT_LOG_LEVEL"] || "error";
var W3mFrameConstants = {
  APP_EVENT_KEY: "@w3m-app/",
  FRAME_EVENT_KEY: "@w3m-frame/",
  RPC_METHOD_KEY: "RPC_",
  STORAGE_KEY: "@w3m-storage/",
  SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
  EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
  LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
  LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
  EMAIL: "EMAIL",
  PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
  SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
  SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
  SOCIAL_USERNAME: "SOCIAL_USERNAME",
  SOCIAL: "@w3m/connected_social",
  APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
  APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
  APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
  APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
  APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
  APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
  APP_GET_USER: "@w3m-app/GET_USER",
  APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
  APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
  APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
  APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
  APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
  APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
  APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
  APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
  APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
  APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
  APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
  APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
  APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
  APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
  APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
  FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
  FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
  FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
  FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
  FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
  FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
  FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
  FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
  FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
  FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
  FRAME_CONNECT_FARCASTER_SUCCESS: "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
  FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
  FRAME_GET_FARCASTER_URI_SUCCESS: "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
  FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
  FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
  FRAME_GET_SOCIAL_REDIRECT_URI_ERROR: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
  FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
  FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
  FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
  FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
  FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
  FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
  FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
  FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
  FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
  FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
  FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
  FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
  FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
  FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
  FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
  FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
  FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
  FRAME_INIT_SMART_ACCOUNT_SUCCESS: "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
  FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
  FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
  FRAME_SET_PREFERRED_ACCOUNT_ERROR: "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
  RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
  RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
  RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT"
};
var W3mFrameRpcConstants = {
  SAFE_RPC_METHODS: [
    "eth_accounts",
    "eth_blockNumber",
    "eth_call",
    "eth_chainId",
    "eth_estimateGas",
    "eth_feeHistory",
    "eth_gasPrice",
    "eth_getAccount",
    "eth_getBalance",
    "eth_getBlockByHash",
    "eth_getBlockByNumber",
    "eth_getBlockReceipts",
    "eth_getBlockTransactionCountByHash",
    "eth_getBlockTransactionCountByNumber",
    "eth_getCode",
    "eth_getFilterChanges",
    "eth_getFilterLogs",
    "eth_getLogs",
    "eth_getProof",
    "eth_getStorageAt",
    "eth_getTransactionByBlockHashAndIndex",
    "eth_getTransactionByBlockNumberAndIndex",
    "eth_getTransactionByHash",
    "eth_getTransactionCount",
    "eth_getTransactionReceipt",
    "eth_getUncleCountByBlockHash",
    "eth_getUncleCountByBlockNumber",
    "eth_maxPriorityFeePerGas",
    "eth_newBlockFilter",
    "eth_newFilter",
    "eth_newPendingTransactionFilter",
    "eth_sendRawTransaction",
    "eth_syncing",
    "eth_uninstallFilter",
    "wallet_getCapabilities",
    "wallet_getCallsStatus",
    "eth_getUserOperationReceipt",
    "eth_estimateUserOperationGas",
    "eth_getUserOperationByHash",
    "eth_supportedEntryPoints"
  ],
  NOT_SAFE_RPC_METHODS: [
    "personal_sign",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "solana_signMessage",
    "solana_signTransaction",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction",
    "wallet_sendCalls",
    "wallet_grantPermissions",
    "eth_sendUserOperation"
  ],
  GET_CHAIN_ID: "eth_chainId",
  RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
  RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
  ACCOUNT_TYPES: {
    EOA: "eoa",
    SMART_ACCOUNT: "smartAccount"
  }
};

// node_modules/@web3modal/wallet/dist/esm/src/W3mFrameSchema.js
var zError = z.object({ message: z.string() });
function zType(key) {
  return z.literal(W3mFrameConstants[key]);
}
var GetTransactionByHashResponse = z.object({
  accessList: z.array(z.string()),
  blockHash: z.string().nullable(),
  blockNumber: z.string().nullable(),
  chainId: z.string().or(z.number()),
  from: z.string(),
  gas: z.string(),
  hash: z.string(),
  input: z.string().nullable(),
  maxFeePerGas: z.string(),
  maxPriorityFeePerGas: z.string(),
  nonce: z.string(),
  r: z.string(),
  s: z.string(),
  to: z.string(),
  transactionIndex: z.string().nullable(),
  type: z.string(),
  v: z.string(),
  value: z.string()
});
var AppSwitchNetworkRequest = z.object({ chainId: z.string().or(z.number()) });
var AppConnectEmailRequest = z.object({ email: z.string().email() });
var AppConnectOtpRequest = z.object({ otp: z.string() });
var AppConnectSocialRequest = z.object({ uri: z.string() });
var AppGetUserRequest = z.object({
  chainId: z.optional(z.string().or(z.number())),
  preferredAccountType: z.optional(z.string())
});
var AppGetSocialRedirectUriRequest = z.object({
  provider: z.enum(["google", "github", "apple", "facebook", "x", "discord"])
});
var AppUpdateEmailRequest = z.object({ email: z.string().email() });
var AppUpdateEmailPrimaryOtpRequest = z.object({ otp: z.string() });
var AppUpdateEmailSecondaryOtpRequest = z.object({ otp: z.string() });
var AppSyncThemeRequest = z.object({
  themeMode: z.optional(z.enum(["light", "dark"])),
  themeVariables: z.optional(z.record(z.string(), z.string().or(z.number()))),
  w3mThemeVariables: z.optional(z.record(z.string(), z.string()))
});
var AppSyncDappDataRequest = z.object({
  metadata: z.object({
    name: z.string(),
    description: z.string(),
    url: z.string(),
    icons: z.array(z.string())
  }).optional(),
  sdkVersion: z.string(),
  projectId: z.string()
});
var AppSetPreferredAccountRequest = z.object({ type: z.string() });
var FrameConnectEmailResponse = z.object({
  action: z.enum(["VERIFY_DEVICE", "VERIFY_OTP"])
});
var FrameGetFarcasterUriResponse = z.object({
  url: z.string()
});
var FrameConnectFarcasterResponse = z.object({
  userName: z.string()
});
var FrameConnectSocialResponse = z.object({
  email: z.string(),
  address: z.string(),
  chainId: z.string().or(z.number()),
  accounts: z.array(z.object({
    address: z.string(),
    type: z.enum([
      W3mFrameRpcConstants.ACCOUNT_TYPES.EOA,
      W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
    ])
  })).optional(),
  userName: z.string().optional()
});
var FrameUpdateEmailResponse = z.object({
  action: z.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"])
});
var FrameGetUserResponse = z.object({
  email: z.string().email().optional().nullable(),
  address: z.string(),
  chainId: z.string().or(z.number()),
  smartAccountDeployed: z.optional(z.boolean()),
  accounts: z.array(z.object({
    address: z.string(),
    type: z.enum([
      W3mFrameRpcConstants.ACCOUNT_TYPES.EOA,
      W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
    ])
  })).optional(),
  preferredAccountType: z.optional(z.string())
});
var FrameGetSocialRedirectUriResponse = z.object({ uri: z.string() });
var FrameIsConnectedResponse = z.object({ isConnected: z.boolean() });
var FrameGetChainIdResponse = z.object({ chainId: z.string().or(z.number()) });
var FrameSwitchNetworkResponse = z.object({ chainId: z.string().or(z.number()) });
var FrameUpdateEmailSecondaryOtpResponse = z.object({ newEmail: z.string().email() });
var FrameGetSmartAccountEnabledNetworksResponse = z.object({
  smartAccountEnabledNetworks: z.array(z.number())
});
var FrameInitSmartAccountResponse = z.object({
  address: z.string(),
  isDeployed: z.boolean()
});
var FrameSetPreferredAccountResponse = z.object({ type: z.string(), address: z.string() });
var RpcResponse = z.any();
var RpcEthAccountsRequest = z.object({
  method: z.literal("eth_accounts")
});
var RpcEthBlockNumber = z.object({
  method: z.literal("eth_blockNumber")
});
var RpcEthCall = z.object({
  method: z.literal("eth_call"),
  params: z.array(z.any())
});
var RpcEthChainId = z.object({
  method: z.literal("eth_chainId")
});
var RpcEthEstimateGas = z.object({
  method: z.literal("eth_estimateGas"),
  params: z.array(z.any())
});
var RpcEthFeeHistory = z.object({
  method: z.literal("eth_feeHistory"),
  params: z.array(z.any())
});
var RpcEthGasPrice = z.object({
  method: z.literal("eth_gasPrice")
});
var RpcEthGetAccount = z.object({
  method: z.literal("eth_getAccount"),
  params: z.array(z.any())
});
var RpcEthGetBalance = z.object({
  method: z.literal("eth_getBalance"),
  params: z.array(z.any())
});
var RpcEthGetBlockyByHash = z.object({
  method: z.literal("eth_getBlockByHash"),
  params: z.array(z.any())
});
var RpcEthGetBlockByNumber = z.object({
  method: z.literal("eth_getBlockByNumber"),
  params: z.array(z.any())
});
var RpcEthGetBlockReceipts = z.object({
  method: z.literal("eth_getBlockReceipts"),
  params: z.array(z.any())
});
var RcpEthGetBlockTransactionCountByHash = z.object({
  method: z.literal("eth_getBlockTransactionCountByHash"),
  params: z.array(z.any())
});
var RcpEthGetBlockTransactionCountByNumber = z.object({
  method: z.literal("eth_getBlockTransactionCountByNumber"),
  params: z.array(z.any())
});
var RpcEthGetCode = z.object({
  method: z.literal("eth_getCode"),
  params: z.array(z.any())
});
var RpcEthGetFilter = z.object({
  method: z.literal("eth_getFilterChanges"),
  params: z.array(z.any())
});
var RpcEthGetFilterLogs = z.object({
  method: z.literal("eth_getFilterLogs"),
  params: z.array(z.any())
});
var RpcEthGetLogs = z.object({
  method: z.literal("eth_getLogs"),
  params: z.array(z.any())
});
var RpcEthGetProof = z.object({
  method: z.literal("eth_getProof"),
  params: z.array(z.any())
});
var RpcEthGetStorageAt = z.object({
  method: z.literal("eth_getStorageAt"),
  params: z.array(z.any())
});
var RpcEthGetTransactionByBlockHashAndIndex = z.object({
  method: z.literal("eth_getTransactionByBlockHashAndIndex"),
  params: z.array(z.any())
});
var RpcEthGetTransactionByBlockNumberAndIndex = z.object({
  method: z.literal("eth_getTransactionByBlockNumberAndIndex"),
  params: z.array(z.any())
});
var RpcEthGetTransactionByHash = z.object({
  method: z.literal("eth_getTransactionByHash"),
  params: z.array(z.any())
});
var RpcEthGetTransactionCount = z.object({
  method: z.literal("eth_getTransactionCount"),
  params: z.array(z.any())
});
var RpcEthGetTransactionReceipt = z.object({
  method: z.literal("eth_getTransactionReceipt"),
  params: z.array(z.any())
});
var RpcEthGetUncleCountByBlockHash = z.object({
  method: z.literal("eth_getUncleCountByBlockHash"),
  params: z.array(z.any())
});
var RpcEthGetUncleCountByBlockNumber = z.object({
  method: z.literal("eth_getUncleCountByBlockNumber"),
  params: z.array(z.any())
});
var RpcEthMaxPriorityFeePerGas = z.object({
  method: z.literal("eth_maxPriorityFeePerGas")
});
var RpcEthNewBlockFilter = z.object({
  method: z.literal("eth_newBlockFilter")
});
var RpcEthNewFilter = z.object({
  method: z.literal("eth_newFilter"),
  params: z.array(z.any())
});
var RpcEthNewPendingTransactionFilter = z.object({
  method: z.literal("eth_newPendingTransactionFilter")
});
var RpcEthSendRawTransaction = z.object({
  method: z.literal("eth_sendRawTransaction"),
  params: z.array(z.any())
});
var RpcEthSyncing = z.object({
  method: z.literal("eth_syncing"),
  params: z.array(z.any())
});
var RpcUnistallFilter = z.object({
  method: z.literal("eth_uninstallFilter"),
  params: z.array(z.any())
});
var RpcPersonalSignRequest = z.object({
  method: z.literal("personal_sign"),
  params: z.array(z.any())
});
var RpcEthSignTypedDataV4 = z.object({
  method: z.literal("eth_signTypedData_v4"),
  params: z.array(z.any())
});
var RpcEthSendTransactionRequest = z.object({
  method: z.literal("eth_sendTransaction"),
  params: z.array(z.any())
});
var RpcSolanaSignMessageRequest = z.object({
  method: z.literal("solana_signMessage"),
  params: z.object({
    message: z.string(),
    pubkey: z.string()
  })
});
var RpcSolanaSignTransactionRequest = z.object({
  method: z.literal("solana_signTransaction"),
  params: z.object({
    transaction: z.string()
  })
});
var RpcSolanaSignAllTransactionsRequest = z.object({
  method: z.literal("solana_signAllTransactions"),
  params: z.object({
    transactions: z.array(z.string())
  })
});
var RpcSolanaSignAndSendTransactionRequest = z.object({
  method: z.literal("solana_signAndSendTransaction"),
  params: z.object({
    transaction: z.string(),
    options: z.object({
      skipPreflight: z.boolean().optional(),
      preflightCommitment: z.enum([
        "processed",
        "confirmed",
        "finalized",
        "recent",
        "single",
        "singleGossip",
        "root",
        "max"
      ]).optional(),
      maxRetries: z.number().optional(),
      minContextSlot: z.number().optional()
    }).optional()
  })
});
var WalletSendCallsRequest = z.object({
  method: z.literal("wallet_sendCalls"),
  params: z.array(z.object({
    chainId: z.string().or(z.number()).optional(),
    from: z.string().optional(),
    version: z.string().optional(),
    capabilities: z.any().optional(),
    calls: z.array(z.object({
      to: z.string().startsWith("0x"),
      data: z.string().startsWith("0x").optional(),
      value: z.string().optional()
    }))
  }))
});
var WalletGetCallsReceiptRequest = z.object({
  method: z.literal("wallet_getCallsStatus"),
  params: z.array(z.string())
});
var WalletGetCapabilitiesRequest = z.object({
  method: z.literal("wallet_getCapabilities")
});
var WalletGrantPermissionsRequest = z.object({
  method: z.literal("wallet_grantPermissions"),
  params: z.array(z.any())
});
var FrameSession = z.object({
  token: z.string()
});
var EventSchema = z.object({
  id: z.string().optional()
});
var W3mFrameSchema = {
  appEvent: EventSchema.extend({
    type: zType("APP_SWITCH_NETWORK"),
    payload: AppSwitchNetworkRequest
  }).or(EventSchema.extend({
    type: zType("APP_CONNECT_EMAIL"),
    payload: AppConnectEmailRequest
  })).or(EventSchema.extend({ type: zType("APP_CONNECT_DEVICE") })).or(EventSchema.extend({ type: zType("APP_CONNECT_OTP"), payload: AppConnectOtpRequest })).or(EventSchema.extend({
    type: zType("APP_CONNECT_SOCIAL"),
    payload: AppConnectSocialRequest
  })).or(EventSchema.extend({ type: zType("APP_GET_FARCASTER_URI") })).or(EventSchema.extend({ type: zType("APP_CONNECT_FARCASTER") })).or(EventSchema.extend({
    type: zType("APP_GET_USER"),
    payload: z.optional(AppGetUserRequest)
  })).or(EventSchema.extend({
    type: zType("APP_GET_SOCIAL_REDIRECT_URI"),
    payload: AppGetSocialRedirectUriRequest
  })).or(EventSchema.extend({ type: zType("APP_SIGN_OUT") })).or(EventSchema.extend({
    type: zType("APP_IS_CONNECTED"),
    payload: z.optional(FrameSession)
  })).or(EventSchema.extend({ type: zType("APP_GET_CHAIN_ID") })).or(EventSchema.extend({ type: zType("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") })).or(EventSchema.extend({ type: zType("APP_INIT_SMART_ACCOUNT") })).or(EventSchema.extend({
    type: zType("APP_SET_PREFERRED_ACCOUNT"),
    payload: AppSetPreferredAccountRequest
  })).or(EventSchema.extend({
    type: zType("APP_RPC_REQUEST"),
    payload: RpcPersonalSignRequest.or(RpcEthSendTransactionRequest).or(RpcEthAccountsRequest).or(RpcEthBlockNumber).or(RpcEthCall).or(RpcEthChainId).or(RpcEthEstimateGas).or(RpcEthFeeHistory).or(RpcEthGasPrice).or(RpcEthGetAccount).or(RpcEthGetBalance).or(RpcEthGetBlockyByHash).or(RpcEthGetBlockByNumber).or(RpcEthGetBlockReceipts).or(RcpEthGetBlockTransactionCountByHash).or(RcpEthGetBlockTransactionCountByNumber).or(RpcEthGetCode).or(RpcEthGetFilter).or(RpcEthGetFilterLogs).or(RpcEthGetLogs).or(RpcEthGetProof).or(RpcEthGetStorageAt).or(RpcEthGetTransactionByBlockHashAndIndex).or(RpcEthGetTransactionByBlockNumberAndIndex).or(RpcEthGetTransactionByHash).or(RpcEthGetTransactionCount).or(RpcEthGetTransactionReceipt).or(RpcEthGetUncleCountByBlockHash).or(RpcEthGetUncleCountByBlockNumber).or(RpcEthMaxPriorityFeePerGas).or(RpcEthNewBlockFilter).or(RpcEthNewFilter).or(RpcEthNewPendingTransactionFilter).or(RpcEthSendRawTransaction).or(RpcEthSyncing).or(RpcUnistallFilter).or(RpcPersonalSignRequest).or(RpcEthSignTypedDataV4).or(RpcEthSendTransactionRequest).or(RpcSolanaSignMessageRequest).or(RpcSolanaSignTransactionRequest).or(RpcSolanaSignAllTransactionsRequest).or(RpcSolanaSignAndSendTransactionRequest).or(WalletGetCallsReceiptRequest).or(WalletSendCallsRequest).or(WalletGetCapabilitiesRequest).or(WalletGrantPermissionsRequest)
  })).or(EventSchema.extend({ type: zType("APP_UPDATE_EMAIL"), payload: AppUpdateEmailRequest })).or(EventSchema.extend({
    type: zType("APP_UPDATE_EMAIL_PRIMARY_OTP"),
    payload: AppUpdateEmailPrimaryOtpRequest
  })).or(EventSchema.extend({
    type: zType("APP_UPDATE_EMAIL_SECONDARY_OTP"),
    payload: AppUpdateEmailSecondaryOtpRequest
  })).or(EventSchema.extend({ type: zType("APP_SYNC_THEME"), payload: AppSyncThemeRequest })).or(EventSchema.extend({
    type: zType("APP_SYNC_DAPP_DATA"),
    payload: AppSyncDappDataRequest
  })),
  frameEvent: EventSchema.extend({ type: zType("FRAME_SWITCH_NETWORK_ERROR"), payload: zError }).or(EventSchema.extend({
    type: zType("FRAME_SWITCH_NETWORK_SUCCESS"),
    payload: FrameSwitchNetworkResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_EMAIL_SUCCESS"),
    payload: FrameConnectEmailResponse
  })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_EMAIL_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_GET_FARCASTER_URI_SUCCESS"),
    payload: FrameGetFarcasterUriResponse
  })).or(EventSchema.extend({ type: zType("FRAME_GET_FARCASTER_URI_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_FARCASTER_SUCCESS"),
    payload: FrameConnectFarcasterResponse
  })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_FARCASTER_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_OTP_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_OTP_SUCCESS") })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_DEVICE_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_DEVICE_SUCCESS") })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_SOCIAL_SUCCESS"),
    payload: FrameConnectSocialResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_SOCIAL_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_GET_USER_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_GET_USER_SUCCESS"),
    payload: FrameGetUserResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"),
    payload: zError
  })).or(EventSchema.extend({
    type: zType("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
    payload: FrameGetSocialRedirectUriResponse
  })).or(EventSchema.extend({ type: zType("FRAME_SIGN_OUT_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_SIGN_OUT_SUCCESS") })).or(EventSchema.extend({ type: zType("FRAME_IS_CONNECTED_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_IS_CONNECTED_SUCCESS"),
    payload: FrameIsConnectedResponse
  })).or(EventSchema.extend({ type: zType("FRAME_GET_CHAIN_ID_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_GET_CHAIN_ID_SUCCESS"),
    payload: FrameGetChainIdResponse
  })).or(EventSchema.extend({ type: zType("FRAME_RPC_REQUEST_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_RPC_REQUEST_SUCCESS"), payload: RpcResponse })).or(EventSchema.extend({ type: zType("FRAME_SESSION_UPDATE"), payload: FrameSession })).or(EventSchema.extend({ type: zType("FRAME_UPDATE_EMAIL_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_SUCCESS"),
    payload: FrameUpdateEmailResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
    payload: zError
  })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
    payload: FrameUpdateEmailSecondaryOtpResponse
  })).or(EventSchema.extend({ type: zType("FRAME_SYNC_THEME_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_SYNC_THEME_SUCCESS") })).or(EventSchema.extend({ type: zType("FRAME_SYNC_DAPP_DATA_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_SYNC_DAPP_DATA_SUCCESS") })).or(EventSchema.extend({
    type: zType("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
    payload: FrameGetSmartAccountEnabledNetworksResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_INIT_SMART_ACCOUNT_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
    payload: FrameSetPreferredAccountResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_SET_PREFERRED_ACCOUNT_ERROR"),
    payload: zError
  }))
};

// node_modules/@web3modal/wallet/dist/esm/src/W3mFrameStorage.js
var W3mFrameStorage = {
  set(key, value) {
    if (W3mFrameHelpers.isClient) {
      localStorage.setItem(`${W3mFrameConstants.STORAGE_KEY}${key}`, value);
    }
  },
  get(key) {
    if (W3mFrameHelpers.isClient) {
      return localStorage.getItem(`${W3mFrameConstants.STORAGE_KEY}${key}`);
    }
    return null;
  },
  delete(key, social) {
    if (W3mFrameHelpers.isClient) {
      if (social) {
        localStorage.removeItem(key);
      } else {
        localStorage.removeItem(`${W3mFrameConstants.STORAGE_KEY}${key}`);
      }
    }
  }
};

// node_modules/@web3modal/wallet/dist/esm/src/RegexUtil.js
var RegexUtil = {
  address: /^0x(?:[A-Fa-f0-9]{40})$/u,
  transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
  signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u
};

// node_modules/@web3modal/wallet/dist/esm/src/W3mFrameHelpers.js
var EMAIL_MINIMUM_TIMEOUT = 30 * 1e3;
var W3mFrameHelpers = {
  checkIfAllowedToTriggerEmail() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        const cooldownSec = Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
        throw new Error(`Please try again after ${cooldownSec} seconds`);
      }
    }
  },
  getTimeToNextEmailLogin() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        return Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
      }
    }
    return 0;
  },
  checkIfRequestExists(request) {
    return W3mFrameRpcConstants.NOT_SAFE_RPC_METHODS.includes(request.method) || W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(request.method);
  },
  getResponseType(response) {
    const isPayloadString = typeof response === "string";
    const isTransactionHash = isPayloadString && ((response == null ? void 0 : response.match(RegexUtil.transactionHash)) || (response == null ? void 0 : response.match(RegexUtil.signedMessage)));
    if (isTransactionHash) {
      return W3mFrameConstants.RPC_RESPONSE_TYPE_TX;
    }
    return W3mFrameConstants.RPC_RESPONSE_TYPE_OBJECT;
  },
  checkIfRequestIsSafe(request) {
    return W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(request.method);
  },
  isClient: typeof window !== "undefined"
};

// node_modules/@web3modal/wallet/dist/esm/src/W3mFrame.js
var W3mFrame = class {
  constructor(projectId, isAppClient = false, chainId = "eip155:1") {
    this.iframe = null;
    this.rpcUrl = ConstantsUtil.BLOCKCHAIN_API_RPC_URL;
    this.events = {
      registerFrameEventHandler: (id, callback, signal) => {
        function eventHandler({ data }) {
          var _a2;
          if (!((_a2 = data.type) == null ? void 0 : _a2.includes(W3mFrameConstants.FRAME_EVENT_KEY))) {
            return;
          }
          const frameEvent = W3mFrameSchema.frameEvent.parse(data);
          if (frameEvent.id === id) {
            callback(frameEvent);
            window.removeEventListener("message", eventHandler);
          }
        }
        if (W3mFrameHelpers.isClient) {
          window.addEventListener("message", eventHandler);
          signal.addEventListener("abort", () => {
            window.removeEventListener("message", eventHandler);
          });
        }
      },
      onFrameEvent: (callback) => {
        if (W3mFrameHelpers.isClient) {
          window.addEventListener("message", ({ data }) => {
            var _a2;
            if (!((_a2 = data.type) == null ? void 0 : _a2.includes(W3mFrameConstants.FRAME_EVENT_KEY))) {
              return;
            }
            const frameEvent = W3mFrameSchema.frameEvent.parse(data);
            callback(frameEvent);
          });
        }
      },
      onAppEvent: (callback) => {
        if (W3mFrameHelpers.isClient) {
          window.addEventListener("message", ({ data }) => {
            var _a2;
            if (!((_a2 = data.type) == null ? void 0 : _a2.includes(W3mFrameConstants.APP_EVENT_KEY))) {
              return;
            }
            const appEvent = W3mFrameSchema.appEvent.parse(data);
            callback(appEvent);
          });
        }
      },
      postAppEvent: (event) => {
        var _a2;
        if (W3mFrameHelpers.isClient) {
          if (!((_a2 = this.iframe) == null ? void 0 : _a2.contentWindow)) {
            throw new Error("W3mFrame: iframe is not set");
          }
          W3mFrameSchema.appEvent.parse(event);
          this.iframe.contentWindow.postMessage(event, "*");
        }
      },
      postFrameEvent: (event) => {
        if (W3mFrameHelpers.isClient) {
          if (!parent) {
            throw new Error("W3mFrame: parent is not set");
          }
          W3mFrameSchema.frameEvent.parse(event);
          parent.postMessage(event, "*");
        }
      }
    };
    this.projectId = projectId;
    this.frameLoadPromise = new Promise((resolve, reject) => {
      this.frameLoadPromiseResolver = { resolve, reject };
    });
    if (isAppClient) {
      this.frameLoadPromise = new Promise((resolve, reject) => {
        this.frameLoadPromiseResolver = { resolve, reject };
      });
      if (W3mFrameHelpers.isClient) {
        const iframe = document.createElement("iframe");
        iframe.id = "w3m-iframe";
        iframe.src = `${SECURE_SITE_SDK}?projectId=${projectId}&chainId=${chainId}`;
        iframe.name = "w3m-secure-iframe";
        iframe.style.position = "fixed";
        iframe.style.zIndex = "999999";
        iframe.style.display = "none";
        iframe.style.animationDelay = "0s, 50ms";
        iframe.style.borderBottomLeftRadius = `clamp(0px, var(--wui-border-radius-l), 44px)`;
        iframe.style.borderBottomRightRadius = `clamp(0px, var(--wui-border-radius-l), 44px)`;
        document.body.appendChild(iframe);
        this.iframe = iframe;
        this.iframe.onload = () => {
          var _a2;
          (_a2 = this.frameLoadPromiseResolver) == null ? void 0 : _a2.resolve(void 0);
        };
        this.iframe.onerror = () => {
          var _a2;
          (_a2 = this.frameLoadPromiseResolver) == null ? void 0 : _a2.reject("Unable to load email login dependency");
        };
      }
    }
  }
  get networks() {
    const data = [
      "eip155:1",
      "eip155:5",
      "eip155:11155111",
      "eip155:10",
      "eip155:420",
      "eip155:42161",
      "eip155:421613",
      "eip155:137",
      "eip155:80001",
      "eip155:42220",
      "eip155:1313161554",
      "eip155:1313161555",
      "eip155:56",
      "eip155:97",
      "eip155:43114",
      "eip155:43113",
      "eip155:324",
      "eip155:280",
      "eip155:100",
      "eip155:8453",
      "eip155:84531",
      "eip155:84532",
      "eip155:7777777",
      "eip155:999",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ].map((id) => ({
      [id]: {
        rpcUrl: `${this.rpcUrl}/v1/?chainId=${id}&projectId=${this.projectId}`,
        chainId: id
      }
    }));
    return Object.assign({}, ...data);
  }
};

// node_modules/@web3modal/wallet/dist/esm/src/W3mFrameLogger.js
var W3mFrameLogger = class {
  constructor(projectId) {
    var _a2;
    const loggerOptions = k({
      level: DEFAULT_LOG_LEVEL
    });
    const { logger, chunkLoggerController } = A({
      opts: loggerOptions
    });
    this.logger = E(logger, this.constructor.name);
    this.chunkLoggerController = chunkLoggerController;
    if (typeof window !== "undefined" && ((_a2 = this.chunkLoggerController) == null ? void 0 : _a2.downloadLogsBlobInBrowser)) {
      if (!window.downloadAppKitLogsBlob) {
        window.downloadAppKitLogsBlob = {};
      }
      window.downloadAppKitLogsBlob["sdk"] = () => {
        var _a3;
        if ((_a3 = this.chunkLoggerController) == null ? void 0 : _a3.downloadLogsBlobInBrowser) {
          this.chunkLoggerController.downloadLogsBlobInBrowser({
            projectId
          });
        }
      };
    }
  }
};

// node_modules/@web3modal/wallet/dist/esm/src/W3mFrameProvider.js
var W3mFrameProvider = class {
  constructor(projectId, chainId) {
    this.openRpcRequests = [];
    this.w3mLogger = new W3mFrameLogger(projectId);
    this.w3mFrame = new W3mFrame(projectId, true, chainId);
  }
  getLoginEmailUsed() {
    return Boolean(W3mFrameStorage.get(W3mFrameConstants.EMAIL_LOGIN_USED_KEY));
  }
  getEmail() {
    return W3mFrameStorage.get(W3mFrameConstants.EMAIL);
  }
  async connectEmail(payload) {
    try {
      W3mFrameHelpers.checkIfAllowedToTriggerEmail();
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_EMAIL,
        payload
      });
      this.setNewLastEmailLoginTime();
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting email");
      throw error;
    }
  }
  async connectDevice() {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_DEVICE
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting device");
      throw error;
    }
  }
  async connectOtp(payload) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_OTP,
        payload
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting otp");
      throw error;
    }
  }
  async isConnected() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_IS_CONNECTED
      });
      if (!response.isConnected) {
        this.deleteAuthLoginCache();
      }
      return response;
    } catch (error) {
      this.deleteAuthLoginCache();
      this.w3mLogger.logger.error({ error }, "Error checking connection");
      throw error;
    }
  }
  async getChainId() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_CHAIN_ID
      });
      this.setLastUsedChainId(response.chainId);
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error getting chain id");
      throw error;
    }
  }
  async getSocialRedirectUri(payload) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_GET_SOCIAL_REDIRECT_URI,
        payload
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error getting social redirect uri");
      throw error;
    }
  }
  async updateEmail(payload) {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_UPDATE_EMAIL,
        payload
      });
      this.setNewLastEmailLoginTime();
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error updating email");
      throw error;
    }
  }
  async updateEmailPrimaryOtp(payload) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_UPDATE_EMAIL_PRIMARY_OTP,
        payload
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error updating email primary otp");
      throw error;
    }
  }
  async updateEmailSecondaryOtp(payload) {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_UPDATE_EMAIL_SECONDARY_OTP,
        payload
      });
      this.setLoginSuccess(response.newEmail);
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error updating email secondary otp");
      throw error;
    }
  }
  async syncTheme(payload) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_SYNC_THEME,
        payload
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error syncing theme");
      throw error;
    }
  }
  async syncDappData(payload) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_SYNC_DAPP_DATA,
        payload
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error syncing dapp data");
      throw error;
    }
  }
  async getSmartAccountEnabledNetworks() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS
      });
      this.persistSmartAccountEnabledNetworks(response.smartAccountEnabledNetworks);
      return response;
    } catch (error) {
      this.persistSmartAccountEnabledNetworks([]);
      this.w3mLogger.logger.error({ error }, "Error getting smart account enabled networks");
      throw error;
    }
  }
  async setPreferredAccount(type) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_SET_PREFERRED_ACCOUNT,
        payload: { type }
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error setting preferred account");
      throw error;
    }
  }
  async connect(payload) {
    try {
      const chainId = (payload == null ? void 0 : payload.chainId) ?? this.getLastUsedChainId() ?? 1;
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_USER,
        payload: { ...payload, chainId }
      });
      this.setLoginSuccess(response.email);
      this.setLastUsedChainId(response.chainId);
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting");
      throw error;
    }
  }
  async connectSocial(uri) {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_SOCIAL,
        payload: { uri }
      });
      if (response.userName) {
        this.setSocialLoginSuccess(response.userName);
      }
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting social");
      throw error;
    }
  }
  async getFarcasterUri() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_FARCASTER_URI
      });
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error getting farcaster uri");
      throw error;
    }
  }
  async connectFarcaster() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_FARCASTER
      });
      if (response.userName) {
        this.setSocialLoginSuccess(response.userName);
      }
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting farcaster");
      throw error;
    }
  }
  async switchNetwork(chainId) {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_SWITCH_NETWORK,
        payload: { chainId }
      });
      this.setLastUsedChainId(response.chainId);
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error switching network");
      throw error;
    }
  }
  async disconnect() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_SIGN_OUT
      });
      this.deleteAuthLoginCache();
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error disconnecting");
      throw error;
    }
  }
  async request(req) {
    var _a2, _b, _c;
    try {
      if (W3mFrameRpcConstants.GET_CHAIN_ID === req.method) {
        return this.getLastUsedChainId();
      }
      (_a2 = this.rpcRequestHandler) == null ? void 0 : _a2.call(this, req);
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_RPC_REQUEST,
        payload: req
      });
      (_b = this.rpcSuccessHandler) == null ? void 0 : _b.call(this, response, req);
      return response;
    } catch (error) {
      (_c = this.rpcErrorHandler) == null ? void 0 : _c.call(this, error, req);
      this.w3mLogger.logger.error({ error }, "Error requesting");
      throw error;
    }
  }
  onRpcRequest(callback) {
    this.rpcRequestHandler = callback;
  }
  onRpcSuccess(callback) {
    this.rpcSuccessHandler = callback;
  }
  onRpcError(callback) {
    this.rpcErrorHandler = callback;
  }
  onIsConnected(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_GET_USER_SUCCESS) {
        callback(event.payload);
      }
    });
  }
  onNotConnected(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_IS_CONNECTED_ERROR) {
        callback();
      }
      if (event.type === W3mFrameConstants.FRAME_IS_CONNECTED_SUCCESS && !event.payload.isConnected) {
        callback();
      }
    });
  }
  async getCapabilities() {
    try {
      const capabilities = await this.request({
        method: "wallet_getCapabilities"
      });
      return capabilities || {};
    } catch {
      return {};
    }
  }
  onSetPreferredAccount(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS) {
        callback(event.payload);
      } else if (event.type === W3mFrameConstants.FRAME_SET_PREFERRED_ACCOUNT_ERROR) {
        callback({ type: W3mFrameRpcConstants.ACCOUNT_TYPES.EOA });
      }
    });
  }
  onGetSmartAccountEnabledNetworks(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS) {
        callback(event.payload.smartAccountEnabledNetworks);
      } else if (event.type === W3mFrameConstants.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR) {
        callback([]);
      }
    });
  }
  getAvailableChainIds() {
    return Object.keys(this.w3mFrame.networks);
  }
  rejectRpcRequests() {
    try {
      this.openRpcRequests.forEach(({ abortController, method }) => {
        if (!W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(method)) {
          abortController.abort();
        }
      });
      this.openRpcRequests = [];
    } catch (e) {
      this.w3mLogger.logger.error({ error: e }, "Error aborting RPC request");
    }
  }
  async appEvent(event) {
    await this.w3mFrame.frameLoadPromise;
    const type = event.type.replace("@w3m-app/", "");
    return new Promise((resolve, reject) => {
      var _a2, _b;
      const id = Math.random().toString(36).substring(7);
      (_b = (_a2 = this.w3mLogger.logger).info) == null ? void 0 : _b.call(_a2, { event, id }, "Sending app event");
      this.w3mFrame.events.postAppEvent({ ...event, id });
      const abortController = new AbortController();
      if (type === "RPC_REQUEST") {
        const rpcEvent = event;
        this.openRpcRequests = [...this.openRpcRequests, { ...rpcEvent.payload, abortController }];
      }
      abortController.signal.addEventListener("abort", () => {
        if (type === "RPC_REQUEST") {
          reject(new Error("Request was aborted"));
        }
      });
      function handler(framEvent) {
        var _a3;
        if (framEvent.type === `@w3m-frame/${type}_SUCCESS`) {
          if ("payload" in framEvent) {
            resolve(framEvent.payload);
          }
          resolve(void 0);
        } else if (framEvent.type === `@w3m-frame/${type}_ERROR`) {
          if ("payload" in framEvent) {
            reject(new Error(((_a3 = framEvent.payload) == null ? void 0 : _a3.message) || "An error occurred"));
          }
          reject(new Error("An error occurred"));
        }
      }
      this.w3mFrame.events.registerFrameEventHandler(id, handler, abortController.signal);
    });
  }
  setNewLastEmailLoginTime() {
    W3mFrameStorage.set(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
  }
  setSocialLoginSuccess(username) {
    W3mFrameStorage.set(W3mFrameConstants.SOCIAL_USERNAME, username);
  }
  setLoginSuccess(email) {
    if (email) {
      W3mFrameStorage.set(W3mFrameConstants.EMAIL, email);
    }
    W3mFrameStorage.set(W3mFrameConstants.EMAIL_LOGIN_USED_KEY, "true");
    W3mFrameStorage.delete(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
  }
  deleteAuthLoginCache() {
    W3mFrameStorage.delete(W3mFrameConstants.EMAIL_LOGIN_USED_KEY);
    W3mFrameStorage.delete(W3mFrameConstants.EMAIL);
    W3mFrameStorage.delete(W3mFrameConstants.LAST_USED_CHAIN_KEY);
    W3mFrameStorage.delete(W3mFrameConstants.SOCIAL_USERNAME);
    W3mFrameStorage.delete(W3mFrameConstants.SOCIAL, true);
  }
  setLastUsedChainId(chainId) {
    W3mFrameStorage.set(W3mFrameConstants.LAST_USED_CHAIN_KEY, String(chainId));
  }
  getLastUsedChainId() {
    return Number(W3mFrameStorage.get(W3mFrameConstants.LAST_USED_CHAIN_KEY));
  }
  persistSmartAccountEnabledNetworks(networks) {
    W3mFrameStorage.set(W3mFrameConstants.SMART_ACCOUNT_ENABLED_NETWORKS, networks.join(","));
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/TransactionsController.js
var state5 = proxy({
  transactions: [],
  coinbaseTransactions: {},
  transactionsByYear: {},
  lastNetworkInView: void 0,
  loading: false,
  empty: false,
  next: void 0
});
var TransactionsController = {
  state: state5,
  subscribe(callback) {
    return subscribe(state5, () => callback(state5));
  },
  setLastNetworkInView(lastNetworkInView) {
    state5.lastNetworkInView = lastNetworkInView;
  },
  async fetchTransactions(accountAddress, onramp) {
    var _a2;
    const { projectId } = OptionsController.state;
    if (!projectId || !accountAddress) {
      throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
    }
    state5.loading = true;
    try {
      const response = await BlockchainApiController.fetchTransactions({
        account: accountAddress,
        projectId,
        cursor: state5.next,
        onramp,
        // Coinbase transaction history state updates require the latest data
        cache: onramp === "coinbase" ? "no-cache" : void 0,
        chainId: (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id
      });
      const nonSpamTransactions = this.filterSpamTransactions(response.data);
      const sameChainTransactions = this.filterByConnectedChain(nonSpamTransactions);
      const filteredTransactions = [...state5.transactions, ...sameChainTransactions];
      state5.loading = false;
      if (onramp === "coinbase") {
        state5.coinbaseTransactions = this.groupTransactionsByYearAndMonth(state5.coinbaseTransactions, response.data);
      } else {
        state5.transactions = filteredTransactions;
        state5.transactionsByYear = this.groupTransactionsByYearAndMonth(state5.transactionsByYear, sameChainTransactions);
      }
      state5.empty = filteredTransactions.length === 0;
      state5.next = response.next ? response.next : void 0;
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: accountAddress,
          projectId,
          cursor: state5.next,
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      SnackController.showError("Failed to fetch transactions");
      state5.loading = false;
      state5.empty = true;
      state5.next = void 0;
    }
  },
  groupTransactionsByYearAndMonth(transactionsMap = {}, transactions = []) {
    const grouped = transactionsMap;
    transactions.forEach((transaction) => {
      const year = new Date(transaction.metadata.minedAt).getFullYear();
      const month = new Date(transaction.metadata.minedAt).getMonth();
      const yearTransactions = grouped[year] ?? {};
      const monthTransactions = yearTransactions[month] ?? [];
      const newMonthTransactions = monthTransactions.filter((tx) => tx.id !== transaction.id);
      grouped[year] = {
        ...yearTransactions,
        [month]: [...newMonthTransactions, transaction].sort((a, b) => new Date(b.metadata.minedAt).getTime() - new Date(a.metadata.minedAt).getTime())
      };
    });
    return grouped;
  },
  filterSpamTransactions(transactions) {
    return transactions.filter((transaction) => {
      const isAllSpam = transaction.transfers.every((transfer) => {
        var _a2;
        return ((_a2 = transfer.nft_info) == null ? void 0 : _a2.flags.is_spam) === true;
      });
      return !isAllSpam;
    });
  },
  filterByConnectedChain(transactions) {
    var _a2;
    const chainId = (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id;
    const filteredTransactions = transactions.filter((transaction) => transaction.metadata.chain === chainId);
    return filteredTransactions;
  },
  clearCursor() {
    state5.next = void 0;
  },
  resetTransactions() {
    state5.transactions = [];
    state5.transactionsByYear = {};
    state5.lastNetworkInView = void 0;
    state5.loading = false;
    state5.empty = false;
    state5.next = void 0;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/PublicStateController.js
var state6 = proxy({
  loading: false,
  open: false,
  selectedNetworkId: void 0,
  activeChain: void 0
});
var PublicStateController = {
  state: state6,
  subscribe(callback) {
    return subscribe(state6, () => callback(state6));
  },
  set(newState) {
    Object.assign(state6, { ...state6, ...newState });
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ChainController.js
var accountState = {
  isConnected: false,
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: []
};
var networkState = {
  supportsAllNetworks: true,
  isDefaultCaipNetwork: false,
  smartAccountEnabledNetworks: []
};
var state7 = proxy({
  chains: proxyMap(),
  activeChain: void 0,
  activeCaipNetwork: void 0
});
var ChainController = {
  state: state7,
  subscribeKey(key, callback) {
    return subscribeKey(state7, key, callback);
  },
  subscribeChain(callback) {
    let prev = void 0;
    return subscribe(state7.chains, () => {
      const activeChain = state7.activeChain;
      if (activeChain) {
        const nextValue = state7.chains.get(activeChain);
        if (!prev || prev !== nextValue) {
          prev = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  subscribeChainProp(property, callback) {
    let prev = void 0;
    return subscribe(state7.chains, () => {
      var _a2;
      const activeChain = state7.activeChain;
      if (activeChain) {
        const nextValue = (_a2 = state7.chains.get(activeChain)) == null ? void 0 : _a2[property];
        if (prev !== nextValue) {
          prev = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  initialize(adapters) {
    const adapterToActivate = adapters == null ? void 0 : adapters[0];
    if (!adapterToActivate) {
      throw new Error("Adapter is required to initialize ChainController");
    }
    state7.activeChain = adapterToActivate.chain;
    PublicStateController.set({ activeChain: adapterToActivate.chain });
    this.setActiveCaipNetwork(adapterToActivate.defaultChain);
    adapters.forEach((adapter) => {
      state7.chains.set(adapter.chain, {
        chain: adapter.chain,
        connectionControllerClient: adapter.connectionControllerClient,
        networkControllerClient: adapter.networkControllerClient,
        accountState,
        networkState
      });
    });
  },
  setChainNetworkData(chain, props, replaceState = false) {
    if (!chain) {
      throw new Error("Chain is required to update chain network data");
    }
    const chainAdapter = state7.chains.get(chain);
    if (chainAdapter) {
      chainAdapter.networkState = ref({
        ...chainAdapter.networkState,
        ...props
      });
      state7.chains.set(chain, ref(chainAdapter));
      if (replaceState || state7.chains.size === 1 || state7.activeChain === chain) {
        NetworkController.replaceState(chainAdapter.networkState);
      }
    }
  },
  setChainAccountData(chain, accountProps, replaceState = true) {
    if (!chain) {
      throw new Error("Chain is required to update chain account data");
    }
    const chainAdapter = state7.chains.get(chain);
    if (chainAdapter) {
      chainAdapter.accountState = ref({
        ...chainAdapter.accountState,
        ...accountProps
      });
      state7.chains.set(chain, chainAdapter);
      if (replaceState || state7.chains.size === 1 || state7.activeChain === chain) {
        AccountController.replaceState(chainAdapter.accountState);
      }
    }
  },
  setAccountProp(prop, value, chain) {
    this.setChainAccountData(chain, {
      [prop]: value
    });
  },
  setActiveChain(chain) {
    var _a2, _b, _c, _d, _e;
    const newAdapter = chain ? state7.chains.get(chain) : void 0;
    if (newAdapter && newAdapter.chain !== state7.activeChain) {
      state7.activeChain = newAdapter.chain;
      state7.activeCaipNetwork = ((_a2 = newAdapter.networkState) == null ? void 0 : _a2.caipNetwork) ? ref((_b = newAdapter.networkState) == null ? void 0 : _b.caipNetwork) : void 0;
      AccountController.replaceState(newAdapter.accountState);
      NetworkController.replaceState(newAdapter.networkState);
      this.setCaipNetwork(newAdapter.chain, (_c = newAdapter.networkState) == null ? void 0 : _c.caipNetwork);
      PublicStateController.set({
        activeChain: chain,
        selectedNetworkId: (_e = (_d = newAdapter.networkState) == null ? void 0 : _d.caipNetwork) == null ? void 0 : _e.id
      });
    }
  },
  setActiveCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    if (caipNetwork.chain !== state7.activeChain) {
      this.setActiveChain(caipNetwork.chain);
    }
    state7.activeCaipNetwork = ref(caipNetwork);
    state7.activeChain = caipNetwork.chain;
    this.setCaipNetwork(caipNetwork.chain, caipNetwork, true);
    PublicStateController.set({
      activeChain: caipNetwork.chain,
      selectedNetworkId: caipNetwork == null ? void 0 : caipNetwork.id
    });
  },
  /**
   * The setCaipNetwork function is being called for different purposes and it needs to be controlled if it should replace the NetworkController state or not.
   * While we initializing the adapters, we need to set the caipNetwork without replacing the state.
   * But when we switch the network, we need to replace the state.
   * @param chain
   * @param caipNetwork
   * @param shouldReplace - if true, it will replace the NetworkController state
   */
  setCaipNetwork(chain, caipNetwork, shouldReplace = false) {
    this.setChainNetworkData(chain, { caipNetwork }, shouldReplace);
  },
  setActiveConnector(connector) {
    if (connector) {
      state7.activeConnector = ref(connector);
    }
  },
  getNetworkControllerClient() {
    const chain = state7.activeChain;
    if (!chain) {
      throw new Error("Chain is required to get network controller client");
    }
    const chainAdapter = state7.chains.get(chain);
    if (!chainAdapter) {
      throw new Error("Chain adapter not found");
    }
    if (!chainAdapter.networkControllerClient) {
      throw new Error("NetworkController client not set");
    }
    return chainAdapter.networkControllerClient;
  },
  getConnectionControllerClient(_chain) {
    const chain = _chain || state7.activeChain;
    if (!chain) {
      throw new Error("Chain is required to get connection controller client");
    }
    const chainAdapter = state7.chains.get(chain);
    if (!chainAdapter) {
      throw new Error("Chain adapter not found");
    }
    if (!chainAdapter.connectionControllerClient) {
      throw new Error("ConnectionController client not set");
    }
    return chainAdapter.connectionControllerClient;
  },
  getAccountProp(key, _chain) {
    var _a2;
    let chain = state7.activeChain;
    if (_chain) {
      chain = _chain;
    }
    if (!chain) {
      return void 0;
    }
    const chainAccountState = (_a2 = state7.chains.get(chain)) == null ? void 0 : _a2.accountState;
    if (!chainAccountState) {
      return void 0;
    }
    return chainAccountState[key];
  },
  getNetworkProp(key) {
    var _a2;
    const chainToWrite = state7.activeChain;
    if (!chainToWrite) {
      return void 0;
    }
    const chainNetworkState = (_a2 = state7.chains.get(chainToWrite)) == null ? void 0 : _a2.networkState;
    if (!chainNetworkState) {
      return void 0;
    }
    return chainNetworkState[key];
  },
  resetAccount(chain) {
    const chainToWrite = chain;
    if (!chainToWrite) {
      throw new Error("Chain is required to set account prop");
    }
    this.setChainAccountData(chainToWrite, ref({
      isConnected: false,
      smartAccountDeployed: false,
      currentTab: 0,
      caipAddress: void 0,
      address: void 0,
      balance: void 0,
      balanceSymbol: void 0,
      profileName: void 0,
      profileImage: void 0,
      addressExplorerUrl: void 0,
      tokenBalance: [],
      connectedWalletInfo: void 0,
      preferredAccountType: void 0,
      socialProvider: void 0,
      socialWindow: void 0,
      farcasterUrl: void 0
    }));
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ConnectionController.js
var state8 = proxy({
  wcError: false,
  buffering: false
});
var ConnectionController = {
  state: state8,
  subscribeKey(key, callback) {
    return subscribeKey(state8, key, callback);
  },
  _getClient(chain) {
    return ChainController.getConnectionControllerClient(chain);
  },
  setClient(client) {
    state8._client = ref(client);
  },
  async connectWalletConnect() {
    StorageUtil.setConnectedConnector("WALLET_CONNECT");
    await this._getClient().connectWalletConnect((uri) => {
      state8.wcUri = uri;
      state8.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
    });
  },
  async connectExternal(options, chain) {
    var _a2, _b;
    await ((_b = (_a2 = this._getClient(chain)).connectExternal) == null ? void 0 : _b.call(_a2, options));
    ChainController.setActiveChain(chain);
    StorageUtil.setConnectedConnector(options.type);
  },
  async reconnectExternal(options) {
    var _a2, _b;
    await ((_b = (_a2 = this._getClient()).reconnectExternal) == null ? void 0 : _b.call(_a2, options));
    StorageUtil.setConnectedConnector(options.type);
  },
  async setPreferredAccountType(accountType) {
    var _a2;
    ModalController.setLoading(true);
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector) {
      return;
    }
    await (authConnector == null ? void 0 : authConnector.provider.setPreferredAccount(accountType));
    await this.reconnectExternal(authConnector);
    ModalController.setLoading(false);
    EventsController.sendEvent({
      type: "track",
      event: "SET_PREFERRED_ACCOUNT_TYPE",
      properties: { accountType, network: ((_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id) || "" }
    });
  },
  async signMessage(message) {
    return this._getClient().signMessage(message);
  },
  parseUnits(value, decimals) {
    return this._getClient().parseUnits(value, decimals);
  },
  formatUnits(value, decimals) {
    return this._getClient().formatUnits(value, decimals);
  },
  async sendTransaction(args) {
    return this._getClient().sendTransaction(args);
  },
  async estimateGas(args) {
    return this._getClient().estimateGas(args);
  },
  async writeContract(args) {
    return this._getClient().writeContract(args);
  },
  async getEnsAddress(value) {
    return this._getClient().getEnsAddress(value);
  },
  async getEnsAvatar(value) {
    return this._getClient().getEnsAvatar(value);
  },
  checkInstalled(ids, chain) {
    var _a2, _b;
    return ((_b = (_a2 = this._getClient(chain)).checkInstalled) == null ? void 0 : _b.call(_a2, ids)) || false;
  },
  resetWcConnection() {
    state8.wcUri = void 0;
    state8.wcPairingExpiry = void 0;
    state8.wcLinking = void 0;
    state8.recentWallet = void 0;
    TransactionsController.resetTransactions();
    StorageUtil.deleteWalletConnectDeepLink();
  },
  setWcLinking(wcLinking) {
    state8.wcLinking = wcLinking;
  },
  setWcError(wcError) {
    state8.wcError = wcError;
    state8.buffering = false;
  },
  setRecentWallet(wallet) {
    state8.recentWallet = wallet;
  },
  setBuffering(buffering) {
    state8.buffering = buffering;
  },
  async disconnect() {
    const client = this._getClient();
    try {
      await client.disconnect();
      this.resetWcConnection();
    } catch (error) {
      throw new Error("Failed to disconnect");
    }
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/SwapApiUtil.js
var SwapApiUtil = {
  async getTokenList() {
    var _a2;
    const caipNetwork = NetworkController.state.caipNetwork;
    const response = await BlockchainApiController.fetchSwapTokens({
      chainId: caipNetwork == null ? void 0 : caipNetwork.id,
      projectId: OptionsController.state.projectId
    });
    const tokens = ((_a2 = response == null ? void 0 : response.tokens) == null ? void 0 : _a2.map((token) => ({
      ...token,
      eip2612: false,
      quantity: {
        decimals: "0",
        numeric: "0"
      },
      price: 0,
      value: 0
    }))) || [];
    return tokens;
  },
  async fetchGasPrice() {
    const projectId = OptionsController.state.projectId;
    const caipNetwork = NetworkController.state.caipNetwork;
    if (!caipNetwork) {
      return null;
    }
    try {
      switch (caipNetwork.chain) {
        case "solana":
          const lamportsPerSignature = (await ConnectionController.estimateGas({ chainNamespace: "solana" })).toString();
          return {
            standard: lamportsPerSignature,
            fast: lamportsPerSignature,
            instant: lamportsPerSignature
          };
        case "evm":
        default:
          return await BlockchainApiController.fetchGasPrice({
            projectId,
            chainId: caipNetwork.id
          });
      }
    } catch {
      return null;
    }
  },
  async fetchSwapAllowance({ tokenAddress, userAddress, sourceTokenAmount, sourceTokenDecimals }) {
    const projectId = OptionsController.state.projectId;
    const response = await BlockchainApiController.fetchSwapAllowance({
      projectId,
      tokenAddress,
      userAddress
    });
    if ((response == null ? void 0 : response.allowance) && sourceTokenAmount && sourceTokenDecimals) {
      const parsedValue = ConnectionController.parseUnits(sourceTokenAmount, sourceTokenDecimals) || 0;
      const hasAllowance = BigInt(response.allowance) >= parsedValue;
      return hasAllowance;
    }
    return false;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const address = AccountController.state.address;
    const caipNetwork = NetworkController.state.caipNetwork;
    if (!address || !caipNetwork) {
      return [];
    }
    const response = await BlockchainApiController.getBalance(address, caipNetwork.id, forceUpdate);
    const balances = response.balances.filter((balance) => balance.quantity.decimals !== "0");
    AccountController.setTokenBalance(balances, ChainController.state.activeChain);
    return this.mapBalancesToSwapTokens(balances);
  },
  mapBalancesToSwapTokens(balances) {
    return (balances == null ? void 0 : balances.map((token) => ({
      ...token,
      address: (token == null ? void 0 : token.address) ? token.address : NetworkController.getActiveNetworkTokenAddress(),
      decimals: parseInt(token.quantity.decimals, 10),
      logoUri: token.iconUrl,
      eip2612: false
    }))) || [];
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/RouterController.js
var state9 = proxy({
  view: "Connect",
  history: ["Connect"],
  transactionStack: []
});
var RouterController = {
  state: state9,
  subscribeKey(key, callback) {
    return subscribeKey(state9, key, callback);
  },
  pushTransactionStack(action) {
    state9.transactionStack.push(action);
  },
  popTransactionStack(cancel) {
    var _a2, _b;
    const action = state9.transactionStack.pop();
    if (!action) {
      return;
    }
    if (cancel) {
      this.goBack();
      (_a2 = action == null ? void 0 : action.onCancel) == null ? void 0 : _a2.call(action);
    } else {
      if (action.goBack) {
        this.goBack();
      } else if (action.view) {
        this.reset(action.view);
      }
      (_b = action == null ? void 0 : action.onSuccess) == null ? void 0 : _b.call(action);
    }
  },
  push(view, data) {
    if (view !== state9.view) {
      state9.view = view;
      state9.history.push(view);
      state9.data = data;
    }
  },
  reset(view) {
    state9.view = view;
    state9.history = [view];
  },
  replace(view, data) {
    if (state9.history.length >= 1 && state9.history.at(-1) !== view) {
      state9.view = view;
      state9.history[state9.history.length - 1] = view;
      state9.data = data;
    }
  },
  goBack() {
    if (state9.history.length > 1) {
      state9.history.pop();
      const [last] = state9.history.slice(-1);
      if (last) {
        state9.view = last;
      }
    }
  },
  goBackToIndex(historyIndex) {
    if (state9.history.length > 1) {
      state9.history = state9.history.slice(0, historyIndex + 1);
      const [last] = state9.history.slice(-1);
      if (last) {
        state9.view = last;
      }
    }
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/SwapCalculationUtil.js
var SwapCalculationUtil = {
  getGasPriceInEther(gas, gasPrice) {
    const totalGasCostInWei = gasPrice * gas;
    const totalGasCostInEther = Number(totalGasCostInWei) / 1e18;
    return totalGasCostInEther;
  },
  getGasPriceInUSD(networkPrice, gas, gasPrice) {
    const totalGasCostInEther = SwapCalculationUtil.getGasPriceInEther(gas, gasPrice);
    const networkPriceInUSD = NumberUtil.bigNumber(networkPrice);
    const gasCostInUSD = networkPriceInUSD.multipliedBy(totalGasCostInEther);
    return gasCostInUSD.toNumber();
  },
  getPriceImpact({ sourceTokenAmount, sourceTokenPriceInUSD, toTokenPriceInUSD, toTokenAmount }) {
    const inputValue = NumberUtil.bigNumber(sourceTokenAmount).multipliedBy(sourceTokenPriceInUSD);
    const outputValue = NumberUtil.bigNumber(toTokenAmount).multipliedBy(toTokenPriceInUSD);
    const priceImpact = inputValue.minus(outputValue).dividedBy(inputValue).multipliedBy(100);
    return priceImpact.toNumber();
  },
  getMaxSlippage(slippage, toTokenAmount) {
    const slippageToleranceDecimal = NumberUtil.bigNumber(slippage).dividedBy(100);
    const maxSlippageAmount = NumberUtil.multiply(toTokenAmount, slippageToleranceDecimal);
    return maxSlippageAmount.toNumber();
  },
  getProviderFee(sourceTokenAmount, feePercentage = 85e-4) {
    const providerFee = NumberUtil.bigNumber(sourceTokenAmount).multipliedBy(feePercentage);
    return providerFee.toString();
  },
  isInsufficientNetworkTokenForGas(networkBalanceInUSD, gasPriceInUSD) {
    const gasPrice = gasPriceInUSD || "0";
    if (NumberUtil.bigNumber(networkBalanceInUSD).isZero()) {
      return true;
    }
    return NumberUtil.bigNumber(NumberUtil.bigNumber(gasPrice)).isGreaterThan(networkBalanceInUSD);
  },
  isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, balance) {
    var _a2, _b;
    const sourceTokenBalance = (_b = (_a2 = balance == null ? void 0 : balance.find((token) => token.address === sourceTokenAddress)) == null ? void 0 : _a2.quantity) == null ? void 0 : _b.numeric;
    const isInSufficientBalance = NumberUtil.bigNumber(sourceTokenBalance || "0").isLessThan(sourceTokenAmount);
    return isInSufficientBalance;
  },
  getToTokenAmount({ sourceToken, toToken, sourceTokenPrice, toTokenPrice, sourceTokenAmount }) {
    if (sourceTokenAmount === "0") {
      return "0";
    }
    if (!sourceToken || !toToken) {
      return "0";
    }
    const sourceTokenDecimals = sourceToken.decimals;
    const sourceTokenPriceInUSD = sourceTokenPrice;
    const toTokenDecimals = toToken.decimals;
    const toTokenPriceInUSD = toTokenPrice;
    if (toTokenPriceInUSD <= 0) {
      return "0";
    }
    const providerFee = NumberUtil.bigNumber(sourceTokenAmount).multipliedBy(85e-4);
    const adjustedSourceTokenAmount = NumberUtil.bigNumber(sourceTokenAmount).minus(providerFee);
    const sourceAmountInSmallestUnit = adjustedSourceTokenAmount.multipliedBy(NumberUtil.bigNumber(10).pow(sourceTokenDecimals));
    const priceRatio = NumberUtil.bigNumber(sourceTokenPriceInUSD).dividedBy(toTokenPriceInUSD);
    const decimalDifference = sourceTokenDecimals - toTokenDecimals;
    const toTokenAmountInSmallestUnit = sourceAmountInSmallestUnit.multipliedBy(priceRatio).dividedBy(NumberUtil.bigNumber(10).pow(decimalDifference));
    const toTokenAmount = toTokenAmountInSmallestUnit.dividedBy(NumberUtil.bigNumber(10).pow(toTokenDecimals));
    const amount = toTokenAmount.toFixed(toTokenDecimals).toString();
    return amount;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/SwapController.js
var INITIAL_GAS_LIMIT = 15e4;
var TO_AMOUNT_DECIMALS = 6;
var initialState = {
  // Loading states
  initializing: false,
  initialized: false,
  loadingPrices: false,
  loadingQuote: false,
  loadingApprovalTransaction: false,
  loadingBuildTransaction: false,
  loadingTransaction: false,
  // Error states
  fetchError: false,
  // Approval & Swap transaction states
  approvalTransaction: void 0,
  swapTransaction: void 0,
  transactionError: void 0,
  // Input values
  sourceToken: void 0,
  sourceTokenAmount: "",
  sourceTokenPriceInUSD: 0,
  toToken: void 0,
  toTokenAmount: "",
  toTokenPriceInUSD: 0,
  networkPrice: "0",
  networkBalanceInUSD: "0",
  networkTokenSymbol: "",
  inputError: void 0,
  // Request values
  slippage: ConstantsUtil2.CONVERT_SLIPPAGE_TOLERANCE,
  // Tokens
  tokens: void 0,
  popularTokens: void 0,
  suggestedTokens: void 0,
  foundTokens: void 0,
  myTokensWithBalance: void 0,
  tokensPriceMap: {},
  // Calculations
  gasFee: "0",
  gasPriceInUSD: 0,
  priceImpact: void 0,
  maxSlippage: void 0,
  providerFee: void 0
};
var state10 = proxy(initialState);
var SwapController = {
  state: state10,
  subscribe(callback) {
    return subscribe(state10, () => callback(state10));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state10, key, callback);
  },
  getParams() {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const address = AccountController.state.address;
    const networkAddress = NetworkController.getActiveNetworkTokenAddress();
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (!address) {
      throw new Error("No address found to swap the tokens from.");
    }
    const caipAddress = AccountController.state.caipAddress;
    const invalidToToken = !((_a2 = state10.toToken) == null ? void 0 : _a2.address) || !((_b = state10.toToken) == null ? void 0 : _b.decimals);
    const invalidSourceToken = !((_c = state10.sourceToken) == null ? void 0 : _c.address) || !((_d = state10.sourceToken) == null ? void 0 : _d.decimals) || !NumberUtil.bigNumber(state10.sourceTokenAmount).isGreaterThan(0);
    const invalidSourceTokenAmount = !state10.sourceTokenAmount;
    return {
      networkAddress,
      fromAddress: address,
      fromCaipAddress: AccountController.state.caipAddress,
      sourceTokenAddress: (_e = state10.sourceToken) == null ? void 0 : _e.address,
      toTokenAddress: (_f = state10.toToken) == null ? void 0 : _f.address,
      toTokenAmount: state10.toTokenAmount,
      toTokenDecimals: (_g = state10.toToken) == null ? void 0 : _g.decimals,
      sourceTokenAmount: state10.sourceTokenAmount,
      sourceTokenDecimals: (_h = state10.sourceToken) == null ? void 0 : _h.decimals,
      invalidToToken,
      invalidSourceToken,
      invalidSourceTokenAmount,
      availableToSwap: caipAddress && !invalidToToken && !invalidSourceToken && !invalidSourceTokenAmount,
      isAuthConnector: (authConnector == null ? void 0 : authConnector.walletFeatures) && type === "AUTH"
    };
  },
  setSourceToken(sourceToken) {
    if (!sourceToken) {
      state10.sourceToken = sourceToken;
      state10.sourceTokenAmount = "";
      state10.sourceTokenPriceInUSD = 0;
      return;
    }
    state10.sourceToken = sourceToken;
    this.setTokenPrice(sourceToken.address, "sourceToken");
  },
  setSourceTokenAmount(amount) {
    state10.sourceTokenAmount = amount;
  },
  setToToken(toToken) {
    if (!toToken) {
      state10.toToken = toToken;
      state10.toTokenAmount = "";
      state10.toTokenPriceInUSD = 0;
      return;
    }
    state10.toToken = toToken;
    this.setTokenPrice(toToken.address, "toToken");
  },
  setToTokenAmount(amount) {
    state10.toTokenAmount = amount ? NumberUtil.formatNumberToLocalString(amount, TO_AMOUNT_DECIMALS) : "";
  },
  async setTokenPrice(address, target) {
    const { availableToSwap } = this.getParams();
    let price = state10.tokensPriceMap[address] || 0;
    if (!price) {
      state10.loadingPrices = true;
      price = await this.getAddressPrice(address);
    }
    if (target === "sourceToken") {
      state10.sourceTokenPriceInUSD = price;
    } else if (target === "toToken") {
      state10.toTokenPriceInUSD = price;
    }
    if (state10.loadingPrices) {
      state10.loadingPrices = false;
      if (availableToSwap) {
        this.swapTokens();
      }
    }
  },
  switchTokens() {
    if (state10.initializing || !state10.initialized) {
      return;
    }
    const newSourceToken = state10.toToken ? { ...state10.toToken } : void 0;
    const newToToken = state10.sourceToken ? { ...state10.sourceToken } : void 0;
    const newSourceTokenAmount = newSourceToken && state10.toTokenAmount === "" ? "1" : state10.toTokenAmount;
    this.setSourceToken(newSourceToken);
    this.setToToken(newToToken);
    this.setSourceTokenAmount(newSourceTokenAmount);
    this.setToTokenAmount("");
    this.swapTokens();
  },
  resetState() {
    state10.myTokensWithBalance = initialState.myTokensWithBalance;
    state10.tokensPriceMap = initialState.tokensPriceMap;
    state10.initialized = initialState.initialized;
    state10.sourceToken = initialState.sourceToken;
    state10.sourceTokenAmount = initialState.sourceTokenAmount;
    state10.sourceTokenPriceInUSD = initialState.sourceTokenPriceInUSD;
    state10.toToken = initialState.toToken;
    state10.toTokenAmount = initialState.toTokenAmount;
    state10.toTokenPriceInUSD = initialState.toTokenPriceInUSD;
    state10.networkPrice = initialState.networkPrice;
    state10.networkTokenSymbol = initialState.networkTokenSymbol;
    state10.networkBalanceInUSD = initialState.networkBalanceInUSD;
    state10.inputError = initialState.inputError;
  },
  resetValues() {
    var _a2;
    const { networkAddress } = this.getParams();
    const networkToken = (_a2 = state10.tokens) == null ? void 0 : _a2.find((token) => token.address === networkAddress);
    this.setSourceToken(networkToken);
    this.setToToken(void 0);
  },
  getApprovalLoadingState() {
    return state10.loadingApprovalTransaction;
  },
  clearError() {
    state10.transactionError = void 0;
  },
  async initializeState() {
    if (state10.initializing) {
      return;
    }
    state10.initializing = true;
    if (!state10.initialized) {
      try {
        await this.fetchTokens();
        state10.initialized = true;
      } catch (error) {
        state10.initialized = false;
        SnackController.showError("Failed to initialize swap");
        RouterController.goBack();
      }
    }
    state10.initializing = false;
  },
  async fetchTokens() {
    var _a2;
    const { networkAddress } = this.getParams();
    await this.getTokenList();
    await this.getNetworkTokenPrice();
    await this.getMyTokensWithBalance();
    const networkToken = (_a2 = state10.tokens) == null ? void 0 : _a2.find((token) => token.address === networkAddress);
    if (networkToken) {
      state10.networkTokenSymbol = networkToken.symbol;
      this.setSourceToken(networkToken);
      this.setSourceTokenAmount("1");
    }
  },
  async getTokenList() {
    const tokens = await SwapApiUtil.getTokenList();
    state10.tokens = tokens;
    state10.popularTokens = tokens.sort((aTokenInfo, bTokenInfo) => {
      if (aTokenInfo.symbol < bTokenInfo.symbol) {
        return -1;
      }
      if (aTokenInfo.symbol > bTokenInfo.symbol) {
        return 1;
      }
      return 0;
    });
    state10.suggestedTokens = tokens.filter((token) => {
      if (ConstantsUtil2.SWAP_SUGGESTED_TOKENS.includes(token.symbol)) {
        return true;
      }
      return false;
    }, {});
  },
  async getAddressPrice(address) {
    var _a2, _b;
    const existPrice = state10.tokensPriceMap[address];
    if (existPrice) {
      return existPrice;
    }
    const response = await BlockchainApiController.fetchTokenPrice({
      projectId: OptionsController.state.projectId,
      addresses: [address]
    });
    const fungibles = response.fungibles || [];
    const allTokens = [...state10.tokens || [], ...state10.myTokensWithBalance || []];
    const symbol = (_a2 = allTokens == null ? void 0 : allTokens.find((token) => token.address === address)) == null ? void 0 : _a2.symbol;
    const price = ((_b = fungibles.find((p) => p.symbol.toLowerCase() === (symbol == null ? void 0 : symbol.toLowerCase()))) == null ? void 0 : _b.price) || 0;
    const priceAsFloat = parseFloat(price.toString());
    state10.tokensPriceMap[address] = priceAsFloat;
    return priceAsFloat;
  },
  async getNetworkTokenPrice() {
    var _a2;
    const { networkAddress } = this.getParams();
    const response = await BlockchainApiController.fetchTokenPrice({
      projectId: OptionsController.state.projectId,
      addresses: [networkAddress]
    }).catch(() => {
      SnackController.showError("Failed to fetch network token price");
      return { fungibles: [] };
    });
    const token = (_a2 = response.fungibles) == null ? void 0 : _a2[0];
    const price = (token == null ? void 0 : token.price.toString()) || "0";
    state10.tokensPriceMap[networkAddress] = parseFloat(price);
    state10.networkTokenSymbol = (token == null ? void 0 : token.symbol) || "";
    state10.networkPrice = price;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const balances = await SwapApiUtil.getMyTokensWithBalance(forceUpdate);
    if (!balances) {
      return;
    }
    await this.getInitialGasPrice();
    this.setBalances(balances);
  },
  setBalances(balances) {
    const { networkAddress } = this.getParams();
    const caipNetwork = NetworkController.state.caipNetwork;
    if (!caipNetwork) {
      return;
    }
    const networkToken = balances.find((token) => token.address === networkAddress);
    balances.forEach((token) => {
      state10.tokensPriceMap[token.address] = token.price || 0;
    });
    state10.myTokensWithBalance = balances.filter((token) => token.address.startsWith(caipNetwork.id));
    state10.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : "0";
  },
  async getInitialGasPrice() {
    var _a2;
    const res = await SwapApiUtil.fetchGasPrice();
    if (!res) {
      return { gasPrice: null, gasPriceInUSD: null };
    }
    switch ((_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.chain) {
      case "solana":
        state10.gasFee = res.standard;
        state10.gasPriceInUSD = NumberUtil.multiply(res.standard, state10.networkPrice).dividedBy(1e9).toNumber();
        return {
          gasPrice: BigInt(state10.gasFee),
          gasPriceInUSD: Number(state10.gasPriceInUSD)
        };
      case "evm":
      default:
        const value = res.standard;
        const gasFee = BigInt(value);
        const gasLimit = BigInt(INITIAL_GAS_LIMIT);
        const gasPrice = SwapCalculationUtil.getGasPriceInUSD(state10.networkPrice, gasLimit, gasFee);
        state10.gasFee = value;
        state10.gasPriceInUSD = gasPrice;
        return { gasPrice: gasFee, gasPriceInUSD: gasPrice };
    }
  },
  // -- Swap -------------------------------------- //
  async swapTokens() {
    var _a2, _b;
    const address = AccountController.state.address;
    const sourceToken = state10.sourceToken;
    const toToken = state10.toToken;
    const haveSourceTokenAmount = NumberUtil.bigNumber(state10.sourceTokenAmount).isGreaterThan(0);
    if (!toToken || !sourceToken || state10.loadingPrices || !haveSourceTokenAmount) {
      return;
    }
    state10.loadingQuote = true;
    const amountDecimal = NumberUtil.bigNumber(state10.sourceTokenAmount).multipliedBy(10 ** sourceToken.decimals);
    const quoteResponse = await BlockchainApiController.fetchSwapQuote({
      userAddress: address,
      projectId: OptionsController.state.projectId,
      from: sourceToken.address,
      to: toToken.address,
      gasPrice: state10.gasFee,
      amount: amountDecimal.toString()
    });
    state10.loadingQuote = false;
    const quoteToAmount = (_b = (_a2 = quoteResponse == null ? void 0 : quoteResponse.quotes) == null ? void 0 : _a2[0]) == null ? void 0 : _b.toAmount;
    if (!quoteToAmount) {
      return;
    }
    const toTokenAmount = NumberUtil.bigNumber(quoteToAmount).dividedBy(10 ** toToken.decimals).toString();
    this.setToTokenAmount(toTokenAmount);
    const isInsufficientToken = this.hasInsufficientToken(state10.sourceTokenAmount, sourceToken.address);
    if (isInsufficientToken) {
      state10.inputError = "Insufficient balance";
    } else {
      state10.inputError = void 0;
      this.setTransactionDetails();
    }
  },
  // -- Create Transactions -------------------------------------- //
  async getTransaction() {
    const { fromCaipAddress, availableToSwap } = this.getParams();
    const sourceToken = state10.sourceToken;
    const toToken = state10.toToken;
    if (!fromCaipAddress || !availableToSwap || !sourceToken || !toToken || state10.loadingQuote) {
      return void 0;
    }
    try {
      state10.loadingBuildTransaction = true;
      const hasAllowance = await SwapApiUtil.fetchSwapAllowance({
        userAddress: fromCaipAddress,
        tokenAddress: sourceToken.address,
        sourceTokenAmount: state10.sourceTokenAmount,
        sourceTokenDecimals: sourceToken.decimals
      });
      let transaction = void 0;
      if (hasAllowance) {
        transaction = await this.createSwapTransaction();
      } else {
        transaction = await this.createAllowanceTransaction();
      }
      state10.loadingBuildTransaction = false;
      state10.fetchError = false;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to check allowance");
      state10.loadingBuildTransaction = false;
      state10.approvalTransaction = void 0;
      state10.swapTransaction = void 0;
      state10.fetchError = true;
      return void 0;
    }
  },
  async createAllowanceTransaction() {
    const { fromCaipAddress, fromAddress, sourceTokenAddress, toTokenAddress } = this.getParams();
    if (!fromCaipAddress || !toTokenAddress) {
      return void 0;
    }
    if (!sourceTokenAddress) {
      throw new Error("createAllowanceTransaction - No source token address found.");
    }
    try {
      const response = await BlockchainApiController.generateApproveCalldata({
        projectId: OptionsController.state.projectId,
        from: sourceTokenAddress,
        to: toTokenAddress,
        userAddress: fromCaipAddress
      });
      const gasLimit = await ConnectionController.estimateGas({
        address: fromAddress,
        to: CoreHelperUtil.getPlainAddress(response.tx.to),
        data: response.tx.data
      });
      const transaction = {
        data: response.tx.data,
        to: CoreHelperUtil.getPlainAddress(response.tx.from),
        gas: gasLimit,
        gasPrice: BigInt(response.tx.eip155.gasPrice),
        value: BigInt(response.tx.value),
        toAmount: state10.toTokenAmount
      };
      state10.swapTransaction = void 0;
      state10.approvalTransaction = transaction;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create approval transaction");
      state10.approvalTransaction = void 0;
      state10.swapTransaction = void 0;
      state10.fetchError = true;
      return void 0;
    }
  },
  async createSwapTransaction() {
    const { networkAddress, fromCaipAddress, sourceTokenAmount } = this.getParams();
    const sourceToken = state10.sourceToken;
    const toToken = state10.toToken;
    if (!fromCaipAddress || !sourceTokenAmount || !sourceToken || !toToken) {
      return void 0;
    }
    const amount = ConnectionController.parseUnits(sourceTokenAmount, sourceToken.decimals).toString();
    try {
      const response = await BlockchainApiController.generateSwapCalldata({
        projectId: OptionsController.state.projectId,
        userAddress: fromCaipAddress,
        from: sourceToken.address,
        to: toToken.address,
        amount
      });
      const isSourceTokenIsNetworkToken = sourceToken.address === networkAddress;
      const gas = BigInt(response.tx.eip155.gas);
      const gasPrice = BigInt(response.tx.eip155.gasPrice);
      const transaction = {
        data: response.tx.data,
        to: CoreHelperUtil.getPlainAddress(response.tx.to),
        gas,
        gasPrice,
        value: isSourceTokenIsNetworkToken ? BigInt(amount) : BigInt("0"),
        toAmount: state10.toTokenAmount
      };
      state10.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state10.networkPrice, gas, gasPrice);
      state10.approvalTransaction = void 0;
      state10.swapTransaction = transaction;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create transaction");
      state10.approvalTransaction = void 0;
      state10.swapTransaction = void 0;
      state10.fetchError = true;
      return void 0;
    }
  },
  // -- Send Transactions --------------------------------- //
  async sendTransactionForApproval(data) {
    const { fromAddress, isAuthConnector } = this.getParams();
    state10.loadingApprovalTransaction = true;
    const approveLimitMessage = `Approve limit increase in your wallet`;
    if (isAuthConnector) {
      RouterController.pushTransactionStack({
        view: null,
        goBack: true,
        onSuccess() {
          SnackController.showLoading(approveLimitMessage);
        }
      });
    } else {
      SnackController.showLoading(approveLimitMessage);
    }
    try {
      await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data.to,
        data: data.data,
        value: BigInt(data.value),
        gasPrice: BigInt(data.gasPrice)
      });
      await this.swapTokens();
      await this.getTransaction();
      state10.approvalTransaction = void 0;
      state10.loadingApprovalTransaction = false;
    } catch (err) {
      const error = err;
      state10.transactionError = error == null ? void 0 : error.shortMessage;
      state10.loadingApprovalTransaction = false;
      SnackController.showError((error == null ? void 0 : error.shortMessage) || "Transaction error");
    }
  },
  async sendTransactionForSwap(data) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    if (!data) {
      return void 0;
    }
    const { fromAddress, toTokenAmount, isAuthConnector } = this.getParams();
    state10.loadingTransaction = true;
    const snackbarPendingMessage = `Swapping ${(_a2 = state10.sourceToken) == null ? void 0 : _a2.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${(_b = state10.toToken) == null ? void 0 : _b.symbol}`;
    const snackbarSuccessMessage = `Swapped ${(_c = state10.sourceToken) == null ? void 0 : _c.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${(_d = state10.toToken) == null ? void 0 : _d.symbol}`;
    if (isAuthConnector) {
      RouterController.pushTransactionStack({
        view: "Account",
        goBack: false,
        onSuccess() {
          SnackController.showLoading(snackbarPendingMessage);
          SwapController.resetState();
        }
      });
    } else {
      SnackController.showLoading("Confirm transaction in your wallet");
    }
    try {
      const forceUpdateAddresses = [(_e = state10.sourceToken) == null ? void 0 : _e.address, (_f = state10.toToken) == null ? void 0 : _f.address].join(",");
      const transactionHash = await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data.to,
        data: data.data,
        gas: data.gas,
        gasPrice: BigInt(data.gasPrice),
        value: data.value
      });
      state10.loadingTransaction = false;
      SnackController.showSuccess(snackbarSuccessMessage);
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_SUCCESS",
        properties: {
          network: ((_g = NetworkController.state.caipNetwork) == null ? void 0 : _g.id) || "",
          swapFromToken: ((_h = this.state.sourceToken) == null ? void 0 : _h.symbol) || "",
          swapToToken: ((_i = this.state.toToken) == null ? void 0 : _i.symbol) || "",
          swapFromAmount: this.state.sourceTokenAmount || "",
          swapToAmount: this.state.toTokenAmount || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      SwapController.resetState();
      if (!isAuthConnector) {
        RouterController.replace("Account");
      }
      SwapController.getMyTokensWithBalance(forceUpdateAddresses);
      return transactionHash;
    } catch (err) {
      const error = err;
      state10.transactionError = error == null ? void 0 : error.shortMessage;
      state10.loadingTransaction = false;
      SnackController.showError((error == null ? void 0 : error.shortMessage) || "Transaction error");
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_ERROR",
        properties: {
          network: ((_j = NetworkController.state.caipNetwork) == null ? void 0 : _j.id) || "",
          swapFromToken: ((_k = this.state.sourceToken) == null ? void 0 : _k.symbol) || "",
          swapToToken: ((_l = this.state.toToken) == null ? void 0 : _l.symbol) || "",
          swapFromAmount: this.state.sourceTokenAmount || "",
          swapToAmount: this.state.toTokenAmount || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      return void 0;
    }
  },
  // -- Checks -------------------------------------------- //
  hasInsufficientToken(sourceTokenAmount, sourceTokenAddress) {
    const isInsufficientSourceTokenForSwap = SwapCalculationUtil.isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, state10.myTokensWithBalance);
    const insufficientNetworkTokenForGas = SwapCalculationUtil.isInsufficientNetworkTokenForGas(state10.networkBalanceInUSD, state10.gasPriceInUSD);
    return insufficientNetworkTokenForGas || isInsufficientSourceTokenForSwap;
  },
  // -- Calculations -------------------------------------- //
  setTransactionDetails() {
    const { toTokenAddress, toTokenDecimals } = this.getParams();
    if (!toTokenAddress || !toTokenDecimals) {
      return;
    }
    state10.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state10.networkPrice, BigInt(state10.gasFee), BigInt(INITIAL_GAS_LIMIT));
    state10.priceImpact = SwapCalculationUtil.getPriceImpact({
      sourceTokenAmount: state10.sourceTokenAmount,
      sourceTokenPriceInUSD: state10.sourceTokenPriceInUSD,
      toTokenPriceInUSD: state10.toTokenPriceInUSD,
      toTokenAmount: state10.toTokenAmount
    });
    state10.maxSlippage = SwapCalculationUtil.getMaxSlippage(state10.slippage, state10.toTokenAmount);
    state10.providerFee = SwapCalculationUtil.getProviderFee(state10.sourceTokenAmount);
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/AccountController.js
var state11 = proxy({
  isConnected: false,
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: []
});
var AccountController = {
  state: state11,
  replaceState(newState) {
    if (!newState) {
      return;
    }
    Object.assign(state11, ref(newState));
  },
  subscribe(callback) {
    return ChainController.subscribeChainProp("accountState", (accountState2) => {
      if (accountState2) {
        return callback(accountState2);
      }
      return void 0;
    });
  },
  subscribeKey(property, callback) {
    let prev = void 0;
    return ChainController.subscribeChainProp("accountState", (accountState2) => {
      if (accountState2) {
        const nextValue = accountState2[property];
        if (prev !== nextValue) {
          prev = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  setIsConnected(isConnected, chain) {
    ChainController.setAccountProp("isConnected", isConnected, chain);
  },
  getChainIsConnected(chain) {
    return ChainController.getAccountProp("isConnected", chain);
  },
  setCaipAddress(caipAddress, chain) {
    const newCaipAddress = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    ChainController.setAccountProp("caipAddress", caipAddress, chain);
    ChainController.setAccountProp("address", newCaipAddress, chain);
  },
  setBalance(balance, balanceSymbol, chain) {
    ChainController.setAccountProp("balance", balance, chain);
    ChainController.setAccountProp("balanceSymbol", balanceSymbol, chain);
  },
  setProfileName(profileName, chain) {
    ChainController.setAccountProp("profileName", profileName, chain);
  },
  setProfileImage(profileImage, chain) {
    ChainController.setAccountProp("profileImage", profileImage, chain);
  },
  setAddressExplorerUrl(explorerUrl, chain) {
    ChainController.setAccountProp("addressExplorerUrl", explorerUrl, chain);
  },
  setSmartAccountDeployed(isDeployed, chain) {
    ChainController.setAccountProp("smartAccountDeployed", isDeployed, chain);
  },
  setCurrentTab(currentTab) {
    ChainController.setAccountProp("currentTab", currentTab, ChainController.state.activeChain);
  },
  setTokenBalance(tokenBalance, chain) {
    if (tokenBalance) {
      ChainController.setAccountProp("tokenBalance", tokenBalance, chain);
    }
  },
  setShouldUpdateToAddress(address, chain) {
    ChainController.setAccountProp("shouldUpdateToAddress", address, chain);
  },
  setAllAccounts(accounts, chain) {
    ChainController.setAccountProp("allAccounts", accounts, chain);
  },
  addAddressLabel(address, label, chain) {
    const map = ChainController.getAccountProp("addressLabels", chain) || /* @__PURE__ */ new Map();
    map.set(address, label);
    ChainController.setAccountProp("addressLabels", map, ChainController.state.activeChain);
  },
  removeAddressLabel(address, chain) {
    const map = ChainController.getAccountProp("addressLabels", chain) || /* @__PURE__ */ new Map();
    map.delete(address);
    ChainController.setAccountProp("addressLabels", map, ChainController.state.activeChain);
  },
  setConnectedWalletInfo(connectedWalletInfo, chain) {
    ChainController.setAccountProp("connectedWalletInfo", connectedWalletInfo, chain);
  },
  setPreferredAccountType(preferredAccountType, chain) {
    ChainController.setAccountProp("preferredAccountType", preferredAccountType, chain);
  },
  setSocialProvider(socialProvider, chain) {
    if (socialProvider) {
      ChainController.setAccountProp("socialProvider", socialProvider, chain);
    }
  },
  setSocialWindow(socialWindow, chain) {
    if (socialWindow) {
      ChainController.setAccountProp("socialWindow", ref(socialWindow), chain);
    }
  },
  setFarcasterUrl(farcasterUrl, chain) {
    if (farcasterUrl) {
      ChainController.setAccountProp("farcasterUrl", farcasterUrl, chain);
    }
  },
  async fetchTokenBalance() {
    var _a2, _b;
    const chainId = (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id;
    const chain = (_b = NetworkController.state.caipNetwork) == null ? void 0 : _b.chain;
    const address = AccountController.state.address;
    try {
      if (address && chainId && chain) {
        const response = await BlockchainApiController.getBalance(address, chainId);
        const filteredBalances = response.balances.filter((balance) => balance.quantity.decimals !== "0");
        this.setTokenBalance(filteredBalances, chain);
        SwapController.setBalances(SwapApiUtil.mapBalancesToSwapTokens(response.balances));
      }
    } catch (error) {
      SnackController.showError("Failed to fetch token balance");
    }
  },
  resetAccount(chain) {
    ChainController.resetAccount(chain);
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ModalController.js
var state12 = proxy({
  loading: false,
  open: false,
  shake: false
});
var ModalController = {
  state: state12,
  subscribe(callback) {
    return subscribe(state12, () => callback(state12));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state12, key, callback);
  },
  async open(options) {
    await ApiController.state.prefetchPromise;
    const connected = AccountController.state.isConnected;
    if (options == null ? void 0 : options.view) {
      RouterController.reset(options.view);
    } else if (connected) {
      RouterController.reset("Account");
    } else {
      RouterController.reset("Connect");
    }
    state12.open = true;
    PublicStateController.set({ open: true });
    EventsController.sendEvent({
      type: "track",
      event: "MODAL_OPEN",
      properties: { connected }
    });
  },
  close() {
    const connected = AccountController.state.isConnected || false;
    state12.open = false;
    PublicStateController.set({ open: false });
    EventsController.sendEvent({
      type: "track",
      event: "MODAL_CLOSE",
      properties: { connected }
    });
  },
  setLoading(loading) {
    state12.loading = loading;
    PublicStateController.set({ loading });
  },
  shake() {
    if (state12.shake) {
      return;
    }
    state12.shake = true;
    setTimeout(() => {
      state12.shake = false;
    }, 500);
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/NetworkController.js
var state13 = proxy({
  supportsAllNetworks: true,
  isDefaultCaipNetwork: false,
  smartAccountEnabledNetworks: []
});
var NetworkController = {
  state: state13,
  replaceState(newState) {
    if (!newState) {
      return;
    }
    Object.assign(state13, ref(newState));
  },
  subscribeKey(property, callback) {
    let prev = void 0;
    return ChainController.subscribeChainProp("networkState", (networkState2) => {
      if (networkState2) {
        const nextValue = networkState2[property];
        if (prev !== nextValue) {
          prev = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  _getClient() {
    return ChainController.getNetworkControllerClient();
  },
  initializeDefaultNetwork() {
    const networks = this.getRequestedCaipNetworks();
    if (networks.length > 0) {
      this.setCaipNetwork(networks[0]);
    }
  },
  setDefaultCaipNetwork(caipNetwork) {
    if (caipNetwork) {
      ChainController.setCaipNetwork(caipNetwork.chain, caipNetwork, true);
      ChainController.setChainNetworkData(caipNetwork.chain, { isDefaultCaipNetwork: true });
      PublicStateController.set({ selectedNetworkId: caipNetwork.id });
    }
  },
  setActiveCaipNetwork(caipNetwork) {
    var _a2, _b;
    if (!caipNetwork) {
      return;
    }
    ChainController.setActiveCaipNetwork(caipNetwork);
    ChainController.setChainNetworkData(caipNetwork.chain, { caipNetwork });
    PublicStateController.set({
      activeChain: caipNetwork.chain,
      selectedNetworkId: caipNetwork == null ? void 0 : caipNetwork.id
    });
    if (!((_b = (_a2 = ChainController.state.chains.get(caipNetwork.chain)) == null ? void 0 : _a2.networkState) == null ? void 0 : _b.allowUnsupportedChain)) {
      const isSupported = this.checkIfSupportedNetwork();
      if (!isSupported) {
        this.showUnsupportedChainUI();
      }
    }
  },
  setCaipNetwork(caipNetwork) {
    var _a2, _b;
    if (!caipNetwork) {
      return;
    }
    if (!(caipNetwork == null ? void 0 : caipNetwork.chain)) {
      throw new Error("chain is required to set active network");
    }
    ChainController.setCaipNetwork(caipNetwork == null ? void 0 : caipNetwork.chain, caipNetwork);
    if (!((_b = (_a2 = ChainController.state.chains.get(caipNetwork.chain)) == null ? void 0 : _a2.networkState) == null ? void 0 : _b.allowUnsupportedChain)) {
      const isSupported = this.checkIfSupportedNetwork();
      if (!isSupported) {
        this.showUnsupportedChainUI();
      }
    }
  },
  setRequestedCaipNetworks(requestedNetworks, chain) {
    ChainController.setChainNetworkData(chain, { requestedCaipNetworks: requestedNetworks });
  },
  setAllowUnsupportedChain(allowUnsupportedChain, chain) {
    ChainController.setChainNetworkData(chain || ChainController.state.activeChain, {
      allowUnsupportedChain
    });
  },
  setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain) {
    ChainController.setChainNetworkData(chain, { smartAccountEnabledNetworks });
  },
  getRequestedCaipNetworks(chainToFilter) {
    let chainAdapters = void 0;
    if (!ChainController.state.activeChain) {
      throw new Error("activeChain is required to get requested networks");
    }
    if (chainToFilter) {
      const chain = chainToFilter;
      if (!chain) {
        throw new Error("chain is required to get requested networks");
      }
      chainAdapters = [chain];
    } else {
      const chains = [...ChainController.state.chains.keys()];
      chainAdapters = chains;
    }
    const approvedIds = [];
    const requestedNetworks = [];
    chainAdapters.forEach((chn) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      if ((_b = (_a2 = ChainController.state.chains.get(chn)) == null ? void 0 : _a2.networkState) == null ? void 0 : _b.approvedCaipNetworkIds) {
        approvedIds.push(...((_d = (_c = ChainController.state.chains.get(chn)) == null ? void 0 : _c.networkState) == null ? void 0 : _d.approvedCaipNetworkIds) || []);
      }
      if ((_f = (_e = ChainController.state.chains.get(chn)) == null ? void 0 : _e.networkState) == null ? void 0 : _f.requestedCaipNetworks) {
        requestedNetworks.push(...((_h = (_g = ChainController.state.chains.get(chn)) == null ? void 0 : _g.networkState) == null ? void 0 : _h.requestedCaipNetworks) || []);
      }
    });
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedIds, requestedNetworks);
    return sortedNetworks;
  },
  async switchActiveNetwork(network) {
    var _a2;
    const networkControllerClient = network ? (_a2 = ChainController.state.chains.get(network.chain)) == null ? void 0 : _a2.networkControllerClient : void 0;
    if (!networkControllerClient) {
      throw new Error("networkControllerClient not found for given network object");
    }
    ChainController.setActiveCaipNetwork(network);
    await (networkControllerClient == null ? void 0 : networkControllerClient.switchCaipNetwork(network));
    if (network) {
      EventsController.sendEvent({
        type: "track",
        event: "SWITCH_NETWORK",
        properties: { network: network.id }
      });
    }
  },
  getApprovedCaipNetworkIds(chainToFilter) {
    var _a2, _b;
    if (chainToFilter) {
      const chain = chainToFilter;
      if (!chain) {
        throw new Error("chain is required to get approved network IDs");
      }
      return (_b = (_a2 = ChainController.state.chains.get(chain)) == null ? void 0 : _a2.networkState) == null ? void 0 : _b.approvedCaipNetworkIds;
    }
    const allCaipNetworkIds = [];
    Object.values(ChainController.state.chains).forEach((adapter) => {
      var _a3;
      if (adapter.networkState.approvedCaipNetworkIds) {
        allCaipNetworkIds.push(...((_a3 = adapter.networkState) == null ? void 0 : _a3.approvedCaipNetworkIds) || []);
      }
    });
    return allCaipNetworkIds;
  },
  async setApprovedCaipNetworksData(chain) {
    const networkControllerClient = ChainController.getNetworkControllerClient();
    const data = await networkControllerClient.getApprovedCaipNetworksData();
    if (!chain) {
      throw new Error("chain is required to set approved network data");
    }
    ChainController.setChainNetworkData(chain, {
      approvedCaipNetworkIds: data == null ? void 0 : data.approvedCaipNetworkIds,
      supportsAllNetworks: (data == null ? void 0 : data.supportsAllNetworks) || false
    });
  },
  checkIfSupportedNetwork() {
    var _a2, _b;
    const chain = ChainController.state.activeChain;
    if (!chain) {
      return false;
    }
    const activeCaipNetwork = (_b = (_a2 = ChainController.state.chains.get(chain)) == null ? void 0 : _a2.networkState) == null ? void 0 : _b.caipNetwork;
    const requestedCaipNetworks = this.getRequestedCaipNetworks();
    if (!requestedCaipNetworks.length) {
      return true;
    }
    return requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.some((network) => network.id === (activeCaipNetwork == null ? void 0 : activeCaipNetwork.id));
  },
  checkIfSmartAccountEnabled() {
    var _a2;
    const networkId = NetworkUtil.caipNetworkIdToNumber((_a2 = state13.caipNetwork) == null ? void 0 : _a2.id);
    const activeChain = ChainController.state.activeChain;
    if (!activeChain) {
      throw new Error("activeChain is required to check if smart account is enabled");
    }
    if (!networkId) {
      return false;
    }
    const smartAccountEnabledNetworks = ChainController.getNetworkProp("smartAccountEnabledNetworks");
    return Boolean(smartAccountEnabledNetworks == null ? void 0 : smartAccountEnabledNetworks.includes(networkId));
  },
  checkIfNamesSupported() {
    var _a2, _b;
    const chain = ChainController.state.activeChain;
    if (!chain) {
      return false;
    }
    const activeCaipNetwork = (_b = (_a2 = ChainController.state.chains.get(chain)) == null ? void 0 : _a2.networkState) == null ? void 0 : _b.caipNetwork;
    return (activeCaipNetwork == null ? void 0 : activeCaipNetwork.chain) === ConstantsUtil.CHAIN.EVM;
  },
  resetNetwork() {
    const chain = ChainController.state.activeChain;
    if (!chain) {
      throw new Error("chain is required to reset network");
    }
    ChainController.setChainNetworkData(chain, {
      approvedCaipNetworkIds: void 0,
      supportsAllNetworks: true,
      smartAccountEnabledNetworks: []
    });
  },
  getSupportsAllNetworks() {
    var _a2, _b;
    const chain = ChainController.state.activeChain;
    if (!chain) {
      throw new Error("chain is required to check if network supports all networks");
    }
    return (_b = (_a2 = ChainController.state.chains.get(chain)) == null ? void 0 : _a2.networkState) == null ? void 0 : _b.supportsAllNetworks;
  },
  showUnsupportedChainUI() {
    setTimeout(() => {
      ModalController.open({ view: "UnsupportedChain" });
    }, 300);
  },
  getActiveNetworkTokenAddress() {
    var _a2, _b;
    const address = ConstantsUtil2.NATIVE_TOKEN_ADDRESS[((_a2 = this.state.caipNetwork) == null ? void 0 : _a2.chain) || "evm"];
    return `${((_b = this.state.caipNetwork) == null ? void 0 : _b.id) || "eip155:1"}:${address}`;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ApiController.js
var baseUrl3 = CoreHelperUtil.getApiUrl();
var api2 = new FetchUtil({ baseUrl: baseUrl3, clientId: null });
var entries = "40";
var recommendedEntries = "4";
var imageCountToFetch = 20;
var state14 = proxy({
  page: 1,
  count: 0,
  featured: [],
  recommended: [],
  wallets: [],
  search: [],
  isAnalyticsEnabled: false,
  excludedRDNS: []
});
var ApiController = {
  state: state14,
  subscribeKey(key, callback) {
    return subscribeKey(state14, key, callback);
  },
  _getApiHeaders() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  _filterOutExtensions(wallets) {
    if (OptionsController.state.isUniversalProvider) {
      return wallets.filter((w) => Boolean(w.mobile_link || w.desktop_link || w.webapp_link));
    }
    return wallets;
  },
  async _fetchWalletImage(imageId) {
    const imageUrl = `${api2.baseUrl}/getWalletImage/${imageId}`;
    const blob = await api2.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setWalletImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchNetworkImage(imageId) {
    const imageUrl = `${api2.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api2.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setNetworkImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchConnectorImage(imageId) {
    const imageUrl = `${api2.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api2.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setConnectorImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchCurrencyImage(countryCode) {
    const imageUrl = `${api2.baseUrl}/public/getCurrencyImage/${countryCode}`;
    const blob = await api2.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setCurrencyImage(countryCode, URL.createObjectURL(blob));
  },
  async _fetchTokenImage(symbol) {
    const imageUrl = `${api2.baseUrl}/public/getTokenImage/${symbol}`;
    const blob = await api2.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setTokenImage(symbol, URL.createObjectURL(blob));
  },
  async fetchNetworkImages() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const ids = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.map(({ imageId }) => imageId).filter(Boolean);
    if (ids) {
      await Promise.allSettled(ids.map((id) => ApiController._fetchNetworkImage(id)));
    }
  },
  async fetchConnectorImages() {
    const { connectors } = ConnectorController.state;
    const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
    await Promise.allSettled(ids.map((id) => ApiController._fetchConnectorImage(id)));
  },
  async fetchCurrencyImages(currencies = []) {
    await Promise.allSettled(currencies.map((currency) => ApiController._fetchCurrencyImage(currency)));
  },
  async fetchTokenImages(tokens = []) {
    await Promise.allSettled(tokens.map((token) => ApiController._fetchTokenImage(token)));
  },
  async fetchFeaturedWallets() {
    const { featuredWalletIds } = OptionsController.state;
    if (featuredWalletIds == null ? void 0 : featuredWalletIds.length) {
      const { data } = await api2.get({
        path: "/getWallets",
        headers: ApiController._getApiHeaders(),
        params: {
          page: "1",
          entries: (featuredWalletIds == null ? void 0 : featuredWalletIds.length) ? String(featuredWalletIds.length) : recommendedEntries,
          include: featuredWalletIds == null ? void 0 : featuredWalletIds.join(",")
        }
      });
      data.sort((a, b) => featuredWalletIds.indexOf(a.id) - featuredWalletIds.indexOf(b.id));
      const images = data.map((d) => d.image_id).filter(Boolean);
      await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
      state14.featured = data;
    }
  },
  async fetchRecommendedWallets() {
    var _a2;
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [...excludeWalletIds ?? [], ...featuredWalletIds ?? []].filter(Boolean);
    const { data, count } = await api2.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        chains: (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id,
        entries: recommendedEntries,
        include: includeWalletIds == null ? void 0 : includeWalletIds.join(","),
        exclude: exclude == null ? void 0 : exclude.join(",")
      }
    });
    const recent = StorageUtil.getRecentWallets();
    const recommendedImages = data.map((d) => d.image_id).filter(Boolean);
    const recentImages = recent.map((r) => r.image_id).filter(Boolean);
    await Promise.allSettled([...recommendedImages, ...recentImages].map((id) => ApiController._fetchWalletImage(id)));
    state14.recommended = data;
    state14.count = count ?? 0;
  },
  async fetchWallets({ page }) {
    var _a2;
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [
      ...state14.recommended.map(({ id }) => id),
      ...excludeWalletIds ?? [],
      ...featuredWalletIds ?? []
    ].filter(Boolean);
    const { data, count } = await api2.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: String(page),
        entries,
        chains: (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id,
        include: includeWalletIds == null ? void 0 : includeWalletIds.join(","),
        exclude: exclude.join(",")
      }
    });
    const images = data.slice(0, imageCountToFetch).map((w) => w.image_id).filter(Boolean);
    await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
    state14.wallets = CoreHelperUtil.uniqueBy([...state14.wallets, ...ApiController._filterOutExtensions(data)], "id");
    state14.count = count > state14.count ? count : state14.count;
    state14.page = page;
  },
  async searchWalletByIds({ ids }) {
    var _a2;
    const { data } = await api2.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: String(ids.length),
        chains: (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id,
        include: ids == null ? void 0 : ids.join(",")
      }
    });
    if (data) {
      data.forEach((wallet) => {
        if (wallet == null ? void 0 : wallet.rdns) {
          state14.excludedRDNS.push(wallet.rdns);
        }
      });
    }
  },
  async searchWallet({ search }) {
    var _a2;
    const { includeWalletIds, excludeWalletIds } = OptionsController.state;
    state14.search = [];
    const { data } = await api2.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: "100",
        search: search == null ? void 0 : search.trim(),
        chains: (_a2 = NetworkController.state.caipNetwork) == null ? void 0 : _a2.id,
        include: includeWalletIds == null ? void 0 : includeWalletIds.join(","),
        exclude: excludeWalletIds == null ? void 0 : excludeWalletIds.join(",")
      }
    });
    const images = data.map((w) => w.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id) => ApiController._fetchWalletImage(id)),
      CoreHelperUtil.wait(300)
    ]);
    state14.search = ApiController._filterOutExtensions(data);
  },
  async reFetchWallets() {
    state14.page = 1;
    state14.wallets = [];
    await ApiController.fetchFeaturedWallets();
    await ApiController.fetchRecommendedWallets();
  },
  prefetch() {
    const promises = [
      ApiController.fetchFeaturedWallets(),
      ApiController.fetchRecommendedWallets(),
      ApiController.fetchNetworkImages(),
      ApiController.fetchConnectorImages()
    ];
    if (OptionsController.state.enableAnalytics) {
      promises.push(ApiController.fetchAnalyticsConfig());
    }
    state14.prefetchPromise = Promise.race([Promise.allSettled(promises)]);
  },
  async fetchAnalyticsConfig() {
    const { isAnalyticsEnabled } = await api2.get({
      path: "/getAnalyticsConfig",
      headers: ApiController._getApiHeaders()
    });
    OptionsController.setEnableAnalytics(isAnalyticsEnabled);
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/OptionsController.js
var state15 = proxy({
  projectId: "",
  sdkType: "w3m",
  sdkVersion: "html-wagmi-undefined",
  enableAnalytics: ConstantsUtil2.DEFAULT_FEATURES.analytics,
  enableOnramp: ConstantsUtil2.DEFAULT_FEATURES.onramp,
  enableSwaps: ConstantsUtil2.DEFAULT_FEATURES.swaps,
  allWallets: ConstantsUtil2.DEFAULT_FEATURES.allWallets,
  disableAppend: ConstantsUtil2.DEFAULT_FEATURES.disableAppend,
  enableEIP6963: ConstantsUtil2.DEFAULT_FEATURES.enableEIP6963
});
var OptionsController = {
  state: state15,
  subscribeKey(key, callback) {
    return subscribeKey(state15, key, callback);
  },
  setOptions(options) {
    Object.assign(state15, options);
  },
  setProjectId(projectId) {
    state15.projectId = projectId;
  },
  setAllWallets(allWallets = ConstantsUtil2.DEFAULT_FEATURES.allWallets) {
    state15.allWallets = allWallets;
  },
  setIncludeWalletIds(includeWalletIds) {
    state15.includeWalletIds = includeWalletIds;
  },
  setExcludeWalletIds(excludeWalletIds) {
    state15.excludeWalletIds = excludeWalletIds;
    if (excludeWalletIds) {
      ApiController.searchWalletByIds({ ids: excludeWalletIds });
    }
  },
  setFeaturedWalletIds(featuredWalletIds) {
    state15.featuredWalletIds = featuredWalletIds;
  },
  setTokens(tokens) {
    state15.tokens = tokens;
  },
  setTermsConditionsUrl(termsConditionsUrl) {
    state15.termsConditionsUrl = termsConditionsUrl;
  },
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    state15.privacyPolicyUrl = privacyPolicyUrl;
  },
  setCustomWallets(customWallets) {
    state15.customWallets = customWallets;
  },
  setIsSiweEnabled(isSiweEnabled) {
    state15.isSiweEnabled = isSiweEnabled;
  },
  setIsUniversalProvider(isUniversalProvider) {
    state15.isUniversalProvider = isUniversalProvider;
  },
  setEnableAnalytics(enableAnalytics = ConstantsUtil2.DEFAULT_FEATURES.analytics) {
    state15.enableAnalytics = enableAnalytics;
  },
  setSdkVersion(sdkVersion) {
    state15.sdkVersion = sdkVersion;
  },
  setMetadata(metadata) {
    state15.metadata = metadata;
  },
  setOnrampEnabled(enableOnramp = ConstantsUtil2.DEFAULT_FEATURES.onramp) {
    state15.enableOnramp = enableOnramp;
  },
  setDisableAppend(disableAppend = ConstantsUtil2.DEFAULT_FEATURES.disableAppend) {
    state15.disableAppend = disableAppend;
  },
  setEIP6963Enabled(enableEIP6963 = ConstantsUtil2.DEFAULT_FEATURES.enableEIP6963) {
    state15.enableEIP6963 = enableEIP6963;
  },
  setHasMultipleAddresses(hasMultipleAddresses) {
    state15.hasMultipleAddresses = hasMultipleAddresses;
  },
  setEnableSwaps(enableSwaps = ConstantsUtil2.DEFAULT_FEATURES.swaps) {
    state15.enableSwaps = enableSwaps;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ConnectorController.js
var state16 = proxy({
  unMergedConnectors: [],
  connectors: []
});
var ConnectorController = {
  state: state16,
  subscribeKey(key, callback) {
    return subscribeKey(state16, key, callback);
  },
  setConnectors(connectors) {
    connectors.forEach(this.syncIfAuthConnector);
    state16.unMergedConnectors = [...state16.unMergedConnectors, ...connectors].filter((connector) => {
      try {
        const canProxyConnector = Boolean(proxy(connector));
        if (!canProxyConnector) {
          throw new Error("Connector is not available");
        }
        return true;
      } catch (error) {
        console.error("ConnectorController.setConnectors: Not possible to add connector", {
          connector,
          error
        });
        return false;
      }
    });
    state16.connectors = this.mergeMultiChainConnectors(state16.unMergedConnectors);
  },
  mergeMultiChainConnectors(connectors) {
    const connectorsByNameMap = this.generateConnectorMapByName(connectors);
    const refactoredConnectors = Array.from(connectorsByNameMap.values()).map((_connectors) => {
      var _a2, _b, _c;
      if (_connectors.length > 1) {
        return {
          name: (_a2 = _connectors[0]) == null ? void 0 : _a2.name,
          imageUrl: (_b = _connectors[0]) == null ? void 0 : _b.imageUrl,
          imageId: (_c = _connectors[0]) == null ? void 0 : _c.imageId,
          providers: this.getUniqueConnectorsByName(_connectors),
          type: "MULTI_CHAIN"
        };
      }
      return _connectors[0];
    });
    return refactoredConnectors;
  },
  generateConnectorMapByName(connectors) {
    const connectorsByNameMap = /* @__PURE__ */ new Map();
    connectors.forEach((connector) => {
      const { name } = connector;
      if (!name) {
        return;
      }
      const connectorsByName = connectorsByNameMap.get(name) || [];
      const haveSameConnector = connectorsByName.find((c) => c.chain === connector.chain);
      if (!haveSameConnector) {
        connectorsByName.push(connector);
      }
      connectorsByNameMap.set(name, connectorsByName);
    });
    return connectorsByNameMap;
  },
  getUniqueConnectorsByName(connectors) {
    const uniqueConnectors = [];
    connectors.forEach((c) => {
      if (!uniqueConnectors.find((uc) => uc.chain === c.chain)) {
        uniqueConnectors.push({
          ...c,
          name: ConstantsUtil.CHAIN_NAME_MAP[c.chain]
        });
      }
    });
    return uniqueConnectors;
  },
  addConnector(connector) {
    this.setConnectors([connector]);
  },
  getAuthConnector() {
    return state16.connectors.find((c) => c.type === "AUTH");
  },
  getAnnouncedConnectorRdns() {
    return state16.connectors.filter((c) => c.type === "ANNOUNCED").map((c) => {
      var _a2;
      return (_a2 = c.info) == null ? void 0 : _a2.rdns;
    });
  },
  getConnectors() {
    return state16.connectors;
  },
  getConnector(id, rdns) {
    return state16.connectors.find((c) => {
      var _a2;
      return c.explorerId === id || ((_a2 = c.info) == null ? void 0 : _a2.rdns) === rdns;
    });
  },
  syncIfAuthConnector(connector) {
    var _a2, _b;
    if (connector.id !== "w3mAuth") {
      return;
    }
    const authConnector = connector;
    const optionsState = snapshot(OptionsController.state);
    const themeMode = ThemeController.getSnapshot().themeMode;
    const themeVariables = ThemeController.getSnapshot().themeVariables;
    (_b = (_a2 = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _a2.syncDappData) == null ? void 0 : _b.call(_a2, {
      metadata: optionsState.metadata,
      sdkVersion: optionsState.sdkVersion,
      projectId: optionsState.projectId
    });
    authConnector.provider.syncTheme({
      themeMode,
      themeVariables,
      w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
    });
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ThemeController.js
var state17 = proxy({
  themeMode: "dark",
  themeVariables: {},
  w3mThemeVariables: void 0
});
var ThemeController = {
  state: state17,
  subscribe(callback) {
    return subscribe(state17, () => callback(state17));
  },
  setThemeMode(themeMode) {
    state17.themeMode = themeMode;
    try {
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        const themeVariables = ThemeController.getSnapshot().themeVariables;
        authConnector.provider.syncTheme({
          themeMode,
          themeVariables,
          w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  setThemeVariables(themeVariables) {
    state17.themeVariables = { ...state17.themeVariables, ...themeVariables };
    try {
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        const themeVariablesSnapshot = ThemeController.getSnapshot().themeVariables;
        authConnector.provider.syncTheme({
          themeVariables: themeVariablesSnapshot,
          w3mThemeVariables: getW3mThemeVariables(state17.themeVariables, state17.themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  getSnapshot() {
    return snapshot(state17);
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/EnsUtil.js
var SLIP44_MSB = 2147483648;
var EnsUtil = {
  convertEVMChainIdToCoinType(chainId) {
    if (chainId >= SLIP44_MSB) {
      throw new Error("Invalid chainId");
    }
    return (SLIP44_MSB | chainId) >>> 0;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/EnsController.js
var state18 = proxy({
  suggestions: [],
  loading: false
});
var EnsController = {
  state: state18,
  subscribe(callback) {
    return subscribe(state18, () => callback(state18));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state18, key, callback);
  },
  async resolveName(name) {
    var _a2, _b;
    try {
      return await BlockchainApiController.lookupEnsName(name);
    } catch (e) {
      const error = e;
      throw new Error(((_b = (_a2 = error == null ? void 0 : error.reasons) == null ? void 0 : _a2[0]) == null ? void 0 : _b.description) || "Error resolving name");
    }
  },
  async isNameRegistered(name) {
    try {
      await BlockchainApiController.lookupEnsName(name);
      return true;
    } catch {
      return false;
    }
  },
  async getSuggestions(name) {
    try {
      state18.loading = true;
      state18.suggestions = [];
      const response = await BlockchainApiController.getEnsNameSuggestions(name);
      state18.suggestions = response.suggestions.map((suggestion) => ({
        ...suggestion,
        name: suggestion.name.replace(ConstantsUtil.WC_NAME_SUFFIX, "")
      })) || [];
      return state18.suggestions;
    } catch (e) {
      const errorMessage = this.parseEnsApiError(e, "Error fetching name suggestions");
      throw new Error(errorMessage);
    } finally {
      state18.loading = false;
    }
  },
  async getNamesForAddress(address) {
    try {
      const network = NetworkController.state.caipNetwork;
      if (!network) {
        return [];
      }
      const response = await BlockchainApiController.reverseLookupEnsName({ address });
      return response;
    } catch (e) {
      const errorMessage = this.parseEnsApiError(e, "Error fetching names for address");
      throw new Error(errorMessage);
    }
  },
  async registerName(name) {
    const network = NetworkController.state.caipNetwork;
    if (!network) {
      throw new Error("Network not found");
    }
    const address = AccountController.state.address;
    const emailConnector = ConnectorController.getAuthConnector();
    if (!address || !emailConnector) {
      throw new Error("Address or auth connector not found");
    }
    state18.loading = true;
    try {
      const message = JSON.stringify({
        name: `${name}${ConstantsUtil.WC_NAME_SUFFIX}`,
        attributes: {},
        timestamp: Math.floor(Date.now() / 1e3)
      });
      RouterController.pushTransactionStack({
        view: "RegisterAccountNameSuccess",
        goBack: false,
        replace: true,
        onCancel() {
          state18.loading = false;
        }
      });
      const signature = await ConnectionController.signMessage(message);
      const networkId = NetworkUtil.caipNetworkIdToNumber(network.id);
      if (!networkId) {
        throw new Error("Network not found");
      }
      const coinType = EnsUtil.convertEVMChainIdToCoinType(networkId);
      await BlockchainApiController.registerEnsName({
        coinType,
        address,
        signature,
        message
      });
      AccountController.setProfileName(`${name}${ConstantsUtil.WC_NAME_SUFFIX}`, ChainController.state.activeChain);
      RouterController.replace("RegisterAccountNameSuccess");
    } catch (e) {
      const errorMessage = this.parseEnsApiError(e, `Error registering name ${name}`);
      RouterController.replace("RegisterAccountName");
      throw new Error(errorMessage);
    } finally {
      state18.loading = false;
    }
  },
  validateName(name) {
    return /^[a-zA-Z0-9-]{4,}$/u.test(name);
  },
  parseEnsApiError(error, defaultError) {
    var _a2, _b;
    const ensError = error;
    return ((_b = (_a2 = ensError == null ? void 0 : ensError.reasons) == null ? void 0 : _a2[0]) == null ? void 0 : _b.description) || defaultError;
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/AssetUtil.js
var namespaceImageIds = {
  // Ethereum
  evm: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
  // Solana
  solana: "a1b58899-f671-4276-6a5e-56ca5bd59700"
};
var AssetUtil = {
  async fetchWalletImage(imageId) {
    if (!imageId) {
      return void 0;
    }
    await ApiController._fetchWalletImage(imageId);
    return this.getWalletImageById(imageId);
  },
  getWalletImageById(imageId) {
    if (!imageId) {
      return void 0;
    }
    return AssetController.state.walletImages[imageId];
  },
  getWalletImage(wallet) {
    if (wallet == null ? void 0 : wallet.image_url) {
      return wallet == null ? void 0 : wallet.image_url;
    }
    if (wallet == null ? void 0 : wallet.image_id) {
      return AssetController.state.walletImages[wallet.image_id];
    }
    return void 0;
  },
  getNetworkImage(network) {
    if (network == null ? void 0 : network.imageUrl) {
      return network == null ? void 0 : network.imageUrl;
    }
    if (network == null ? void 0 : network.imageId) {
      return AssetController.state.networkImages[network.imageId];
    }
    return void 0;
  },
  getNetworkImageById(imageId) {
    if (!imageId) {
      return void 0;
    }
    return AssetController.state.networkImages[imageId];
  },
  getConnectorImage(connector) {
    if (connector == null ? void 0 : connector.imageUrl) {
      return connector.imageUrl;
    }
    if (connector == null ? void 0 : connector.imageId) {
      return AssetController.state.connectorImages[connector.imageId];
    }
    return void 0;
  },
  getChainImage(chain) {
    return AssetController.state.networkImages[namespaceImageIds[chain]];
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/RouterUtil.js
var RouterUtil = {
  goBackOrCloseModal() {
    if (RouterController.state.history.length > 1) {
      RouterController.goBack();
    } else {
      ModalController.close();
    }
  },
  navigateAfterNetworkSwitch() {
    const { history } = RouterController.state;
    const networkSelectIndex = history.findIndex((name) => name === "Networks");
    if (networkSelectIndex >= 1) {
      RouterController.goBackToIndex(networkSelectIndex - 1);
    } else {
      ModalController.close();
    }
  },
  navigateAfterPreferredAccountTypeSelect() {
    const { isSiweEnabled } = OptionsController.state;
    if (isSiweEnabled && ChainController.state.activeChain === ConstantsUtil.CHAIN.EVM) {
      RouterController.push("ConnectingSiwe");
    } else {
      RouterController.push("Account");
    }
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/OnRampController.js
var USDC_CURRENCY_DEFAULT = {
  id: "2b92315d-eab7-5bef-84fa-089a131333f5",
  name: "USD Coin",
  symbol: "USDC",
  networks: [
    {
      name: "ethereum-mainnet",
      display_name: "Ethereum",
      chain_id: "1",
      contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    },
    {
      name: "polygon-mainnet",
      display_name: "Polygon",
      chain_id: "137",
      contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
    }
  ]
};
var USD_CURRENCY_DEFAULT = {
  id: "USD",
  payment_method_limits: [
    {
      id: "card",
      min: "10.00",
      max: "7500.00"
    },
    {
      id: "ach_bank_account",
      min: "10.00",
      max: "25000.00"
    }
  ]
};
var defaultState = {
  providers: ONRAMP_PROVIDERS,
  selectedProvider: null,
  error: null,
  purchaseCurrency: USDC_CURRENCY_DEFAULT,
  paymentCurrency: USD_CURRENCY_DEFAULT,
  purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
  paymentCurrencies: [],
  quotesLoading: false
};
var state19 = proxy(defaultState);
var OnRampController = {
  state: state19,
  subscribe(callback) {
    return subscribe(state19, () => callback(state19));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state19, key, callback);
  },
  setSelectedProvider(provider) {
    if (provider && provider.name === "meld") {
      const pubKey = false ? MELD_PROD_PUBLIC_KEY : MELD_DEV_PUBLIC_KEY;
      const currency = ChainController.state.activeChain === ConstantsUtil.CHAIN.SOLANA ? "SOL" : "USDC";
      const address = AccountController.state.address ?? "";
      const url = new URL(provider.url);
      url.searchParams.append("publicKey", pubKey);
      url.searchParams.append("destinationCurrencyCode", currency);
      url.searchParams.append("walletAddress", address);
      provider.url = url.toString();
    }
    state19.selectedProvider = provider;
  },
  setPurchaseCurrency(currency) {
    state19.purchaseCurrency = currency;
  },
  setPaymentCurrency(currency) {
    state19.paymentCurrency = currency;
  },
  setPurchaseAmount(amount) {
    this.state.purchaseAmount = amount;
  },
  setPaymentAmount(amount) {
    this.state.paymentAmount = amount;
  },
  async getAvailableCurrencies() {
    const options = await BlockchainApiController.getOnrampOptions();
    state19.purchaseCurrencies = options.purchaseCurrencies;
    state19.paymentCurrencies = options.paymentCurrencies;
    state19.paymentCurrency = options.paymentCurrencies[0] || USD_CURRENCY_DEFAULT;
    state19.purchaseCurrency = options.purchaseCurrencies[0] || USDC_CURRENCY_DEFAULT;
    await ApiController.fetchCurrencyImages(options.paymentCurrencies.map((currency) => currency.id));
    await ApiController.fetchTokenImages(options.purchaseCurrencies.map((currency) => currency.symbol));
  },
  async getQuote() {
    var _a2, _b;
    state19.quotesLoading = true;
    try {
      const quote = await BlockchainApiController.getOnrampQuote({
        purchaseCurrency: state19.purchaseCurrency,
        paymentCurrency: state19.paymentCurrency,
        amount: ((_a2 = state19.paymentAmount) == null ? void 0 : _a2.toString()) || "0",
        network: (_b = state19.purchaseCurrency) == null ? void 0 : _b.symbol
      });
      state19.quotesLoading = false;
      state19.purchaseAmount = Number(quote.purchaseAmount.amount);
      return quote;
    } catch (error) {
      state19.error = error.message;
      state19.quotesLoading = false;
      return null;
    } finally {
      state19.quotesLoading = false;
    }
  },
  resetState() {
    state19.providers = ONRAMP_PROVIDERS;
    state19.selectedProvider = null;
    state19.error = null;
    state19.purchaseCurrency = USDC_CURRENCY_DEFAULT;
    state19.paymentCurrency = USD_CURRENCY_DEFAULT;
    state19.purchaseCurrencies = [USDC_CURRENCY_DEFAULT];
    state19.paymentCurrencies = [];
    state19.paymentAmount = void 0;
    state19.purchaseAmount = void 0;
    state19.quotesLoading = false;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/SendController.js
var state20 = proxy({
  loading: false
});
var SendController = {
  state: state20,
  subscribe(callback) {
    return subscribe(state20, () => callback(state20));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state20, key, callback);
  },
  setToken(token) {
    if (token) {
      state20.token = ref(token);
    }
  },
  setTokenAmount(sendTokenAmount) {
    state20.sendTokenAmount = sendTokenAmount;
  },
  setReceiverAddress(receiverAddress) {
    state20.receiverAddress = receiverAddress;
  },
  setReceiverProfileImageUrl(receiverProfileImageUrl) {
    state20.receiverProfileImageUrl = receiverProfileImageUrl;
  },
  setReceiverProfileName(receiverProfileName) {
    state20.receiverProfileName = receiverProfileName;
  },
  setGasPrice(gasPrice) {
    state20.gasPrice = gasPrice;
  },
  setGasPriceInUsd(gasPriceInUSD) {
    state20.gasPriceInUSD = gasPriceInUSD;
  },
  setLoading(loading) {
    state20.loading = loading;
  },
  sendToken() {
    var _a2;
    switch ((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.chain) {
      case "evm":
        this.sendEvmToken();
        return;
      case "solana":
        this.sendSolanaToken();
        return;
      default:
        throw new Error("Unsupported chain");
    }
  },
  sendEvmToken() {
    var _a2, _b, _c, _d, _e;
    if (((_a2 = this.state.token) == null ? void 0 : _a2.address) && this.state.sendTokenAmount && this.state.receiverAddress) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token.address,
          amount: this.state.sendTokenAmount,
          network: ((_b = NetworkController.state.caipNetwork) == null ? void 0 : _b.id) || ""
        }
      });
      this.sendERC20Token({
        receiverAddress: this.state.receiverAddress,
        tokenAddress: this.state.token.address,
        sendTokenAmount: this.state.sendTokenAmount,
        decimals: this.state.token.quantity.decimals
      });
    } else if (this.state.receiverAddress && this.state.sendTokenAmount && this.state.gasPrice && ((_c = this.state.token) == null ? void 0 : _c.quantity.decimals)) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: (_d = this.state.token) == null ? void 0 : _d.symbol,
          amount: this.state.sendTokenAmount,
          network: ((_e = NetworkController.state.caipNetwork) == null ? void 0 : _e.id) || ""
        }
      });
      this.sendNativeToken({
        receiverAddress: this.state.receiverAddress,
        sendTokenAmount: this.state.sendTokenAmount,
        gasPrice: this.state.gasPrice,
        decimals: this.state.token.quantity.decimals
      });
    }
  },
  async sendNativeToken(params) {
    var _a2, _b, _c, _d;
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    const to = params.receiverAddress;
    const address = AccountController.state.address;
    const value = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
    const data = "0x";
    try {
      await ConnectionController.sendTransaction({
        to,
        address,
        data,
        value,
        gasPrice: params.gasPrice
      });
      SnackController.showSuccess("Transaction started");
      EventsController.sendEvent({
        type: "track",
        event: "SEND_SUCCESS",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: ((_a2 = this.state.token) == null ? void 0 : _a2.symbol) || "",
          amount: params.sendTokenAmount,
          network: ((_b = NetworkController.state.caipNetwork) == null ? void 0 : _b.id) || ""
        }
      });
      this.resetSend();
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_ERROR",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: ((_c = this.state.token) == null ? void 0 : _c.symbol) || "",
          amount: params.sendTokenAmount,
          network: ((_d = NetworkController.state.caipNetwork) == null ? void 0 : _d.id) || ""
        }
      });
      SnackController.showError("Something went wrong");
    }
  },
  async sendERC20Token(params) {
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    const amount = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
    try {
      if (AccountController.state.address && params.sendTokenAmount && params.receiverAddress && params.tokenAddress) {
        await ConnectionController.writeContract({
          fromAddress: AccountController.state.address,
          tokenAddress: CoreHelperUtil.getPlainAddress(params.tokenAddress),
          receiverAddress: params.receiverAddress,
          tokenAmount: amount,
          method: "transfer",
          abi: erc20ABI
        });
        SnackController.showSuccess("Transaction started");
        this.resetSend();
      }
    } catch (error) {
      SnackController.showError("Something went wrong");
    }
  },
  sendSolanaToken() {
    if (!this.state.sendTokenAmount || !this.state.receiverAddress) {
      SnackController.showError("Please enter a valid amount and receiver address");
      return;
    }
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    ConnectionController.sendTransaction({
      chainNamespace: "solana",
      to: this.state.receiverAddress,
      value: this.state.sendTokenAmount
    }).then(() => {
      this.resetSend();
      AccountController.fetchTokenBalance();
    }).catch((error) => {
      SnackController.showError("Failed to send transaction. Please try again.");
      console.error("SendController:sendToken - failed to send solana transaction", error);
    });
  },
  resetSend() {
    state20.token = void 0;
    state20.sendTokenAmount = void 0;
    state20.receiverAddress = void 0;
    state20.receiverProfileImageUrl = void 0;
    state20.receiverProfileName = void 0;
    state20.loading = false;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/TooltipController.js
var state21 = proxy({
  message: "",
  open: false,
  triggerRect: {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  },
  variant: "shade"
});
var TooltipController = {
  state: state21,
  subscribe(callback) {
    return subscribe(state21, () => callback(state21));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state21, key, callback);
  },
  showTooltip({ message, triggerRect, variant }) {
    state21.open = true;
    state21.message = message;
    state21.triggerRect = triggerRect;
    state21.variant = variant;
  },
  hide() {
    state21.open = false;
    state21.message = "";
    state21.triggerRect = {
      width: 0,
      height: 0,
      top: 0,
      left: 0
    };
  }
};

export {
  DateUtil,
  NetworkUtil,
  NumberUtil,
  InputUtil,
  NavigationUtil,
  ConstantsUtil,
  getW3mThemeVariables,
  ConstantsUtil2,
  CoreHelperUtil,
  StorageUtil,
  AssetController,
  ThemeController,
  ConnectorController,
  EventsController,
  PublicStateController,
  ChainController,
  NetworkController,
  ApiController,
  OptionsController,
  BlockchainApiController,
  SnackController,
  W3mFrameRpcConstants,
  W3mFrameHelpers,
  W3mFrameProvider,
  TransactionsController,
  ConnectionController,
  RouterController,
  SwapController,
  AccountController,
  ModalController,
  OnRampController,
  SendController,
  TooltipController,
  EnsController,
  AssetUtil,
  RouterUtil
};
//# sourceMappingURL=chunk-CGGDFF2D.js.map
