{
  "version": 3,
  "sources": ["../../viem/utils/signature/recoverPublicKey.ts", "../../viem/accounts/utils/publicKeyToAddress.ts", "../../viem/utils/signature/recoverAddress.ts", "../../viem/utils/encoding/toRlp.ts", "../../viem/utils/chain/assertCurrentChain.ts", "../../viem/errors/fee.ts", "../../viem/errors/block.ts", "../../viem/utils/formatters/transaction.ts", "../../viem/utils/formatters/block.ts", "../../viem/errors/estimateGas.ts", "../../viem/utils/blob/blobsToCommitments.ts", "../../viem/utils/blob/blobsToProofs.ts", "../../viem/utils/hash/sha256.ts", "../../viem/utils/blob/commitmentToVersionedHash.ts", "../../viem/utils/blob/commitmentsToVersionedHashes.ts", "../../viem/constants/blob.ts", "../../viem/constants/kzg.ts", "../../viem/errors/blob.ts", "../../viem/utils/blob/toBlobs.ts", "../../viem/utils/blob/toBlobSidecars.ts", "../../viem/utils/transaction/getTransactionType.ts", "../../viem/utils/formatters/log.ts", "../../viem/utils/formatters/transactionReceipt.ts", "../../viem/utils/chain/defineChain.ts", "../../viem/utils/transaction/assertTransaction.ts", "../../viem/utils/transaction/serializeAccessList.ts", "../../viem/experimental/eip7702/utils/serializeAuthorizationList.ts", "../../viem/utils/transaction/serializeTransaction.ts", "../../viem/utils/getAction.ts", "../../viem/actions/public/getChainId.ts", "../../viem/actions/public/getBlock.ts", "../../viem/actions/public/getGasPrice.ts", "../../viem/actions/public/estimateMaxPriorityFeePerGas.ts", "../../viem/actions/public/estimateFeesPerGas.ts", "../../viem/actions/public/getBalance.ts", "../../viem/experimental/eip7702/utils/hashAuthorization.ts", "../../viem/experimental/eip7702/utils/recoverAuthorizationAddress.ts", "../../viem/utils/errors/getEstimateGasError.ts", "../../viem/actions/public/getTransactionCount.ts", "../../viem/actions/wallet/prepareTransactionRequest.ts", "../../viem/actions/public/estimateGas.ts", "../../viem/errors/account.ts"],
  "sourcesContent": ["import type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\r\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\r\nimport {\r\n  type HexToNumberErrorType,\r\n  hexToBigInt,\r\n  hexToNumber,\r\n} from '../encoding/fromHex.js'\r\nimport { toHex } from '../encoding/toHex.js'\r\n\r\nexport type RecoverPublicKeyParameters = {\r\n  hash: Hex | ByteArray\r\n  signature: Hex | ByteArray | Signature\r\n}\r\n\r\nexport type RecoverPublicKeyReturnType = Hex\r\n\r\nexport type RecoverPublicKeyErrorType =\r\n  | HexToNumberErrorType\r\n  | IsHexErrorType\r\n  | ErrorType\r\n\r\nexport async function recoverPublicKey({\r\n  hash,\r\n  signature,\r\n}: RecoverPublicKeyParameters): Promise<RecoverPublicKeyReturnType> {\r\n  const hashHex = isHex(hash) ? hash : toHex(hash)\r\n\r\n  const { secp256k1 } = await import('@noble/curves/secp256k1')\r\n  const signature_ = (() => {\r\n    // typeof signature: `Signature`\r\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\r\n      const { r, s, v, yParity } = signature\r\n      const yParityOrV = Number(yParity ?? v)!\r\n      const recoveryBit = toRecoveryBit(yParityOrV)\r\n      return new secp256k1.Signature(\r\n        hexToBigInt(r),\r\n        hexToBigInt(s),\r\n      ).addRecoveryBit(recoveryBit)\r\n    }\r\n\r\n    // typeof signature: `Hex | ByteArray`\r\n    const signatureHex = isHex(signature) ? signature : toHex(signature)\r\n    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`)\r\n    const recoveryBit = toRecoveryBit(yParityOrV)\r\n    return secp256k1.Signature.fromCompact(\r\n      signatureHex.substring(2, 130),\r\n    ).addRecoveryBit(recoveryBit)\r\n  })()\r\n\r\n  const publicKey = signature_\r\n    .recoverPublicKey(hashHex.substring(2))\r\n    .toHex(false)\r\n  return `0x${publicKey}`\r\n}\r\n\r\nfunction toRecoveryBit(yParityOrV: number) {\r\n  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV\r\n  if (yParityOrV === 27) return 0\r\n  if (yParityOrV === 28) return 1\r\n  throw new Error('Invalid yParityOrV value')\r\n}\r\n", "import type { Address } from 'abitype'\r\n\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { Hex } from '../../types/misc.js'\r\nimport {\r\n  type ChecksumAddressErrorType,\r\n  checksumAddress,\r\n} from '../../utils/address/getAddress.js'\r\nimport {\r\n  type Keccak256ErrorType,\r\n  keccak256,\r\n} from '../../utils/hash/keccak256.js'\r\n\r\nexport type PublicKeyToAddressErrorType =\r\n  | ChecksumAddressErrorType\r\n  | Keccak256ErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * @description Converts an ECDSA public key to an address.\r\n *\r\n * @param publicKey The public key to convert.\r\n *\r\n * @returns The address.\r\n */\r\nexport function publicKeyToAddress(publicKey: Hex): Address {\r\n  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26)\r\n  return checksumAddress(`0x${address}`) as Address\r\n}\r\n", "import type { Address } from 'abitype'\r\n\r\nimport { publicKeyToAddress } from '../../accounts/utils/publicKeyToAddress.js'\r\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\r\n\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport { recoverPublicKey } from './recoverPublicKey.js'\r\n\r\nexport type RecoverAddressParameters = {\r\n  hash: Hex | ByteArray\r\n  signature: Hex | ByteArray | Signature\r\n}\r\n\r\nexport type RecoverAddressReturnType = Address\r\n\r\nexport type RecoverAddressErrorType = ErrorType\r\n\r\nexport async function recoverAddress({\r\n  hash,\r\n  signature,\r\n}: RecoverAddressParameters): Promise<RecoverAddressReturnType> {\r\n  return publicKeyToAddress(await recoverPublicKey({ hash: hash, signature }))\r\n}\r\n", "import { BaseError } from '../../errors/base.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport {\r\n  type CreateCursorErrorType,\r\n  type Cursor,\r\n  createCursor,\r\n} from '../cursor.js'\r\n\r\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\r\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\r\n\r\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\ntype Encodable = {\r\n  length: number\r\n  encode(cursor: Cursor): void\r\n}\r\n\r\nexport type ToRlpReturnType<to extends To> =\r\n  | (to extends 'bytes' ? ByteArray : never)\r\n  | (to extends 'hex' ? Hex : never)\r\n\r\nexport type ToRlpErrorType =\r\n  | CreateCursorErrorType\r\n  | BytesToHexErrorType\r\n  | HexToBytesErrorType\r\n  | ErrorType\r\n\r\nexport function toRlp<to extends To = 'hex'>(\r\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\r\n  to: to | To | undefined = 'hex',\r\n): ToRlpReturnType<to> {\r\n  const encodable = getEncodable(bytes)\r\n  const cursor = createCursor(new Uint8Array(encodable.length))\r\n  encodable.encode(cursor)\r\n\r\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\r\n  return cursor.bytes as ToRlpReturnType<to>\r\n}\r\n\r\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\r\n\r\nexport function bytesToRlp<to extends To = 'bytes'>(\r\n  bytes: RecursiveArray<ByteArray>,\r\n  to: to | To | undefined = 'bytes',\r\n): ToRlpReturnType<to> {\r\n  return toRlp(bytes, to)\r\n}\r\n\r\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\r\n\r\nexport function hexToRlp<to extends To = 'hex'>(\r\n  hex: RecursiveArray<Hex>,\r\n  to: to | To | undefined = 'hex',\r\n): ToRlpReturnType<to> {\r\n  return toRlp(hex, to)\r\n}\r\n\r\nfunction getEncodable(\r\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\r\n): Encodable {\r\n  if (Array.isArray(bytes))\r\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\r\n  return getEncodableBytes(bytes as any)\r\n}\r\n\r\nfunction getEncodableList(list: Encodable[]): Encodable {\r\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\r\n\r\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\r\n  const length = (() => {\r\n    if (bodyLength <= 55) return 1 + bodyLength\r\n    return 1 + sizeOfBodyLength + bodyLength\r\n  })()\r\n\r\n  return {\r\n    length,\r\n    encode(cursor: Cursor) {\r\n      if (bodyLength <= 55) {\r\n        cursor.pushByte(0xc0 + bodyLength)\r\n      } else {\r\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\r\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\r\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\r\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\r\n        else cursor.pushUint32(bodyLength)\r\n      }\r\n      for (const { encode } of list) {\r\n        encode(cursor)\r\n      }\r\n    },\r\n  }\r\n}\r\n\r\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\r\n  const bytes =\r\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\r\n\r\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\r\n  const length = (() => {\r\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\r\n    if (bytes.length <= 55) return 1 + bytes.length\r\n    return 1 + sizeOfBytesLength + bytes.length\r\n  })()\r\n\r\n  return {\r\n    length,\r\n    encode(cursor: Cursor) {\r\n      if (bytes.length === 1 && bytes[0] < 0x80) {\r\n        cursor.pushBytes(bytes)\r\n      } else if (bytes.length <= 55) {\r\n        cursor.pushByte(0x80 + bytes.length)\r\n        cursor.pushBytes(bytes)\r\n      } else {\r\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\r\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\r\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\r\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\r\n        else cursor.pushUint32(bytes.length)\r\n        cursor.pushBytes(bytes)\r\n      }\r\n    },\r\n  }\r\n}\r\n\r\nfunction getSizeOfLength(length: number) {\r\n  if (length < 2 ** 8) return 1\r\n  if (length < 2 ** 16) return 2\r\n  if (length < 2 ** 24) return 3\r\n  if (length < 2 ** 32) return 4\r\n  throw new BaseError('Length is too large.')\r\n}\r\n", "import {\r\n  ChainMismatchError,\r\n  type ChainMismatchErrorType,\r\n  ChainNotFoundError,\r\n  type ChainNotFoundErrorType,\r\n} from '../../errors/chain.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { Chain } from '../../types/chain.js'\r\n\r\nexport type AssertCurrentChainParameters = {\r\n  chain?: Chain | undefined\r\n  currentChainId: number\r\n}\r\n\r\nexport type AssertCurrentChainErrorType =\r\n  | ChainNotFoundErrorType\r\n  | ChainMismatchErrorType\r\n  | ErrorType\r\n\r\nexport function assertCurrentChain({\r\n  chain,\r\n  currentChainId,\r\n}: AssertCurrentChainParameters): void {\r\n  if (!chain) throw new ChainNotFoundError()\r\n  if (currentChainId !== chain.id)\r\n    throw new ChainMismatchError({ chain, currentChainId })\r\n}\r\n", "import { formatGwei } from '../utils/unit/formatGwei.js'\r\nimport { BaseError } from './base.js'\r\n\r\nexport type BaseFeeScalarErrorType = BaseFeeScalarError & {\r\n  name: 'BaseFeeScalarError'\r\n}\r\nexport class BaseFeeScalarError extends BaseError {\r\n  constructor() {\r\n    super('`baseFeeMultiplier` must be greater than 1.', {\r\n      name: 'BaseFeeScalarError',\r\n    })\r\n  }\r\n}\r\n\r\nexport type Eip1559FeesNotSupportedErrorType = Eip1559FeesNotSupportedError & {\r\n  name: 'Eip1559FeesNotSupportedError'\r\n}\r\nexport class Eip1559FeesNotSupportedError extends BaseError {\r\n  constructor() {\r\n    super('Chain does not support EIP-1559 fees.', {\r\n      name: 'Eip1559FeesNotSupportedError',\r\n    })\r\n  }\r\n}\r\n\r\nexport type MaxFeePerGasTooLowErrorType = MaxFeePerGasTooLowError & {\r\n  name: 'MaxFeePerGasTooLowError'\r\n}\r\nexport class MaxFeePerGasTooLowError extends BaseError {\r\n  constructor({ maxPriorityFeePerGas }: { maxPriorityFeePerGas: bigint }) {\r\n    super(\r\n      `\\`maxFeePerGas\\` cannot be less than the \\`maxPriorityFeePerGas\\` (${formatGwei(\r\n        maxPriorityFeePerGas,\r\n      )} gwei).`,\r\n      { name: 'MaxFeePerGasTooLowError' },\r\n    )\r\n  }\r\n}\r\n", "import type { Hash } from '../types/misc.js'\r\n\r\nimport { BaseError } from './base.js'\r\n\r\nexport type BlockNotFoundErrorType = BlockNotFoundError & {\r\n  name: 'BlockNotFoundError'\r\n}\r\nexport class BlockNotFoundError extends BaseError {\r\n  constructor({\r\n    blockHash,\r\n    blockNumber,\r\n  }: {\r\n    blockHash?: Hash | undefined\r\n    blockNumber?: bigint | undefined\r\n  }) {\r\n    let identifier = 'Block'\r\n    if (blockHash) identifier = `Block at hash \"${blockHash}\"`\r\n    if (blockNumber) identifier = `Block at number \"${blockNumber}\"`\r\n    super(`${identifier} could not be found.`, { name: 'BlockNotFoundError' })\r\n  }\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { SignedAuthorizationList } from '../../experimental/eip7702/types/authorization.js'\r\nimport type { RpcAuthorizationList } from '../../experimental/eip7702/types/rpc.js'\r\nimport type { BlockTag } from '../../types/block.js'\r\nimport type { Chain } from '../../types/chain.js'\r\nimport type {\r\n  ExtractChainFormatterExclude,\r\n  ExtractChainFormatterReturnType,\r\n} from '../../types/chain.js'\r\nimport type { Hex } from '../../types/misc.js'\r\nimport type { RpcTransaction } from '../../types/rpc.js'\r\nimport type { Transaction, TransactionType } from '../../types/transaction.js'\r\nimport type { ExactPartial, UnionLooseOmit } from '../../types/utils.js'\r\nimport { hexToNumber } from '../encoding/fromHex.js'\r\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\r\n\r\ntype TransactionPendingDependencies =\r\n  | 'blockHash'\r\n  | 'blockNumber'\r\n  | 'transactionIndex'\r\n\r\nexport type FormattedTransaction<\r\n  chain extends Chain | undefined = undefined,\r\n  blockTag extends BlockTag = BlockTag,\r\n  _FormatterReturnType = ExtractChainFormatterReturnType<\r\n    chain,\r\n    'transaction',\r\n    Transaction\r\n  >,\r\n  _ExcludedPendingDependencies extends string = TransactionPendingDependencies &\r\n    ExtractChainFormatterExclude<chain, 'transaction'>,\r\n> = UnionLooseOmit<_FormatterReturnType, TransactionPendingDependencies> & {\r\n  [_K in _ExcludedPendingDependencies]: never\r\n} & Pick<\r\n    Transaction<bigint, number, blockTag extends 'pending' ? true : false>,\r\n    TransactionPendingDependencies\r\n  >\r\n\r\nexport const transactionType = {\r\n  '0x0': 'legacy',\r\n  '0x1': 'eip2930',\r\n  '0x2': 'eip1559',\r\n  '0x3': 'eip4844',\r\n  '0x4': 'eip7702',\r\n} as const satisfies Record<Hex, TransactionType>\r\n\r\nexport type FormatTransactionErrorType = ErrorType\r\n\r\nexport function formatTransaction(transaction: ExactPartial<RpcTransaction>) {\r\n  const transaction_ = {\r\n    ...transaction,\r\n    blockHash: transaction.blockHash ? transaction.blockHash : null,\r\n    blockNumber: transaction.blockNumber\r\n      ? BigInt(transaction.blockNumber)\r\n      : null,\r\n    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,\r\n    gas: transaction.gas ? BigInt(transaction.gas) : undefined,\r\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,\r\n    maxFeePerBlobGas: transaction.maxFeePerBlobGas\r\n      ? BigInt(transaction.maxFeePerBlobGas)\r\n      : undefined,\r\n    maxFeePerGas: transaction.maxFeePerGas\r\n      ? BigInt(transaction.maxFeePerGas)\r\n      : undefined,\r\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\r\n      ? BigInt(transaction.maxPriorityFeePerGas)\r\n      : undefined,\r\n    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,\r\n    to: transaction.to ? transaction.to : null,\r\n    transactionIndex: transaction.transactionIndex\r\n      ? Number(transaction.transactionIndex)\r\n      : null,\r\n    type: transaction.type\r\n      ? (transactionType as any)[transaction.type]\r\n      : undefined,\r\n    typeHex: transaction.type ? transaction.type : undefined,\r\n    value: transaction.value ? BigInt(transaction.value) : undefined,\r\n    v: transaction.v ? BigInt(transaction.v) : undefined,\r\n  } as Transaction\r\n\r\n  if (transaction.authorizationList)\r\n    transaction_.authorizationList = formatAuthorizationList(\r\n      transaction.authorizationList,\r\n    )\r\n\r\n  transaction_.yParity = (() => {\r\n    // If `yParity` is provided, we will use it.\r\n    if (transaction.yParity) return Number(transaction.yParity)\r\n\r\n    // If no `yParity` provided, try derive from `v`.\r\n    if (typeof transaction_.v === 'bigint') {\r\n      if (transaction_.v === 0n || transaction_.v === 27n) return 0\r\n      if (transaction_.v === 1n || transaction_.v === 28n) return 1\r\n      if (transaction_.v >= 35n) return transaction_.v % 2n === 0n ? 1 : 0\r\n    }\r\n\r\n    return undefined\r\n  })()\r\n\r\n  if (transaction_.type === 'legacy') {\r\n    delete transaction_.accessList\r\n    delete transaction_.maxFeePerBlobGas\r\n    delete transaction_.maxFeePerGas\r\n    delete transaction_.maxPriorityFeePerGas\r\n    delete transaction_.yParity\r\n  }\r\n  if (transaction_.type === 'eip2930') {\r\n    delete transaction_.maxFeePerBlobGas\r\n    delete transaction_.maxFeePerGas\r\n    delete transaction_.maxPriorityFeePerGas\r\n  }\r\n  if (transaction_.type === 'eip1559') {\r\n    delete transaction_.maxFeePerBlobGas\r\n  }\r\n  return transaction_\r\n}\r\n\r\nexport type DefineTransactionErrorType = DefineFormatterErrorType | ErrorType\r\n\r\nexport const defineTransaction = /*#__PURE__*/ defineFormatter(\r\n  'transaction',\r\n  formatTransaction,\r\n)\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction formatAuthorizationList(\r\n  authorizationList: RpcAuthorizationList,\r\n): SignedAuthorizationList {\r\n  return authorizationList.map(\r\n    (authorization) =>\r\n      ({\r\n        contractAddress: (authorization as any).address,\r\n        r: authorization.r,\r\n        s: authorization.s,\r\n        chainId: Number(authorization.chainId),\r\n        nonce: Number(authorization.nonce),\r\n        ...(typeof authorization.yParity !== 'undefined'\r\n          ? { yParity: Number(authorization.yParity) }\r\n          : {}),\r\n        ...(typeof authorization.v !== 'undefined' &&\r\n        typeof authorization.yParity === 'undefined'\r\n          ? { v: Number(authorization.v) }\r\n          : {}),\r\n      }) as any,\r\n  ) as SignedAuthorizationList\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { Block, BlockTag } from '../../types/block.js'\r\nimport type { Chain } from '../../types/chain.js'\r\nimport type {\r\n  ExtractChainFormatterExclude,\r\n  ExtractChainFormatterReturnType,\r\n} from '../../types/chain.js'\r\nimport type { Hash } from '../../types/misc.js'\r\nimport type { RpcBlock } from '../../types/rpc.js'\r\nimport type { ExactPartial, Prettify } from '../../types/utils.js'\r\n\r\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\r\nimport { type FormattedTransaction, formatTransaction } from './transaction.js'\r\n\r\ntype BlockPendingDependencies = 'hash' | 'logsBloom' | 'nonce' | 'number'\r\n\r\nexport type FormattedBlock<\r\n  chain extends Chain | undefined = undefined,\r\n  includeTransactions extends boolean = boolean,\r\n  blockTag extends BlockTag = BlockTag,\r\n  _FormatterReturnType = ExtractChainFormatterReturnType<\r\n    chain,\r\n    'block',\r\n    Block<bigint, includeTransactions>\r\n  >,\r\n  _ExcludedPendingDependencies extends string = BlockPendingDependencies &\r\n    ExtractChainFormatterExclude<chain, 'block'>,\r\n  _Formatted = Omit<_FormatterReturnType, BlockPendingDependencies> & {\r\n    [_key in _ExcludedPendingDependencies]: never\r\n  } & Pick<\r\n      Block<bigint, includeTransactions, blockTag>,\r\n      BlockPendingDependencies\r\n    >,\r\n  _Transactions = includeTransactions extends true\r\n    ? Prettify<FormattedTransaction<chain, blockTag>>[]\r\n    : Hash[],\r\n> = Omit<_Formatted, 'transactions'> & {\r\n  transactions: _Transactions\r\n}\r\n\r\nexport type FormatBlockErrorType = ErrorType\r\n\r\nexport function formatBlock(block: ExactPartial<RpcBlock>) {\r\n  const transactions = block.transactions?.map((transaction) => {\r\n    if (typeof transaction === 'string') return transaction\r\n    return formatTransaction(transaction)\r\n  })\r\n  return {\r\n    ...block,\r\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\r\n    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\r\n    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\r\n    excessBlobGas: block.excessBlobGas\r\n      ? BigInt(block.excessBlobGas)\r\n      : undefined,\r\n    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,\r\n    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,\r\n    hash: block.hash ? block.hash : null,\r\n    logsBloom: block.logsBloom ? block.logsBloom : null,\r\n    nonce: block.nonce ? block.nonce : null,\r\n    number: block.number ? BigInt(block.number) : null,\r\n    size: block.size ? BigInt(block.size) : undefined,\r\n    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\r\n    transactions,\r\n    totalDifficulty: block.totalDifficulty\r\n      ? BigInt(block.totalDifficulty)\r\n      : null,\r\n  } as Block\r\n}\r\n\r\nexport type DefineBlockErrorType = DefineFormatterErrorType | ErrorType\r\n\r\nexport const defineBlock = /*#__PURE__*/ defineFormatter('block', formatBlock)\r\n", "import type { Account } from '../accounts/types.js'\r\nimport type { EstimateGasParameters } from '../actions/public/estimateGas.js'\r\nimport type { Chain } from '../types/chain.js'\r\nimport { formatEther } from '../utils/unit/formatEther.js'\r\nimport { formatGwei } from '../utils/unit/formatGwei.js'\r\n\r\nimport { BaseError } from './base.js'\r\nimport { prettyPrint } from './transaction.js'\r\n\r\nexport type EstimateGasExecutionErrorType = EstimateGasExecutionError & {\r\n  name: 'EstimateGasExecutionError'\r\n}\r\nexport class EstimateGasExecutionError extends BaseError {\r\n  override cause: BaseError\r\n\r\n  constructor(\r\n    cause: BaseError,\r\n    {\r\n      account,\r\n      docsPath,\r\n      chain,\r\n      data,\r\n      gas,\r\n      gasPrice,\r\n      maxFeePerGas,\r\n      maxPriorityFeePerGas,\r\n      nonce,\r\n      to,\r\n      value,\r\n    }: Omit<EstimateGasParameters<any>, 'account'> & {\r\n      account?: Account | undefined\r\n      chain?: Chain | undefined\r\n      docsPath?: string | undefined\r\n    },\r\n  ) {\r\n    const prettyArgs = prettyPrint({\r\n      from: account?.address,\r\n      to,\r\n      value:\r\n        typeof value !== 'undefined' &&\r\n        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\r\n      data,\r\n      gas,\r\n      gasPrice:\r\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\r\n      maxFeePerGas:\r\n        typeof maxFeePerGas !== 'undefined' &&\r\n        `${formatGwei(maxFeePerGas)} gwei`,\r\n      maxPriorityFeePerGas:\r\n        typeof maxPriorityFeePerGas !== 'undefined' &&\r\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\r\n      nonce,\r\n    })\r\n\r\n    super(cause.shortMessage, {\r\n      cause,\r\n      docsPath,\r\n      metaMessages: [\r\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\r\n        'Estimate Gas Arguments:',\r\n        prettyArgs,\r\n      ].filter(Boolean) as string[],\r\n      name: 'EstimateGasExecutionError',\r\n    })\r\n    this.cause = cause\r\n  }\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { Kzg } from '../../types/kzg.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\r\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type BlobsToCommitmentsParameters<\r\n  blobs extends readonly ByteArray[] | readonly Hex[] =\r\n    | readonly ByteArray[]\r\n    | readonly Hex[],\r\n  to extends To | undefined = undefined,\r\n> = {\r\n  /** Blobs to transform into commitments. */\r\n  blobs: blobs | readonly ByteArray[] | readonly Hex[]\r\n  /** KZG implementation. */\r\n  kzg: Pick<Kzg, 'blobToKzgCommitment'>\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n}\r\n\r\nexport type BlobsToCommitmentsReturnType<to extends To> =\r\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\r\n  | (to extends 'hex' ? readonly Hex[] : never)\r\n\r\nexport type BlobsToCommitmentsErrorType =\r\n  | HexToBytesErrorType\r\n  | BytesToHexErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Compute commitments from a list of blobs.\r\n *\r\n * @example\r\n * ```ts\r\n * import { blobsToCommitments, toBlobs } from 'viem'\r\n * import { kzg } from './kzg'\r\n *\r\n * const blobs = toBlobs({ data: '0x1234' })\r\n * const commitments = blobsToCommitments({ blobs, kzg })\r\n * ```\r\n */\r\nexport function blobsToCommitments<\r\n  const blobs extends readonly ByteArray[] | readonly Hex[],\r\n  to extends To =\r\n    | (blobs extends readonly Hex[] ? 'hex' : never)\r\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\r\n>(\r\n  parameters: BlobsToCommitmentsParameters<blobs, to>,\r\n): BlobsToCommitmentsReturnType<to> {\r\n  const { kzg } = parameters\r\n\r\n  const to =\r\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\r\n  const blobs = (\r\n    typeof parameters.blobs[0] === 'string'\r\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\r\n      : parameters.blobs\r\n  ) as ByteArray[]\r\n\r\n  const commitments: ByteArray[] = []\r\n  for (const blob of blobs)\r\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\r\n\r\n  return (to === 'bytes'\r\n    ? commitments\r\n    : commitments.map((x) =>\r\n        bytesToHex(x),\r\n      )) as {} as BlobsToCommitmentsReturnType<to>\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { Kzg } from '../../types/kzg.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\r\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type blobsToProofsParameters<\r\n  blobs extends readonly ByteArray[] | readonly Hex[],\r\n  commitments extends readonly ByteArray[] | readonly Hex[],\r\n  to extends To =\r\n    | (blobs extends readonly Hex[] ? 'hex' : never)\r\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\r\n  ///\r\n  _blobsType =\r\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\r\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\r\n> = {\r\n  /** Blobs to transform into proofs. */\r\n  blobs: blobs\r\n  /** Commitments for the blobs. */\r\n  commitments: commitments &\r\n    (commitments extends _blobsType\r\n      ? {}\r\n      : `commitments must be the same type as blobs`)\r\n  /** KZG implementation. */\r\n  kzg: Pick<Kzg, 'computeBlobKzgProof'>\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n}\r\n\r\nexport type blobsToProofsReturnType<to extends To> =\r\n  | (to extends 'bytes' ? ByteArray[] : never)\r\n  | (to extends 'hex' ? Hex[] : never)\r\n\r\nexport type blobsToProofsErrorType =\r\n  | BytesToHexErrorType\r\n  | HexToBytesErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Compute the proofs for a list of blobs and their commitments.\r\n *\r\n * @example\r\n * ```ts\r\n * import {\r\n *   blobsToCommitments,\r\n *   toBlobs\r\n * } from 'viem'\r\n * import { kzg } from './kzg'\r\n *\r\n * const blobs = toBlobs({ data: '0x1234' })\r\n * const commitments = blobsToCommitments({ blobs, kzg })\r\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\r\n * ```\r\n */\r\nexport function blobsToProofs<\r\n  const blobs extends readonly ByteArray[] | readonly Hex[],\r\n  const commitments extends readonly ByteArray[] | readonly Hex[],\r\n  to extends To =\r\n    | (blobs extends readonly Hex[] ? 'hex' : never)\r\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\r\n>(\r\n  parameters: blobsToProofsParameters<blobs, commitments, to>,\r\n): blobsToProofsReturnType<to> {\r\n  const { kzg } = parameters\r\n\r\n  const to =\r\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\r\n\r\n  const blobs = (\r\n    typeof parameters.blobs[0] === 'string'\r\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\r\n      : parameters.blobs\r\n  ) as ByteArray[]\r\n  const commitments = (\r\n    typeof parameters.commitments[0] === 'string'\r\n      ? parameters.commitments.map((x) => hexToBytes(x as any))\r\n      : parameters.commitments\r\n  ) as ByteArray[]\r\n\r\n  const proofs: ByteArray[] = []\r\n  for (let i = 0; i < blobs.length; i++) {\r\n    const blob = blobs[i]\r\n    const commitment = commitments[i]\r\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\r\n  }\r\n\r\n  return (to === 'bytes'\r\n    ? proofs\r\n    : proofs.map((x) => bytesToHex(x))) as {} as blobsToProofsReturnType<to>\r\n}\r\n", "import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\r\n\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\r\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\r\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type Sha256Hash<to extends To> =\r\n  | (to extends 'bytes' ? ByteArray : never)\r\n  | (to extends 'hex' ? Hex : never)\r\n\r\nexport type Sha256ErrorType =\r\n  | IsHexErrorType\r\n  | ToBytesErrorType\r\n  | ToHexErrorType\r\n  | ErrorType\r\n\r\nexport function sha256<to extends To = 'hex'>(\r\n  value: Hex | ByteArray,\r\n  to_?: to | undefined,\r\n): Sha256Hash<to> {\r\n  const to = to_ || 'hex'\r\n  const bytes = noble_sha256(\r\n    isHex(value, { strict: false }) ? toBytes(value) : value,\r\n  )\r\n  if (to === 'bytes') return bytes as Sha256Hash<to>\r\n  return toHex(bytes) as Sha256Hash<to>\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\r\nimport { type Sha256ErrorType, sha256 } from '../hash/sha256.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type CommitmentToVersionedHashParameters<\r\n  commitment extends Uint8Array | Hex = Uint8Array | Hex,\r\n  to extends To | undefined = undefined,\r\n> = {\r\n  /** Commitment from blob. */\r\n  commitment: commitment | Uint8Array | Hex\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n  /** Version to tag onto the hash. */\r\n  version?: number | undefined\r\n}\r\n\r\nexport type CommitmentToVersionedHashReturnType<to extends To> =\r\n  | (to extends 'bytes' ? ByteArray : never)\r\n  | (to extends 'hex' ? Hex : never)\r\n\r\nexport type CommitmentToVersionedHashErrorType =\r\n  | Sha256ErrorType\r\n  | BytesToHexErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Transform a commitment to it's versioned hash.\r\n *\r\n * @example\r\n * ```ts\r\n * import {\r\n *   blobsToCommitments,\r\n *   commitmentToVersionedHash,\r\n *   toBlobs\r\n * } from 'viem'\r\n * import { kzg } from './kzg'\r\n *\r\n * const blobs = toBlobs({ data: '0x1234' })\r\n * const [commitment] = blobsToCommitments({ blobs, kzg })\r\n * const versionedHash = commitmentToVersionedHash({ commitment })\r\n * ```\r\n */\r\nexport function commitmentToVersionedHash<\r\n  const commitment extends Hex | ByteArray,\r\n  to extends To =\r\n    | (commitment extends Hex ? 'hex' : never)\r\n    | (commitment extends ByteArray ? 'bytes' : never),\r\n>(\r\n  parameters: CommitmentToVersionedHashParameters<commitment, to>,\r\n): CommitmentToVersionedHashReturnType<to> {\r\n  const { commitment, version = 1 } = parameters\r\n  const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes')\r\n\r\n  const versionedHash = sha256(commitment, 'bytes')\r\n  versionedHash.set([version], 0)\r\n  return (\r\n    to === 'bytes' ? versionedHash : bytesToHex(versionedHash)\r\n  ) as CommitmentToVersionedHashReturnType<to>\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport {\r\n  type CommitmentToVersionedHashErrorType,\r\n  commitmentToVersionedHash,\r\n} from './commitmentToVersionedHash.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type CommitmentsToVersionedHashesParameters<\r\n  commitments extends readonly Uint8Array[] | readonly Hex[] =\r\n    | readonly Uint8Array[]\r\n    | readonly Hex[],\r\n  to extends To | undefined = undefined,\r\n> = {\r\n  /** Commitments from blobs. */\r\n  commitments: commitments | readonly Uint8Array[] | readonly Hex[]\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n  /** Version to tag onto the hashes. */\r\n  version?: number | undefined\r\n}\r\n\r\nexport type CommitmentsToVersionedHashesReturnType<to extends To> =\r\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\r\n  | (to extends 'hex' ? readonly Hex[] : never)\r\n\r\nexport type CommitmentsToVersionedHashesErrorType =\r\n  | CommitmentToVersionedHashErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Transform a list of commitments to their versioned hashes.\r\n *\r\n * @example\r\n * ```ts\r\n * import {\r\n *   blobsToCommitments,\r\n *   commitmentsToVersionedHashes,\r\n *   toBlobs\r\n * } from 'viem'\r\n * import { kzg } from './kzg'\r\n *\r\n * const blobs = toBlobs({ data: '0x1234' })\r\n * const commitments = blobsToCommitments({ blobs, kzg })\r\n * const versionedHashes = commitmentsToVersionedHashes({ commitments })\r\n * ```\r\n */\r\nexport function commitmentsToVersionedHashes<\r\n  const commitments extends readonly Uint8Array[] | readonly Hex[],\r\n  to extends To =\r\n    | (commitments extends readonly Hex[] ? 'hex' : never)\r\n    | (commitments extends readonly ByteArray[] ? 'bytes' : never),\r\n>(\r\n  parameters: CommitmentsToVersionedHashesParameters<commitments, to>,\r\n): CommitmentsToVersionedHashesReturnType<to> {\r\n  const { commitments, version } = parameters\r\n\r\n  const to =\r\n    parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes')\r\n\r\n  const hashes: Uint8Array[] | Hex[] = []\r\n  for (const commitment of commitments) {\r\n    hashes.push(\r\n      commitmentToVersionedHash({\r\n        commitment,\r\n        to,\r\n        version,\r\n      }) as any,\r\n    )\r\n  }\r\n  return hashes as any\r\n}\r\n", "// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\r\n\r\n/** Blob limit per transaction. */\r\nconst blobsPerTransaction = 6\r\n\r\n/** The number of bytes in a BLS scalar field element. */\r\nexport const bytesPerFieldElement = 32\r\n\r\n/** The number of field elements in a blob. */\r\nexport const fieldElementsPerBlob = 4096\r\n\r\n/** The number of bytes in a blob. */\r\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\r\n\r\n/** Blob bytes limit per transaction. */\r\nexport const maxBytesPerTransaction =\r\n  bytesPerBlob * blobsPerTransaction -\r\n  // terminator byte (0x80).\r\n  1 -\r\n  // zero byte (0x00) appended to each field element.\r\n  1 * fieldElementsPerBlob * blobsPerTransaction\r\n", "// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\r\n\r\nexport const versionedHashVersionKzg = 1\r\n", "import { versionedHashVersionKzg } from '../constants/kzg.js'\r\nimport type { Hash } from '../types/misc.js'\r\n\r\nimport { BaseError } from './base.js'\r\n\r\nexport type BlobSizeTooLargeErrorType = BlobSizeTooLargeError & {\r\n  name: 'BlobSizeTooLargeError'\r\n}\r\nexport class BlobSizeTooLargeError extends BaseError {\r\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\r\n    super('Blob size is too large.', {\r\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\r\n      name: 'BlobSizeTooLargeError',\r\n    })\r\n  }\r\n}\r\n\r\nexport type EmptyBlobErrorType = EmptyBlobError & {\r\n  name: 'EmptyBlobError'\r\n}\r\nexport class EmptyBlobError extends BaseError {\r\n  constructor() {\r\n    super('Blob data must not be empty.', { name: 'EmptyBlobError' })\r\n  }\r\n}\r\n\r\nexport type InvalidVersionedHashSizeErrorType =\r\n  InvalidVersionedHashSizeError & {\r\n    name: 'InvalidVersionedHashSizeError'\r\n  }\r\nexport class InvalidVersionedHashSizeError extends BaseError {\r\n  constructor({\r\n    hash,\r\n    size,\r\n  }: {\r\n    hash: Hash\r\n    size: number\r\n  }) {\r\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\r\n      metaMessages: ['Expected: 32', `Received: ${size}`],\r\n      name: 'InvalidVersionedHashSizeError',\r\n    })\r\n  }\r\n}\r\n\r\nexport type InvalidVersionedHashVersionErrorType =\r\n  InvalidVersionedHashVersionError & {\r\n    name: 'InvalidVersionedHashVersionError'\r\n  }\r\nexport class InvalidVersionedHashVersionError extends BaseError {\r\n  constructor({\r\n    hash,\r\n    version,\r\n  }: {\r\n    hash: Hash\r\n    version: number\r\n  }) {\r\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\r\n      metaMessages: [\r\n        `Expected: ${versionedHashVersionKzg}`,\r\n        `Received: ${version}`,\r\n      ],\r\n      name: 'InvalidVersionedHashVersionError',\r\n    })\r\n  }\r\n}\r\n", "import {\r\n  bytesPerBlob,\r\n  bytesPerFieldElement,\r\n  fieldElementsPerBlob,\r\n  maxBytesPerTransaction,\r\n} from '../../constants/blob.js'\r\nimport {\r\n  BlobSizeTooLargeError,\r\n  type BlobSizeTooLargeErrorType,\r\n  EmptyBlobError,\r\n  type EmptyBlobErrorType,\r\n} from '../../errors/blob.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport { type CreateCursorErrorType, createCursor } from '../cursor.js'\r\nimport { type SizeErrorType, size } from '../data/size.js'\r\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\r\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type ToBlobsParameters<\r\n  data extends Hex | ByteArray = Hex | ByteArray,\r\n  to extends To | undefined = undefined,\r\n> = {\r\n  /** Data to transform to a blob. */\r\n  data: data | Hex | ByteArray\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n}\r\n\r\nexport type ToBlobsReturnType<to extends To> =\r\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\r\n  | (to extends 'hex' ? readonly Hex[] : never)\r\n\r\nexport type ToBlobsErrorType =\r\n  | BlobSizeTooLargeErrorType\r\n  | BytesToHexErrorType\r\n  | CreateCursorErrorType\r\n  | EmptyBlobErrorType\r\n  | HexToBytesErrorType\r\n  | SizeErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Transforms arbitrary data to blobs.\r\n *\r\n * @example\r\n * ```ts\r\n * import { toBlobs, stringToHex } from 'viem'\r\n *\r\n * const blobs = toBlobs({ data: stringToHex('hello world') })\r\n * ```\r\n */\r\nexport function toBlobs<\r\n  const data extends Hex | ByteArray,\r\n  to extends To =\r\n    | (data extends Hex ? 'hex' : never)\r\n    | (data extends ByteArray ? 'bytes' : never),\r\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\r\n  const to =\r\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\r\n  const data = (\r\n    typeof parameters.data === 'string'\r\n      ? hexToBytes(parameters.data)\r\n      : parameters.data\r\n  ) as ByteArray\r\n\r\n  const size_ = size(data)\r\n  if (!size_) throw new EmptyBlobError()\r\n  if (size_ > maxBytesPerTransaction)\r\n    throw new BlobSizeTooLargeError({\r\n      maxSize: maxBytesPerTransaction,\r\n      size: size_,\r\n    })\r\n\r\n  const blobs = []\r\n\r\n  let active = true\r\n  let position = 0\r\n  while (active) {\r\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\r\n\r\n    let size = 0\r\n    while (size < fieldElementsPerBlob) {\r\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\r\n\r\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\r\n      blob.pushByte(0x00)\r\n\r\n      // Push the current segment of data bytes.\r\n      blob.pushBytes(bytes)\r\n\r\n      // If we detect that the current segment of data bytes is less than 31 bytes,\r\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\r\n      if (bytes.length < 31) {\r\n        blob.pushByte(0x80)\r\n        active = false\r\n        break\r\n      }\r\n\r\n      size++\r\n      position += 31\r\n    }\r\n\r\n    blobs.push(blob)\r\n  }\r\n\r\n  return (\r\n    to === 'bytes'\r\n      ? blobs.map((x) => x.bytes)\r\n      : blobs.map((x) => bytesToHex(x.bytes))\r\n  ) as any\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { BlobSidecars } from '../../types/eip4844.js'\r\nimport type { Kzg } from '../../types/kzg.js'\r\nimport type { ByteArray, Hex } from '../../types/misc.js'\r\nimport type { OneOf } from '../../types/utils.js'\r\nimport {\r\n  type BlobsToCommitmentsErrorType,\r\n  blobsToCommitments,\r\n} from './blobsToCommitments.js'\r\nimport { blobsToProofs, type blobsToProofsErrorType } from './blobsToProofs.js'\r\nimport { type ToBlobsErrorType, toBlobs } from './toBlobs.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type ToBlobSidecarsParameters<\r\n  data extends Hex | ByteArray | undefined = undefined,\r\n  blobs extends readonly Hex[] | readonly ByteArray[] | undefined = undefined,\r\n  to extends To =\r\n    | (blobs extends readonly Hex[] ? 'hex' : never)\r\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\r\n  ///\r\n  _blobsType =\r\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\r\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\r\n> = {\r\n  /** Return type. */\r\n  to?: to | To | undefined\r\n} & OneOf<\r\n  | {\r\n      /** Data to transform into blobs. */\r\n      data: data | Hex | ByteArray\r\n      /** KZG implementation. */\r\n      kzg: Kzg\r\n    }\r\n  | {\r\n      /** Blobs. */\r\n      blobs: blobs | readonly Hex[] | readonly ByteArray[]\r\n      /** Commitment for each blob. */\r\n      commitments: _blobsType | readonly Hex[] | readonly ByteArray[]\r\n      /** Proof for each blob. */\r\n      proofs: _blobsType | readonly Hex[] | readonly ByteArray[]\r\n    }\r\n>\r\n\r\nexport type ToBlobSidecarsReturnType<to extends To> =\r\n  | (to extends 'bytes' ? BlobSidecars<ByteArray> : never)\r\n  | (to extends 'hex' ? BlobSidecars<Hex> : never)\r\n\r\nexport type ToBlobSidecarsErrorType =\r\n  | BlobsToCommitmentsErrorType\r\n  | ToBlobsErrorType\r\n  | blobsToProofsErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.\r\n *\r\n * @example\r\n * ```ts\r\n * import { toBlobSidecars, stringToHex } from 'viem'\r\n *\r\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\r\n * ```\r\n *\r\n * @example\r\n * ```ts\r\n * import {\r\n *   blobsToCommitments,\r\n *   toBlobs,\r\n *   blobsToProofs,\r\n *   toBlobSidecars,\r\n *   stringToHex\r\n * } from 'viem'\r\n *\r\n * const blobs = toBlobs({ data: stringToHex('hello world') })\r\n * const commitments = blobsToCommitments({ blobs, kzg })\r\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\r\n *\r\n * const sidecars = toBlobSidecars({ blobs, commitments, proofs })\r\n * ```\r\n */\r\nexport function toBlobSidecars<\r\n  const data extends Hex | ByteArray | undefined = undefined,\r\n  const blobs extends\r\n    | readonly Hex[]\r\n    | readonly ByteArray[]\r\n    | undefined = undefined,\r\n  to extends To =\r\n    | (data extends Hex ? 'hex' : never)\r\n    | (data extends ByteArray ? 'bytes' : never)\r\n    | (blobs extends readonly Hex[] ? 'hex' : never)\r\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\r\n>(\r\n  parameters: ToBlobSidecarsParameters<data, blobs, to>,\r\n): ToBlobSidecarsReturnType<to> {\r\n  const { data, kzg, to } = parameters\r\n  const blobs = parameters.blobs ?? toBlobs({ data: data!, to })\r\n  const commitments =\r\n    parameters.commitments ?? blobsToCommitments({ blobs, kzg: kzg!, to })\r\n  const proofs =\r\n    parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg: kzg!, to })\r\n\r\n  const sidecars: BlobSidecars = []\r\n  for (let i = 0; i < blobs.length; i++)\r\n    sidecars.push({\r\n      blob: blobs[i],\r\n      commitment: commitments[i],\r\n      proof: proofs[i],\r\n    })\r\n\r\n  return sidecars as ToBlobSidecarsReturnType<to>\r\n}\r\n", "import {\r\n  InvalidSerializableTransactionError,\r\n  type InvalidSerializableTransactionErrorType,\r\n} from '../../errors/transaction.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type {\r\n  FeeValuesEIP1559,\r\n  FeeValuesEIP4844,\r\n  FeeValuesLegacy,\r\n} from '../../index.js'\r\nimport type {\r\n  TransactionRequestEIP1559,\r\n  TransactionRequestEIP2930,\r\n  TransactionRequestEIP4844,\r\n  TransactionRequestEIP7702,\r\n  TransactionRequestGeneric,\r\n  TransactionRequestLegacy,\r\n  TransactionSerializableEIP1559,\r\n  TransactionSerializableEIP2930,\r\n  TransactionSerializableEIP4844,\r\n  TransactionSerializableEIP7702,\r\n  TransactionSerializableGeneric,\r\n  TransactionSerializableLegacy,\r\n} from '../../types/transaction.js'\r\nimport type {\r\n  Assign,\r\n  ExactPartial,\r\n  IsNever,\r\n  OneOf,\r\n  ValueOf,\r\n} from '../../types/utils.js'\r\n\r\nexport type GetTransactionType<\r\n  transaction extends OneOf<\r\n    TransactionSerializableGeneric | TransactionRequestGeneric\r\n  > = TransactionSerializableGeneric,\r\n  result =\r\n    | (transaction extends\r\n        | MatchKeys<TransactionSerializableLegacy, transaction>\r\n        | MatchKeys<TransactionRequestLegacy, transaction>\r\n        | LegacyProperties\r\n        ? 'legacy'\r\n        : never)\r\n    | (transaction extends\r\n        | MatchKeys<TransactionSerializableEIP1559, transaction>\r\n        | MatchKeys<TransactionRequestEIP1559, transaction>\r\n        | EIP1559Properties\r\n        ? 'eip1559'\r\n        : never)\r\n    | (transaction extends\r\n        | MatchKeys<TransactionSerializableEIP2930, transaction>\r\n        | MatchKeys<TransactionRequestEIP2930, transaction>\r\n        | EIP2930Properties\r\n        ? 'eip2930'\r\n        : never)\r\n    | (transaction extends\r\n        | MatchKeys<TransactionSerializableEIP4844, transaction>\r\n        | MatchKeys<TransactionRequestEIP4844, transaction>\r\n        | EIP4844Properties\r\n        ? 'eip4844'\r\n        : never)\r\n    | (transaction extends\r\n        | MatchKeys<TransactionSerializableEIP7702, transaction>\r\n        | MatchKeys<TransactionRequestEIP7702, transaction>\r\n        | EIP7702Properties\r\n        ? 'eip7702'\r\n        : never)\r\n    | (transaction['type'] extends TransactionSerializableGeneric['type']\r\n        ? Extract<transaction['type'], string>\r\n        : never),\r\n> = IsNever<keyof transaction> extends true\r\n  ? string\r\n  : IsNever<result> extends false\r\n    ? result\r\n    : string\r\n\r\nexport type GetTransactionTypeErrorType =\r\n  | InvalidSerializableTransactionErrorType\r\n  | ErrorType\r\n\r\nexport function getTransactionType<\r\n  const transaction extends OneOf<\r\n    TransactionSerializableGeneric | TransactionRequestGeneric\r\n  >,\r\n>(transaction: transaction): GetTransactionType<transaction> {\r\n  if (transaction.type)\r\n    return transaction.type as GetTransactionType<transaction>\r\n\r\n  if (typeof transaction.authorizationList !== 'undefined')\r\n    return 'eip7702' as any\r\n\r\n  if (\r\n    typeof transaction.blobs !== 'undefined' ||\r\n    typeof transaction.blobVersionedHashes !== 'undefined' ||\r\n    typeof transaction.maxFeePerBlobGas !== 'undefined' ||\r\n    typeof transaction.sidecars !== 'undefined'\r\n  )\r\n    return 'eip4844' as any\r\n\r\n  if (\r\n    typeof transaction.maxFeePerGas !== 'undefined' ||\r\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\r\n  ) {\r\n    return 'eip1559' as any\r\n  }\r\n\r\n  if (typeof transaction.gasPrice !== 'undefined') {\r\n    if (typeof transaction.accessList !== 'undefined') return 'eip2930' as any\r\n    return 'legacy' as any\r\n  }\r\n\r\n  throw new InvalidSerializableTransactionError({ transaction })\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n// Types\r\n\r\ntype MatchKeys<T extends object, U extends object> = ValueOf<\r\n  Required<{\r\n    [K in keyof U]: K extends keyof T ? K : undefined\r\n  }>\r\n> extends string\r\n  ? T\r\n  : never\r\n\r\ntype BaseProperties = {\r\n  accessList?: undefined\r\n  authorizationList?: undefined\r\n  blobs?: undefined\r\n  blobVersionedHashes?: undefined\r\n  gasPrice?: undefined\r\n  maxFeePerBlobGas?: undefined\r\n  maxFeePerGas?: undefined\r\n  maxPriorityFeePerGas?: undefined\r\n  sidecars?: undefined\r\n}\r\n\r\ntype LegacyProperties = Assign<BaseProperties, FeeValuesLegacy>\r\ntype EIP1559Properties = Assign<\r\n  BaseProperties,\r\n  OneOf<\r\n    | {\r\n        maxFeePerGas: FeeValuesEIP1559['maxFeePerGas']\r\n      }\r\n    | {\r\n        maxPriorityFeePerGas: FeeValuesEIP1559['maxPriorityFeePerGas']\r\n      },\r\n    FeeValuesEIP1559\r\n  > & {\r\n    accessList?: TransactionSerializableEIP2930['accessList'] | undefined\r\n  }\r\n>\r\ntype EIP2930Properties = Assign<\r\n  BaseProperties,\r\n  ExactPartial<FeeValuesLegacy> & {\r\n    accessList: TransactionSerializableEIP2930['accessList']\r\n  }\r\n>\r\ntype EIP4844Properties = Assign<\r\n  BaseProperties,\r\n  ExactPartial<FeeValuesEIP4844> &\r\n    OneOf<\r\n      | {\r\n          blobs: TransactionSerializableEIP4844['blobs']\r\n        }\r\n      | {\r\n          blobVersionedHashes: TransactionSerializableEIP4844['blobVersionedHashes']\r\n        }\r\n      | {\r\n          sidecars: TransactionSerializableEIP4844['sidecars']\r\n        },\r\n      TransactionSerializableEIP4844\r\n    >\r\n>\r\ntype EIP7702Properties = Assign<\r\n  BaseProperties,\r\n  ExactPartial<FeeValuesEIP1559> & {\r\n    authorizationList: TransactionSerializableEIP7702['authorizationList']\r\n  }\r\n>\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type { Log } from '../../types/log.js'\r\nimport type { RpcLog } from '../../types/rpc.js'\r\nimport type { ExactPartial } from '../../types/utils.js'\r\n\r\nexport type FormatLogErrorType = ErrorType\r\n\r\nexport function formatLog(\r\n  log: ExactPartial<RpcLog>,\r\n  {\r\n    args,\r\n    eventName,\r\n  }: { args?: unknown | undefined; eventName?: string | undefined } = {},\r\n) {\r\n  return {\r\n    ...log,\r\n    blockHash: log.blockHash ? log.blockHash : null,\r\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\r\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\r\n    transactionHash: log.transactionHash ? log.transactionHash : null,\r\n    transactionIndex: log.transactionIndex\r\n      ? Number(log.transactionIndex)\r\n      : null,\r\n    ...(eventName ? { args, eventName } : {}),\r\n  } as Log\r\n}\r\n", "import type { ErrorType } from '../../errors/utils.js'\r\nimport type {\r\n  Chain,\r\n  ExtractChainFormatterReturnType,\r\n} from '../../types/chain.js'\r\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\r\nimport type { TransactionReceipt } from '../../types/transaction.js'\r\nimport type { ExactPartial } from '../../types/utils.js'\r\nimport { hexToNumber } from '../encoding/fromHex.js'\r\n\r\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\r\nimport { formatLog } from './log.js'\r\nimport { transactionType } from './transaction.js'\r\n\r\nexport type FormattedTransactionReceipt<\r\n  chain extends Chain | undefined = undefined,\r\n> = ExtractChainFormatterReturnType<\r\n  chain,\r\n  'transactionReceipt',\r\n  TransactionReceipt\r\n>\r\n\r\nexport const receiptStatuses = {\r\n  '0x0': 'reverted',\r\n  '0x1': 'success',\r\n} as const\r\n\r\nexport type FormatTransactionReceiptErrorType = ErrorType\r\n\r\nexport function formatTransactionReceipt(\r\n  transactionReceipt: ExactPartial<RpcTransactionReceipt>,\r\n) {\r\n  const receipt = {\r\n    ...transactionReceipt,\r\n    blockNumber: transactionReceipt.blockNumber\r\n      ? BigInt(transactionReceipt.blockNumber)\r\n      : null,\r\n    contractAddress: transactionReceipt.contractAddress\r\n      ? transactionReceipt.contractAddress\r\n      : null,\r\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\r\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\r\n      : null,\r\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\r\n      ? BigInt(transactionReceipt.effectiveGasPrice)\r\n      : null,\r\n    gasUsed: transactionReceipt.gasUsed\r\n      ? BigInt(transactionReceipt.gasUsed)\r\n      : null,\r\n    logs: transactionReceipt.logs\r\n      ? transactionReceipt.logs.map((log) => formatLog(log))\r\n      : null,\r\n    to: transactionReceipt.to ? transactionReceipt.to : null,\r\n    transactionIndex: transactionReceipt.transactionIndex\r\n      ? hexToNumber(transactionReceipt.transactionIndex)\r\n      : null,\r\n    status: transactionReceipt.status\r\n      ? receiptStatuses[transactionReceipt.status]\r\n      : null,\r\n    type: transactionReceipt.type\r\n      ? transactionType[\r\n          transactionReceipt.type as keyof typeof transactionType\r\n        ] || transactionReceipt.type\r\n      : null,\r\n  } as TransactionReceipt\r\n\r\n  if (transactionReceipt.blobGasPrice)\r\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice)\r\n  if (transactionReceipt.blobGasUsed)\r\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed)\r\n\r\n  return receipt\r\n}\r\n\r\nexport type DefineTransactionReceiptErrorType =\r\n  | DefineFormatterErrorType\r\n  | ErrorType\r\n\r\nexport const defineTransactionReceipt = /*#__PURE__*/ defineFormatter(\r\n  'transactionReceipt',\r\n  formatTransactionReceipt,\r\n)\r\n", "import type { Chain, ChainFormatters } from '../../types/chain.js'\r\nimport type { Assign, Prettify } from '../../types/utils.js'\r\n\r\nexport function defineChain<\r\n  formatters extends ChainFormatters,\r\n  const chain extends Chain<formatters>,\r\n>(chain: chain): Prettify<Assign<Chain<undefined>, chain>> {\r\n  return {\r\n    formatters: undefined,\r\n    fees: undefined,\r\n    serializers: undefined,\r\n    ...chain,\r\n  } as Assign<Chain<undefined>, chain>\r\n}\r\n", "import { versionedHashVersionKzg } from '../../constants/kzg.js'\r\nimport { maxUint256 } from '../../constants/number.js'\r\nimport {\r\n  InvalidAddressError,\r\n  type InvalidAddressErrorType,\r\n} from '../../errors/address.js'\r\nimport { BaseError, type BaseErrorType } from '../../errors/base.js'\r\nimport {\r\n  EmptyBlobError,\r\n  type EmptyBlobErrorType,\r\n  InvalidVersionedHashSizeError,\r\n  type InvalidVersionedHashSizeErrorType,\r\n  InvalidVersionedHashVersionError,\r\n  type InvalidVersionedHashVersionErrorType,\r\n} from '../../errors/blob.js'\r\nimport {\r\n  InvalidChainIdError,\r\n  type InvalidChainIdErrorType,\r\n} from '../../errors/chain.js'\r\nimport {\r\n  FeeCapTooHighError,\r\n  type FeeCapTooHighErrorType,\r\n  TipAboveFeeCapError,\r\n  type TipAboveFeeCapErrorType,\r\n} from '../../errors/node.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type {\r\n  TransactionSerializableEIP1559,\r\n  TransactionSerializableEIP2930,\r\n  TransactionSerializableEIP4844,\r\n  TransactionSerializableEIP7702,\r\n  TransactionSerializableLegacy,\r\n} from '../../types/transaction.js'\r\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\r\nimport { size } from '../data/size.js'\r\nimport { slice } from '../data/slice.js'\r\nimport { hexToNumber } from '../encoding/fromHex.js'\r\n\r\nexport type AssertTransactionEIP7702ErrorType =\r\n  | AssertTransactionEIP1559ErrorType\r\n  | InvalidAddressErrorType\r\n  | InvalidChainIdErrorType\r\n  | ErrorType\r\n\r\nexport function assertTransactionEIP7702(\r\n  transaction: TransactionSerializableEIP7702,\r\n) {\r\n  const { authorizationList } = transaction\r\n  if (authorizationList) {\r\n    for (const authorization of authorizationList) {\r\n      const { contractAddress, chainId } = authorization\r\n      if (!isAddress(contractAddress))\r\n        throw new InvalidAddressError({ address: contractAddress })\r\n      if (chainId <= 0) throw new InvalidChainIdError({ chainId })\r\n    }\r\n  }\r\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\r\n}\r\n\r\nexport type AssertTransactionEIP4844ErrorType =\r\n  | AssertTransactionEIP1559ErrorType\r\n  | EmptyBlobErrorType\r\n  | InvalidVersionedHashSizeErrorType\r\n  | InvalidVersionedHashVersionErrorType\r\n  | ErrorType\r\n\r\nexport function assertTransactionEIP4844(\r\n  transaction: TransactionSerializableEIP4844,\r\n) {\r\n  const { blobVersionedHashes } = transaction\r\n  if (blobVersionedHashes) {\r\n    if (blobVersionedHashes.length === 0) throw new EmptyBlobError()\r\n    for (const hash of blobVersionedHashes) {\r\n      const size_ = size(hash)\r\n      const version = hexToNumber(slice(hash, 0, 1))\r\n      if (size_ !== 32)\r\n        throw new InvalidVersionedHashSizeError({ hash, size: size_ })\r\n      if (version !== versionedHashVersionKzg)\r\n        throw new InvalidVersionedHashVersionError({\r\n          hash,\r\n          version,\r\n        })\r\n    }\r\n  }\r\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\r\n}\r\n\r\nexport type AssertTransactionEIP1559ErrorType =\r\n  | BaseErrorType\r\n  | IsAddressErrorType\r\n  | InvalidAddressErrorType\r\n  | InvalidChainIdErrorType\r\n  | FeeCapTooHighErrorType\r\n  | TipAboveFeeCapErrorType\r\n  | ErrorType\r\n\r\nexport function assertTransactionEIP1559(\r\n  transaction: TransactionSerializableEIP1559,\r\n) {\r\n  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction\r\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\r\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\r\n  if (maxFeePerGas && maxFeePerGas > maxUint256)\r\n    throw new FeeCapTooHighError({ maxFeePerGas })\r\n  if (\r\n    maxPriorityFeePerGas &&\r\n    maxFeePerGas &&\r\n    maxPriorityFeePerGas > maxFeePerGas\r\n  )\r\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\r\n}\r\n\r\nexport type AssertTransactionEIP2930ErrorType =\r\n  | BaseErrorType\r\n  | IsAddressErrorType\r\n  | InvalidAddressErrorType\r\n  | InvalidChainIdErrorType\r\n  | FeeCapTooHighErrorType\r\n  | ErrorType\r\n\r\nexport function assertTransactionEIP2930(\r\n  transaction: TransactionSerializableEIP2930,\r\n) {\r\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\r\n    transaction\r\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\r\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\r\n  if (maxPriorityFeePerGas || maxFeePerGas)\r\n    throw new BaseError(\r\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.',\r\n    )\r\n  if (gasPrice && gasPrice > maxUint256)\r\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\r\n}\r\n\r\nexport type AssertTransactionLegacyErrorType =\r\n  | BaseErrorType\r\n  | IsAddressErrorType\r\n  | InvalidAddressErrorType\r\n  | InvalidChainIdErrorType\r\n  | FeeCapTooHighErrorType\r\n  | ErrorType\r\n\r\nexport function assertTransactionLegacy(\r\n  transaction: TransactionSerializableLegacy,\r\n) {\r\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\r\n    transaction\r\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\r\n  if (typeof chainId !== 'undefined' && chainId <= 0)\r\n    throw new InvalidChainIdError({ chainId })\r\n  if (maxPriorityFeePerGas || maxFeePerGas)\r\n    throw new BaseError(\r\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.',\r\n    )\r\n  if (gasPrice && gasPrice > maxUint256)\r\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\r\n}\r\n", "import {\r\n  InvalidAddressError,\r\n  type InvalidAddressErrorType,\r\n} from '../../errors/address.js'\r\nimport {\r\n  InvalidStorageKeySizeError,\r\n  type InvalidStorageKeySizeErrorType,\r\n} from '../../errors/transaction.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { Hex } from '../../types/misc.js'\r\nimport type { AccessList } from '../../types/transaction.js'\r\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\r\nimport type { RecursiveArray } from '../encoding/toRlp.js'\r\n\r\nexport type SerializeAccessListErrorType =\r\n  | InvalidStorageKeySizeErrorType\r\n  | InvalidAddressErrorType\r\n  | IsAddressErrorType\r\n  | ErrorType\r\n\r\n/*\r\n * Serialize an  EIP-2930 access list\r\n * @remarks\r\n * Use to create a transaction serializer with support for EIP-2930 access lists\r\n *\r\n * @param accessList - Array of objects of address and arrays of Storage Keys\r\n * @throws InvalidAddressError, InvalidStorageKeySizeError\r\n * @returns Array of hex strings\r\n */\r\nexport function serializeAccessList(\r\n  accessList?: AccessList | undefined,\r\n): RecursiveArray<Hex> {\r\n  if (!accessList || accessList.length === 0) return []\r\n\r\n  const serializedAccessList = []\r\n  for (let i = 0; i < accessList.length; i++) {\r\n    const { address, storageKeys } = accessList[i]\r\n\r\n    for (let j = 0; j < storageKeys.length; j++) {\r\n      if (storageKeys[j].length - 2 !== 64) {\r\n        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] })\r\n      }\r\n    }\r\n\r\n    if (!isAddress(address, { strict: false })) {\r\n      throw new InvalidAddressError({ address })\r\n    }\r\n\r\n    serializedAccessList.push([address, storageKeys])\r\n  }\r\n  return serializedAccessList\r\n}\r\n", "import type { ErrorType } from '../../../errors/utils.js'\r\nimport { toHex } from '../../../utils/encoding/toHex.js'\r\nimport { toYParitySignatureArray } from '../../../utils/transaction/serializeTransaction.js'\r\nimport type {\r\n  AuthorizationList,\r\n  SerializedAuthorizationList,\r\n} from '../types/authorization.js'\r\n\r\nexport type SerializeAuthorizationListReturnType = SerializedAuthorizationList\r\n\r\nexport type SerializeAuthorizationListErrorType = ErrorType\r\n\r\n/*\r\n * Serializes an EIP-7702 authorization list.\r\n */\r\nexport function serializeAuthorizationList(\r\n  authorizationList?: AuthorizationList<number, true> | undefined,\r\n): SerializeAuthorizationListReturnType {\r\n  if (!authorizationList || authorizationList.length === 0) return []\r\n\r\n  const serializedAuthorizationList = []\r\n  for (const authorization of authorizationList) {\r\n    const { contractAddress, chainId, nonce, ...signature } = authorization\r\n    serializedAuthorizationList.push([\r\n      toHex(chainId),\r\n      contractAddress,\r\n      nonce ? toHex(nonce) : '0x',\r\n      ...toYParitySignatureArray({}, signature),\r\n    ])\r\n  }\r\n\r\n  return serializedAuthorizationList as {} as SerializeAuthorizationListReturnType\r\n}\r\n", "import {\r\n  InvalidLegacyVError,\r\n  type InvalidLegacyVErrorType,\r\n} from '../../errors/transaction.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type {\r\n  ByteArray,\r\n  Hex,\r\n  Signature,\r\n  SignatureLegacy,\r\n} from '../../types/misc.js'\r\nimport type {\r\n  TransactionSerializable,\r\n  TransactionSerializableEIP1559,\r\n  TransactionSerializableEIP2930,\r\n  TransactionSerializableEIP4844,\r\n  TransactionSerializableEIP7702,\r\n  TransactionSerializableGeneric,\r\n  TransactionSerializableLegacy,\r\n  TransactionSerialized,\r\n  TransactionSerializedEIP1559,\r\n  TransactionSerializedEIP2930,\r\n  TransactionSerializedEIP4844,\r\n  TransactionSerializedEIP7702,\r\n  TransactionSerializedLegacy,\r\n  TransactionType,\r\n} from '../../types/transaction.js'\r\nimport type { OneOf } from '../../types/utils.js'\r\nimport {\r\n  type BlobsToCommitmentsErrorType,\r\n  blobsToCommitments,\r\n} from '../blob/blobsToCommitments.js'\r\nimport {\r\n  blobsToProofs,\r\n  type blobsToProofsErrorType,\r\n} from '../blob/blobsToProofs.js'\r\nimport {\r\n  type CommitmentsToVersionedHashesErrorType,\r\n  commitmentsToVersionedHashes,\r\n} from '../blob/commitmentsToVersionedHashes.js'\r\nimport {\r\n  type ToBlobSidecarsErrorType,\r\n  toBlobSidecars,\r\n} from '../blob/toBlobSidecars.js'\r\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\r\nimport { trim } from '../data/trim.js'\r\nimport { type ToHexErrorType, bytesToHex, toHex } from '../encoding/toHex.js'\r\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\r\n\r\nimport {\r\n  type SerializeAuthorizationListErrorType,\r\n  serializeAuthorizationList,\r\n} from '../../experimental/eip7702/utils/serializeAuthorizationList.js'\r\nimport {\r\n  type AssertTransactionEIP1559ErrorType,\r\n  type AssertTransactionEIP2930ErrorType,\r\n  type AssertTransactionEIP4844ErrorType,\r\n  type AssertTransactionEIP7702ErrorType,\r\n  type AssertTransactionLegacyErrorType,\r\n  assertTransactionEIP1559,\r\n  assertTransactionEIP2930,\r\n  assertTransactionEIP4844,\r\n  assertTransactionEIP7702,\r\n  assertTransactionLegacy,\r\n} from './assertTransaction.js'\r\nimport {\r\n  type GetTransactionType,\r\n  type GetTransactionTypeErrorType,\r\n  getTransactionType,\r\n} from './getTransactionType.js'\r\nimport {\r\n  type SerializeAccessListErrorType,\r\n  serializeAccessList,\r\n} from './serializeAccessList.js'\r\n\r\nexport type SerializedTransactionReturnType<\r\n  transaction extends TransactionSerializable = TransactionSerializable,\r\n  ///\r\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\r\n> = TransactionSerialized<_transactionType>\r\n\r\nexport type SerializeTransactionFn<\r\n  transaction extends TransactionSerializableGeneric = TransactionSerializable,\r\n  ///\r\n  _transactionType extends TransactionType = never,\r\n> = typeof serializeTransaction<\r\n  OneOf<TransactionSerializable | transaction>,\r\n  _transactionType\r\n>\r\n\r\nexport type SerializeTransactionErrorType =\r\n  | GetTransactionTypeErrorType\r\n  | SerializeTransactionEIP1559ErrorType\r\n  | SerializeTransactionEIP2930ErrorType\r\n  | SerializeTransactionEIP4844ErrorType\r\n  | SerializeTransactionEIP7702ErrorType\r\n  | SerializeTransactionLegacyErrorType\r\n  | ErrorType\r\n\r\nexport function serializeTransaction<\r\n  const transaction extends TransactionSerializable,\r\n  ///\r\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\r\n>(\r\n  transaction: transaction,\r\n  signature?: Signature | undefined,\r\n): SerializedTransactionReturnType<transaction, _transactionType> {\r\n  const type = getTransactionType(transaction) as GetTransactionType\r\n\r\n  if (type === 'eip1559')\r\n    return serializeTransactionEIP1559(\r\n      transaction as TransactionSerializableEIP1559,\r\n      signature,\r\n    ) as SerializedTransactionReturnType<transaction>\r\n\r\n  if (type === 'eip2930')\r\n    return serializeTransactionEIP2930(\r\n      transaction as TransactionSerializableEIP2930,\r\n      signature,\r\n    ) as SerializedTransactionReturnType<transaction>\r\n\r\n  if (type === 'eip4844')\r\n    return serializeTransactionEIP4844(\r\n      transaction as TransactionSerializableEIP4844,\r\n      signature,\r\n    ) as SerializedTransactionReturnType<transaction>\r\n\r\n  if (type === 'eip7702')\r\n    return serializeTransactionEIP7702(\r\n      transaction as TransactionSerializableEIP7702,\r\n      signature,\r\n    ) as SerializedTransactionReturnType<transaction>\r\n\r\n  return serializeTransactionLegacy(\r\n    transaction as TransactionSerializableLegacy,\r\n    signature as SignatureLegacy,\r\n  ) as SerializedTransactionReturnType<transaction>\r\n}\r\n\r\ntype SerializeTransactionEIP7702ErrorType =\r\n  | AssertTransactionEIP7702ErrorType\r\n  | SerializeAuthorizationListErrorType\r\n  | ConcatHexErrorType\r\n  | InvalidLegacyVErrorType\r\n  | ToHexErrorType\r\n  | ToRlpErrorType\r\n  | SerializeAccessListErrorType\r\n  | ErrorType\r\n\r\nfunction serializeTransactionEIP7702(\r\n  transaction: TransactionSerializableEIP7702,\r\n  signature?: Signature | undefined,\r\n): TransactionSerializedEIP7702 {\r\n  const {\r\n    authorizationList,\r\n    chainId,\r\n    gas,\r\n    nonce,\r\n    to,\r\n    value,\r\n    maxFeePerGas,\r\n    maxPriorityFeePerGas,\r\n    accessList,\r\n    data,\r\n  } = transaction\r\n\r\n  assertTransactionEIP7702(transaction)\r\n\r\n  const serializedAccessList = serializeAccessList(accessList)\r\n  const serializedAuthorizationList =\r\n    serializeAuthorizationList(authorizationList)\r\n\r\n  return concatHex([\r\n    '0x04',\r\n    toRlp([\r\n      toHex(chainId),\r\n      nonce ? toHex(nonce) : '0x',\r\n      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\r\n      maxFeePerGas ? toHex(maxFeePerGas) : '0x',\r\n      gas ? toHex(gas) : '0x',\r\n      to ?? '0x',\r\n      value ? toHex(value) : '0x',\r\n      data ?? '0x',\r\n      serializedAccessList,\r\n      serializedAuthorizationList,\r\n      ...toYParitySignatureArray(transaction, signature),\r\n    ]),\r\n  ]) as TransactionSerializedEIP7702\r\n}\r\n\r\ntype SerializeTransactionEIP4844ErrorType =\r\n  | AssertTransactionEIP4844ErrorType\r\n  | BlobsToCommitmentsErrorType\r\n  | CommitmentsToVersionedHashesErrorType\r\n  | blobsToProofsErrorType\r\n  | ToBlobSidecarsErrorType\r\n  | ConcatHexErrorType\r\n  | InvalidLegacyVErrorType\r\n  | ToHexErrorType\r\n  | ToRlpErrorType\r\n  | SerializeAccessListErrorType\r\n  | ErrorType\r\n\r\nfunction serializeTransactionEIP4844(\r\n  transaction: TransactionSerializableEIP4844,\r\n  signature?: Signature | undefined,\r\n): TransactionSerializedEIP4844 {\r\n  const {\r\n    chainId,\r\n    gas,\r\n    nonce,\r\n    to,\r\n    value,\r\n    maxFeePerBlobGas,\r\n    maxFeePerGas,\r\n    maxPriorityFeePerGas,\r\n    accessList,\r\n    data,\r\n  } = transaction\r\n\r\n  assertTransactionEIP4844(transaction)\r\n\r\n  let blobVersionedHashes = transaction.blobVersionedHashes\r\n  let sidecars = transaction.sidecars\r\n  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.\r\n  if (\r\n    transaction.blobs &&\r\n    (typeof blobVersionedHashes === 'undefined' ||\r\n      typeof sidecars === 'undefined')\r\n  ) {\r\n    const blobs = (\r\n      typeof transaction.blobs[0] === 'string'\r\n        ? transaction.blobs\r\n        : (transaction.blobs as ByteArray[]).map((x) => bytesToHex(x))\r\n    ) as Hex[]\r\n    const kzg = transaction.kzg!\r\n    const commitments = blobsToCommitments({\r\n      blobs,\r\n      kzg,\r\n    })\r\n\r\n    if (typeof blobVersionedHashes === 'undefined')\r\n      blobVersionedHashes = commitmentsToVersionedHashes({\r\n        commitments,\r\n      })\r\n    if (typeof sidecars === 'undefined') {\r\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\r\n      sidecars = toBlobSidecars({ blobs, commitments, proofs })\r\n    }\r\n  }\r\n\r\n  const serializedAccessList = serializeAccessList(accessList)\r\n\r\n  const serializedTransaction = [\r\n    toHex(chainId),\r\n    nonce ? toHex(nonce) : '0x',\r\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\r\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\r\n    gas ? toHex(gas) : '0x',\r\n    to ?? '0x',\r\n    value ? toHex(value) : '0x',\r\n    data ?? '0x',\r\n    serializedAccessList,\r\n    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x',\r\n    blobVersionedHashes ?? [],\r\n    ...toYParitySignatureArray(transaction, signature),\r\n  ] as const\r\n\r\n  const blobs: Hex[] = []\r\n  const commitments: Hex[] = []\r\n  const proofs: Hex[] = []\r\n  if (sidecars)\r\n    for (let i = 0; i < sidecars.length; i++) {\r\n      const { blob, commitment, proof } = sidecars[i]\r\n      blobs.push(blob)\r\n      commitments.push(commitment)\r\n      proofs.push(proof)\r\n    }\r\n\r\n  return concatHex([\r\n    '0x03',\r\n    sidecars\r\n      ? // If sidecars are enabled, envelope turns into a \"wrapper\":\r\n        toRlp([serializedTransaction, blobs, commitments, proofs])\r\n      : // If sidecars are disabled, standard envelope is used:\r\n        toRlp(serializedTransaction),\r\n  ]) as TransactionSerializedEIP4844\r\n}\r\n\r\ntype SerializeTransactionEIP1559ErrorType =\r\n  | AssertTransactionEIP1559ErrorType\r\n  | ConcatHexErrorType\r\n  | InvalidLegacyVErrorType\r\n  | ToHexErrorType\r\n  | ToRlpErrorType\r\n  | SerializeAccessListErrorType\r\n  | ErrorType\r\n\r\nfunction serializeTransactionEIP1559(\r\n  transaction: TransactionSerializableEIP1559,\r\n  signature?: Signature | undefined,\r\n): TransactionSerializedEIP1559 {\r\n  const {\r\n    chainId,\r\n    gas,\r\n    nonce,\r\n    to,\r\n    value,\r\n    maxFeePerGas,\r\n    maxPriorityFeePerGas,\r\n    accessList,\r\n    data,\r\n  } = transaction\r\n\r\n  assertTransactionEIP1559(transaction)\r\n\r\n  const serializedAccessList = serializeAccessList(accessList)\r\n\r\n  const serializedTransaction = [\r\n    toHex(chainId),\r\n    nonce ? toHex(nonce) : '0x',\r\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\r\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\r\n    gas ? toHex(gas) : '0x',\r\n    to ?? '0x',\r\n    value ? toHex(value) : '0x',\r\n    data ?? '0x',\r\n    serializedAccessList,\r\n    ...toYParitySignatureArray(transaction, signature),\r\n  ]\r\n\r\n  return concatHex([\r\n    '0x02',\r\n    toRlp(serializedTransaction),\r\n  ]) as TransactionSerializedEIP1559\r\n}\r\n\r\ntype SerializeTransactionEIP2930ErrorType =\r\n  | AssertTransactionEIP2930ErrorType\r\n  | ConcatHexErrorType\r\n  | InvalidLegacyVErrorType\r\n  | ToHexErrorType\r\n  | ToRlpErrorType\r\n  | SerializeAccessListErrorType\r\n  | ErrorType\r\n\r\nfunction serializeTransactionEIP2930(\r\n  transaction: TransactionSerializableEIP2930,\r\n  signature?: Signature | undefined,\r\n): TransactionSerializedEIP2930 {\r\n  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } =\r\n    transaction\r\n\r\n  assertTransactionEIP2930(transaction)\r\n\r\n  const serializedAccessList = serializeAccessList(accessList)\r\n\r\n  const serializedTransaction = [\r\n    toHex(chainId),\r\n    nonce ? toHex(nonce) : '0x',\r\n    gasPrice ? toHex(gasPrice) : '0x',\r\n    gas ? toHex(gas) : '0x',\r\n    to ?? '0x',\r\n    value ? toHex(value) : '0x',\r\n    data ?? '0x',\r\n    serializedAccessList,\r\n    ...toYParitySignatureArray(transaction, signature),\r\n  ]\r\n\r\n  return concatHex([\r\n    '0x01',\r\n    toRlp(serializedTransaction),\r\n  ]) as TransactionSerializedEIP2930\r\n}\r\n\r\ntype SerializeTransactionLegacyErrorType =\r\n  | AssertTransactionLegacyErrorType\r\n  | InvalidLegacyVErrorType\r\n  | ToHexErrorType\r\n  | ToRlpErrorType\r\n  | ErrorType\r\n\r\nfunction serializeTransactionLegacy(\r\n  transaction: TransactionSerializableLegacy,\r\n  signature?: SignatureLegacy | undefined,\r\n): TransactionSerializedLegacy {\r\n  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction\r\n\r\n  assertTransactionLegacy(transaction)\r\n\r\n  let serializedTransaction = [\r\n    nonce ? toHex(nonce) : '0x',\r\n    gasPrice ? toHex(gasPrice) : '0x',\r\n    gas ? toHex(gas) : '0x',\r\n    to ?? '0x',\r\n    value ? toHex(value) : '0x',\r\n    data ?? '0x',\r\n  ]\r\n\r\n  if (signature) {\r\n    const v = (() => {\r\n      // EIP-155 (inferred chainId)\r\n      if (signature.v >= 35n) {\r\n        const inferredChainId = (signature.v - 35n) / 2n\r\n        if (inferredChainId > 0) return signature.v\r\n        return 27n + (signature.v === 35n ? 0n : 1n)\r\n      }\r\n\r\n      // EIP-155 (explicit chainId)\r\n      if (chainId > 0)\r\n        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n)\r\n\r\n      // Pre-EIP-155 (no chainId)\r\n      const v = 27n + (signature.v === 27n ? 0n : 1n)\r\n      if (signature.v !== v) throw new InvalidLegacyVError({ v: signature.v })\r\n      return v\r\n    })()\r\n\r\n    const r = trim(signature.r)\r\n    const s = trim(signature.s)\r\n\r\n    serializedTransaction = [\r\n      ...serializedTransaction,\r\n      toHex(v),\r\n      r === '0x00' ? '0x' : r,\r\n      s === '0x00' ? '0x' : s,\r\n    ]\r\n  } else if (chainId > 0) {\r\n    serializedTransaction = [\r\n      ...serializedTransaction,\r\n      toHex(chainId),\r\n      '0x',\r\n      '0x',\r\n    ]\r\n  }\r\n\r\n  return toRlp(serializedTransaction) as TransactionSerializedLegacy\r\n}\r\n\r\nexport function toYParitySignatureArray(\r\n  transaction: TransactionSerializableGeneric,\r\n  signature_?: Signature | undefined,\r\n) {\r\n  const signature = signature_ ?? transaction\r\n  const { v, yParity } = signature\r\n\r\n  if (typeof signature.r === 'undefined') return []\r\n  if (typeof signature.s === 'undefined') return []\r\n  if (typeof v === 'undefined' && typeof yParity === 'undefined') return []\r\n\r\n  const r = trim(signature.r)\r\n  const s = trim(signature.s)\r\n\r\n  const yParity_ = (() => {\r\n    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x'\r\n    if (v === 0n) return '0x'\r\n    if (v === 1n) return toHex(1)\r\n\r\n    return v === 27n ? '0x' : toHex(1)\r\n  })()\r\n\r\n  return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s]\r\n}\r\n", "import type { Client } from '../clients/createClient.js'\r\nimport type { PublicActions } from '../clients/decorators/public.js'\r\nimport type { WalletActions } from '../clients/decorators/wallet.js'\r\nimport type { Transport } from '../clients/transports/createTransport.js'\r\nimport type { Account } from '../types/account.js'\r\nimport type { Chain } from '../types/chain.js'\r\nimport type { RpcSchema } from '../types/eip1193.js'\r\n\r\n/**\r\n * Retrieves and returns an action from the client (if exists), and falls\r\n * back to the tree-shakable action.\r\n *\r\n * Useful for extracting overridden actions from a client (ie. if a consumer\r\n * wants to override the `sendTransaction` implementation).\r\n */\r\nexport function getAction<\r\n  transport extends Transport,\r\n  chain extends Chain | undefined,\r\n  account extends Account | undefined,\r\n  rpcSchema extends RpcSchema | undefined,\r\n  extended extends { [key: string]: unknown },\r\n  client extends Client<transport, chain, account, rpcSchema, extended>,\r\n  parameters,\r\n  returnType,\r\n>(\r\n  client: client,\r\n  actionFn: (_: any, parameters: parameters) => returnType,\r\n  // Some minifiers drop `Function.prototype.name`, or replace it with short letters,\r\n  // meaning that `actionFn.name` will not always work. For that case, the consumer\r\n  // needs to pass the name explicitly.\r\n  name: keyof PublicActions | keyof WalletActions | (string & {}),\r\n): (parameters: parameters) => returnType {\r\n  const action_implicit = client[actionFn.name]\r\n  if (typeof action_implicit === 'function')\r\n    return action_implicit as (params: parameters) => returnType\r\n\r\n  const action_explicit = client[name]\r\n  if (typeof action_explicit === 'function')\r\n    return action_explicit as (params: parameters) => returnType\r\n\r\n  return (params) => actionFn(client, params)\r\n}\r\n", "import type { Account } from '../../accounts/types.js'\r\nimport type { Client } from '../../clients/createClient.js'\r\nimport type { Transport } from '../../clients/transports/createTransport.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { Chain } from '../../types/chain.js'\r\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\r\nimport {\r\n  type HexToNumberErrorType,\r\n  hexToNumber,\r\n} from '../../utils/encoding/fromHex.js'\r\n\r\nexport type GetChainIdReturnType = number\r\n\r\nexport type GetChainIdErrorType =\r\n  | HexToNumberErrorType\r\n  | RequestErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Returns the chain ID associated with the current network.\r\n *\r\n * - Docs: https://viem.sh/docs/actions/public/getChainId\r\n * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\r\n *\r\n * @param client - Client to use\r\n * @returns The current chain ID. {@link GetChainIdReturnType}\r\n *\r\n * @example\r\n * import { createPublicClient, http } from 'viem'\r\n * import { mainnet } from 'viem/chains'\r\n * import { getChainId } from 'viem/public'\r\n *\r\n * const client = createPublicClient({\r\n *   chain: mainnet,\r\n *   transport: http(),\r\n * })\r\n * const chainId = await getChainId(client)\r\n * // 1\r\n */\r\nexport async function getChainId<\r\n  chain extends Chain | undefined,\r\n  account extends Account | undefined,\r\n>(client: Client<Transport, chain, account>): Promise<GetChainIdReturnType> {\r\n  const chainIdHex = await client.request(\r\n    {\r\n      method: 'eth_chainId',\r\n    },\r\n    { dedupe: true },\r\n  )\r\n  return hexToNumber(chainIdHex)\r\n}\r\n", "import type { Account } from '../../accounts/types.js'\r\nimport type { Client } from '../../clients/createClient.js'\r\nimport type { Transport } from '../../clients/transports/createTransport.js'\r\nimport {\r\n  BlockNotFoundError,\r\n  type BlockNotFoundErrorType,\r\n} from '../../errors/block.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { BlockTag } from '../../types/block.js'\r\nimport type { Chain } from '../../types/chain.js'\r\nimport type { Hash } from '../../types/misc.js'\r\nimport type { RpcBlock } from '../../types/rpc.js'\r\nimport type { Prettify } from '../../types/utils.js'\r\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\r\nimport {\r\n  type NumberToHexErrorType,\r\n  numberToHex,\r\n} from '../../utils/encoding/toHex.js'\r\nimport {\r\n  type FormattedBlock,\r\n  formatBlock,\r\n} from '../../utils/formatters/block.js'\r\n\r\nexport type GetBlockParameters<\r\n  includeTransactions extends boolean = false,\r\n  blockTag extends BlockTag = 'latest',\r\n> = {\r\n  /** Whether or not to include transaction data in the response. */\r\n  includeTransactions?: includeTransactions | undefined\r\n} & (\r\n  | {\r\n      /** Hash of the block. */\r\n      blockHash?: Hash | undefined\r\n      blockNumber?: undefined\r\n      blockTag?: undefined\r\n    }\r\n  | {\r\n      blockHash?: undefined\r\n      /** The block number. */\r\n      blockNumber?: bigint | undefined\r\n      blockTag?: undefined\r\n    }\r\n  | {\r\n      blockHash?: undefined\r\n      blockNumber?: undefined\r\n      /**\r\n       * The block tag.\r\n       * @default 'latest'\r\n       */\r\n      blockTag?: blockTag | BlockTag | undefined\r\n    }\r\n)\r\n\r\nexport type GetBlockReturnType<\r\n  chain extends Chain | undefined = undefined,\r\n  includeTransactions extends boolean = false,\r\n  blockTag extends BlockTag = 'latest',\r\n> = Prettify<FormattedBlock<chain, includeTransactions, blockTag>>\r\n\r\nexport type GetBlockErrorType =\r\n  | BlockNotFoundErrorType\r\n  | NumberToHexErrorType\r\n  | RequestErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Returns information about a block at a block number, hash, or tag.\r\n *\r\n * - Docs: https://viem.sh/docs/actions/public/getBlock\r\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks/fetching-blocks\r\n * - JSON-RPC Methods:\r\n *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.\r\n *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.\r\n *\r\n * @param client - Client to use\r\n * @param parameters - {@link GetBlockParameters}\r\n * @returns Information about the block. {@link GetBlockReturnType}\r\n *\r\n * @example\r\n * import { createPublicClient, http } from 'viem'\r\n * import { mainnet } from 'viem/chains'\r\n * import { getBlock } from 'viem/public'\r\n *\r\n * const client = createPublicClient({\r\n *   chain: mainnet,\r\n *   transport: http(),\r\n * })\r\n * const block = await getBlock(client)\r\n */\r\nexport async function getBlock<\r\n  chain extends Chain | undefined,\r\n  account extends Account | undefined,\r\n  includeTransactions extends boolean = false,\r\n  blockTag extends BlockTag = 'latest',\r\n>(\r\n  client: Client<Transport, chain, account>,\r\n  {\r\n    blockHash,\r\n    blockNumber,\r\n    blockTag: blockTag_,\r\n    includeTransactions: includeTransactions_,\r\n  }: GetBlockParameters<includeTransactions, blockTag> = {},\r\n): Promise<GetBlockReturnType<chain, includeTransactions, blockTag>> {\r\n  const blockTag = blockTag_ ?? 'latest'\r\n  const includeTransactions = includeTransactions_ ?? false\r\n\r\n  const blockNumberHex =\r\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\r\n\r\n  let block: RpcBlock | null = null\r\n  if (blockHash) {\r\n    block = await client.request(\r\n      {\r\n        method: 'eth_getBlockByHash',\r\n        params: [blockHash, includeTransactions],\r\n      },\r\n      { dedupe: true },\r\n    )\r\n  } else {\r\n    block = await client.request(\r\n      {\r\n        method: 'eth_getBlockByNumber',\r\n        params: [blockNumberHex || blockTag, includeTransactions],\r\n      },\r\n      { dedupe: Boolean(blockNumberHex) },\r\n    )\r\n  }\r\n\r\n  if (!block) throw new BlockNotFoundError({ blockHash, blockNumber })\r\n\r\n  const format = client.chain?.formatters?.block?.format || formatBlock\r\n  return format(block)\r\n}\r\n", "import type { Account } from '../../accounts/types.js'\r\nimport type { Client } from '../../clients/createClient.js'\r\nimport type { Transport } from '../../clients/transports/createTransport.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { Chain } from '../../types/chain.js'\r\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\r\n\r\nexport type GetGasPriceReturnType = bigint\r\n\r\nexport type GetGasPriceErrorType = RequestErrorType | ErrorType\r\n\r\n/**\r\n * Returns the current price of gas (in wei).\r\n *\r\n * - Docs: https://viem.sh/docs/actions/public/getGasPrice\r\n * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)\r\n *\r\n * @param client - Client to use\r\n * @returns The gas price (in wei). {@link GetGasPriceReturnType}\r\n *\r\n * @example\r\n * import { createPublicClient, http } from 'viem'\r\n * import { mainnet } from 'viem/chains'\r\n * import { getGasPrice } from 'viem/public'\r\n *\r\n * const client = createPublicClient({\r\n *   chain: mainnet,\r\n *   transport: http(),\r\n * })\r\n * const gasPrice = await getGasPrice(client)\r\n */\r\nexport async function getGasPrice<\r\n  chain extends Chain | undefined,\r\n  account extends Account | undefined,\r\n>(client: Client<Transport, chain, account>): Promise<GetGasPriceReturnType> {\r\n  const gasPrice = await client.request({\r\n    method: 'eth_gasPrice',\r\n  })\r\n  return BigInt(gasPrice)\r\n}\r\n", "import type { Client } from '../../clients/createClient.js'\r\nimport type { Transport } from '../../clients/transports/createTransport.js'\r\nimport {\r\n  Eip1559FeesNotSupportedError,\r\n  type Eip1559FeesNotSupportedErrorType,\r\n} from '../../errors/fee.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { Account } from '../../types/account.js'\r\nimport type { Block } from '../../types/block.js'\r\nimport type { Chain, ChainFeesFnParameters } from '../../types/chain.js'\r\nimport type { GetChainParameter } from '../../types/chain.js'\r\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\r\nimport {\r\n  type HexToBigIntErrorType,\r\n  hexToBigInt,\r\n} from '../../utils/encoding/fromHex.js'\r\nimport { getAction } from '../../utils/getAction.js'\r\nimport type { PrepareTransactionRequestParameters } from '../wallet/prepareTransactionRequest.js'\r\nimport { type GetBlockErrorType, getBlock } from './getBlock.js'\r\nimport { type GetGasPriceErrorType, getGasPrice } from './getGasPrice.js'\r\n\r\nexport type EstimateMaxPriorityFeePerGasParameters<\r\n  chain extends Chain | undefined = Chain | undefined,\r\n  chainOverride extends Chain | undefined = Chain | undefined,\r\n> = GetChainParameter<chain, chainOverride>\r\n\r\nexport type EstimateMaxPriorityFeePerGasReturnType = bigint\r\n\r\nexport type EstimateMaxPriorityFeePerGasErrorType =\r\n  | GetBlockErrorType\r\n  | HexToBigIntErrorType\r\n  | RequestErrorType\r\n  | GetBlockErrorType\r\n  | GetGasPriceErrorType\r\n  | Eip1559FeesNotSupportedErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Returns an estimate for the max priority fee per gas (in wei) for a\r\n * transaction to be likely included in the next block.\r\n * Defaults to [`chain.fees.defaultPriorityFee`](/docs/clients/chains#fees-defaultpriorityfee) if set.\r\n *\r\n * - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas\r\n *\r\n * @param client - Client to use\r\n * @returns An estimate (in wei) for the max priority fee per gas. {@link EstimateMaxPriorityFeePerGasReturnType}\r\n *\r\n * @example\r\n * import { createPublicClient, http } from 'viem'\r\n * import { mainnet } from 'viem/chains'\r\n * import { estimateMaxPriorityFeePerGas } from 'viem/actions'\r\n *\r\n * const client = createPublicClient({\r\n *   chain: mainnet,\r\n *   transport: http(),\r\n * })\r\n * const maxPriorityFeePerGas = await estimateMaxPriorityFeePerGas(client)\r\n * // 10000000n\r\n */\r\nexport async function estimateMaxPriorityFeePerGas<\r\n  chain extends Chain | undefined,\r\n  chainOverride extends Chain | undefined,\r\n>(\r\n  client: Client<Transport, chain>,\r\n  args?:\r\n    | EstimateMaxPriorityFeePerGasParameters<chain, chainOverride>\r\n    | undefined,\r\n): Promise<EstimateMaxPriorityFeePerGasReturnType> {\r\n  return internal_estimateMaxPriorityFeePerGas(client, args as any)\r\n}\r\n\r\nexport async function internal_estimateMaxPriorityFeePerGas<\r\n  chain extends Chain | undefined,\r\n  chainOverride extends Chain | undefined,\r\n>(\r\n  client: Client<Transport, chain>,\r\n  args: EstimateMaxPriorityFeePerGasParameters<chain, chainOverride> & {\r\n    block?: Block | undefined\r\n    request?:\r\n      | PrepareTransactionRequestParameters<\r\n          chain,\r\n          Account | undefined,\r\n          chainOverride\r\n        >\r\n      | undefined\r\n  },\r\n): Promise<EstimateMaxPriorityFeePerGasReturnType> {\r\n  const { block: block_, chain = client.chain, request } = args || {}\r\n\r\n  try {\r\n    const maxPriorityFeePerGas =\r\n      chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee\r\n\r\n    if (typeof maxPriorityFeePerGas === 'function') {\r\n      const block =\r\n        block_ || (await getAction(client, getBlock, 'getBlock')({}))\r\n      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({\r\n        block,\r\n        client,\r\n        request,\r\n      } as ChainFeesFnParameters)\r\n      if (maxPriorityFeePerGas_ === null) throw new Error()\r\n      return maxPriorityFeePerGas_\r\n    }\r\n\r\n    if (typeof maxPriorityFeePerGas !== 'undefined') return maxPriorityFeePerGas\r\n\r\n    const maxPriorityFeePerGasHex = await client.request({\r\n      method: 'eth_maxPriorityFeePerGas',\r\n    })\r\n    return hexToBigInt(maxPriorityFeePerGasHex)\r\n  } catch {\r\n    // If the RPC Provider does not support `eth_maxPriorityFeePerGas`\r\n    // fall back to calculating it manually via `gasPrice - baseFeePerGas`.\r\n    // See: https://github.com/ethereum/pm/issues/328#:~:text=eth_maxPriorityFeePerGas%20after%20London%20will%20effectively%20return%20eth_gasPrice%20%2D%20baseFee\r\n    const [block, gasPrice] = await Promise.all([\r\n      block_\r\n        ? Promise.resolve(block_)\r\n        : getAction(client, getBlock, 'getBlock')({}),\r\n      getAction(client, getGasPrice, 'getGasPrice')({}),\r\n    ])\r\n\r\n    if (typeof block.baseFeePerGas !== 'bigint')\r\n      throw new Eip1559FeesNotSupportedError()\r\n\r\n    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas\r\n\r\n    if (maxPriorityFeePerGas < 0n) return 0n\r\n    return maxPriorityFeePerGas\r\n  }\r\n}\r\n", "import type { Client } from '../../clients/createClient.js'\r\nimport type { Transport } from '../../clients/transports/createTransport.js'\r\nimport {\r\n  BaseFeeScalarError,\r\n  type BaseFeeScalarErrorType,\r\n  Eip1559FeesNotSupportedError,\r\n  type Eip1559FeesNotSupportedErrorType,\r\n} from '../../errors/fee.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { Account } from '../../types/account.js'\r\nimport type { Block } from '../../types/block.js'\r\nimport type {\r\n  Chain,\r\n  ChainEstimateFeesPerGasFnParameters,\r\n  ChainFeesFnParameters,\r\n  GetChainParameter,\r\n} from '../../types/chain.js'\r\nimport type {\r\n  FeeValuesEIP1559,\r\n  FeeValuesLegacy,\r\n  FeeValuesType,\r\n} from '../../types/fee.js'\r\nimport { getAction } from '../../utils/getAction.js'\r\nimport type { PrepareTransactionRequestParameters } from '../wallet/prepareTransactionRequest.js'\r\nimport {\r\n  type EstimateMaxPriorityFeePerGasErrorType,\r\n  internal_estimateMaxPriorityFeePerGas,\r\n} from './estimateMaxPriorityFeePerGas.js'\r\nimport { getBlock } from './getBlock.js'\r\nimport { type GetGasPriceErrorType, getGasPrice } from './getGasPrice.js'\r\n\r\nexport type EstimateFeesPerGasParameters<\r\n  chain extends Chain | undefined = Chain | undefined,\r\n  chainOverride extends Chain | undefined = Chain | undefined,\r\n  type extends FeeValuesType = FeeValuesType,\r\n> = {\r\n  /**\r\n   * The type of fee values to return.\r\n   *\r\n   * - `legacy`: Returns the legacy gas price.\r\n   * - `eip1559`: Returns the max fee per gas and max priority fee per gas.\r\n   *\r\n   * @default 'eip1559'\r\n   */\r\n  type?: type | FeeValuesType | undefined\r\n} & GetChainParameter<chain, chainOverride>\r\n\r\nexport type EstimateFeesPerGasReturnType<\r\n  type extends FeeValuesType = FeeValuesType,\r\n> =\r\n  | (type extends 'legacy' ? FeeValuesLegacy : never)\r\n  | (type extends 'eip1559' ? FeeValuesEIP1559 : never)\r\n\r\nexport type EstimateFeesPerGasErrorType =\r\n  | BaseFeeScalarErrorType\r\n  | EstimateMaxPriorityFeePerGasErrorType\r\n  | GetGasPriceErrorType\r\n  | Eip1559FeesNotSupportedErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Returns an estimate for the fees per gas (in wei) for a\r\n * transaction to be likely included in the next block.\r\n * Defaults to [`chain.fees.estimateFeesPerGas`](/docs/clients/chains#fees-estimatefeespergas) if set.\r\n *\r\n * - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas\r\n *\r\n * @param client - Client to use\r\n * @param parameters - {@link EstimateFeesPerGasParameters}\r\n * @returns An estimate (in wei) for the fees per gas. {@link EstimateFeesPerGasReturnType}\r\n *\r\n * @example\r\n * import { createPublicClient, http } from 'viem'\r\n * import { mainnet } from 'viem/chains'\r\n * import { estimateFeesPerGas } from 'viem/actions'\r\n *\r\n * const client = createPublicClient({\r\n *   chain: mainnet,\r\n *   transport: http(),\r\n * })\r\n * const maxPriorityFeePerGas = await estimateFeesPerGas(client)\r\n * // { maxFeePerGas: ..., maxPriorityFeePerGas: ... }\r\n */\r\nexport async function estimateFeesPerGas<\r\n  chain extends Chain | undefined,\r\n  chainOverride extends Chain | undefined,\r\n  type extends FeeValuesType = 'eip1559',\r\n>(\r\n  client: Client<Transport, chain>,\r\n  args?: EstimateFeesPerGasParameters<chain, chainOverride, type> | undefined,\r\n): Promise<EstimateFeesPerGasReturnType<type>> {\r\n  return internal_estimateFeesPerGas(client, args as any)\r\n}\r\n\r\nexport async function internal_estimateFeesPerGas<\r\n  chain extends Chain | undefined,\r\n  chainOverride extends Chain | undefined,\r\n  type extends FeeValuesType = 'eip1559',\r\n>(\r\n  client: Client<Transport, chain>,\r\n  args: EstimateFeesPerGasParameters<chain, chainOverride, type> & {\r\n    block?: Block | undefined\r\n    request?: PrepareTransactionRequestParameters<Chain, Account> | undefined\r\n  },\r\n): Promise<EstimateFeesPerGasReturnType<type>> {\r\n  const {\r\n    block: block_,\r\n    chain = client.chain,\r\n    request,\r\n    type = 'eip1559',\r\n  } = args || {}\r\n\r\n  const baseFeeMultiplier = await (async () => {\r\n    if (typeof chain?.fees?.baseFeeMultiplier === 'function')\r\n      return chain.fees.baseFeeMultiplier({\r\n        block: block_ as Block,\r\n        client,\r\n        request,\r\n      } as ChainFeesFnParameters)\r\n    return chain?.fees?.baseFeeMultiplier ?? 1.2\r\n  })()\r\n  if (baseFeeMultiplier < 1) throw new BaseFeeScalarError()\r\n\r\n  const decimals = baseFeeMultiplier.toString().split('.')[1]?.length ?? 0\r\n  const denominator = 10 ** decimals\r\n  const multiply = (base: bigint) =>\r\n    (base * BigInt(Math.ceil(baseFeeMultiplier * denominator))) /\r\n    BigInt(denominator)\r\n\r\n  const block = block_\r\n    ? block_\r\n    : await getAction(client, getBlock, 'getBlock')({})\r\n\r\n  if (typeof chain?.fees?.estimateFeesPerGas === 'function') {\r\n    const fees = (await chain.fees.estimateFeesPerGas({\r\n      block: block_ as Block,\r\n      client,\r\n      multiply,\r\n      request,\r\n      type,\r\n    } as ChainEstimateFeesPerGasFnParameters)) as unknown as EstimateFeesPerGasReturnType<type>\r\n\r\n    if (fees !== null) return fees\r\n  }\r\n\r\n  if (type === 'eip1559') {\r\n    if (typeof block.baseFeePerGas !== 'bigint')\r\n      throw new Eip1559FeesNotSupportedError()\r\n\r\n    const maxPriorityFeePerGas =\r\n      typeof request?.maxPriorityFeePerGas === 'bigint'\r\n        ? request.maxPriorityFeePerGas\r\n        : await internal_estimateMaxPriorityFeePerGas(\r\n            client as Client<Transport, Chain>,\r\n            {\r\n              block: block as Block,\r\n              chain,\r\n              request,\r\n            },\r\n          )\r\n\r\n    const baseFeePerGas = multiply(block.baseFeePerGas)\r\n    const maxFeePerGas =\r\n      request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas\r\n\r\n    return {\r\n      maxFeePerGas,\r\n      maxPriorityFeePerGas,\r\n    } as EstimateFeesPerGasReturnType<type>\r\n  }\r\n\r\n  const gasPrice =\r\n    request?.gasPrice ??\r\n    multiply(await getAction(client, getGasPrice, 'getGasPrice')({}))\r\n  return {\r\n    gasPrice,\r\n  } as EstimateFeesPerGasReturnType<type>\r\n}\r\n", "import type { Address } from 'abitype'\r\n\r\nimport type { Client } from '../../clients/createClient.js'\r\nimport type { Transport } from '../../clients/transports/createTransport.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { BlockTag } from '../../types/block.js'\r\nimport type { Chain } from '../../types/chain.js'\r\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\r\nimport {\r\n  type NumberToHexErrorType,\r\n  numberToHex,\r\n} from '../../utils/encoding/toHex.js'\r\n\r\nexport type GetBalanceParameters = {\r\n  /** The address of the account. */\r\n  address: Address\r\n} & (\r\n  | {\r\n      /** The balance of the account at a block number. */\r\n      blockNumber?: bigint | undefined\r\n      blockTag?: undefined\r\n    }\r\n  | {\r\n      blockNumber?: undefined\r\n      /** The balance of the account at a block tag. */\r\n      blockTag?: BlockTag | undefined\r\n    }\r\n)\r\n\r\nexport type GetBalanceReturnType = bigint\r\n\r\nexport type GetBalanceErrorType =\r\n  | NumberToHexErrorType\r\n  | RequestErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Returns the balance of an address in wei.\r\n *\r\n * - Docs: https://viem.sh/docs/actions/public/getBalance\r\n * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)\r\n *\r\n * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther).\r\n *\r\n * ```ts\r\n * const balance = await getBalance(client, {\r\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\r\n *   blockTag: 'safe'\r\n * })\r\n * const balanceAsEther = formatEther(balance)\r\n * // \"6.942\"\r\n * ```\r\n *\r\n * @param client - Client to use\r\n * @param parameters - {@link GetBalanceParameters}\r\n * @returns The balance of the address in wei. {@link GetBalanceReturnType}\r\n *\r\n * @example\r\n * import { createPublicClient, http } from 'viem'\r\n * import { mainnet } from 'viem/chains'\r\n * import { getBalance } from 'viem/public'\r\n *\r\n * const client = createPublicClient({\r\n *   chain: mainnet,\r\n *   transport: http(),\r\n * })\r\n * const balance = await getBalance(client, {\r\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\r\n * })\r\n * // 10000000000000000000000n (wei)\r\n */\r\nexport async function getBalance<chain extends Chain | undefined>(\r\n  client: Client<Transport, chain>,\r\n  { address, blockNumber, blockTag = 'latest' }: GetBalanceParameters,\r\n): Promise<GetBalanceReturnType> {\r\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\r\n\r\n  const balance = await client.request({\r\n    method: 'eth_getBalance',\r\n    params: [address, blockNumberHex || blockTag],\r\n  })\r\n  return BigInt(balance)\r\n}\r\n", "import type { ErrorType } from '../../../errors/utils.js'\r\nimport type { ByteArray, Hex } from '../../../types/misc.js'\r\nimport {\r\n  type ConcatHexErrorType,\r\n  concatHex,\r\n} from '../../../utils/data/concat.js'\r\nimport {\r\n  type HexToBytesErrorType,\r\n  hexToBytes,\r\n} from '../../../utils/encoding/toBytes.js'\r\nimport {\r\n  type NumberToHexErrorType,\r\n  numberToHex,\r\n} from '../../../utils/encoding/toHex.js'\r\nimport { type ToRlpErrorType, toRlp } from '../../../utils/encoding/toRlp.js'\r\nimport {\r\n  type Keccak256ErrorType,\r\n  keccak256,\r\n} from '../../../utils/hash/keccak256.js'\r\nimport type { Authorization } from '../types/authorization.js'\r\n\r\ntype To = 'hex' | 'bytes'\r\n\r\nexport type HashAuthorizationParameters<to extends To> = Authorization & {\r\n  /** Output format. @default \"hex\" */\r\n  to?: to | To | undefined\r\n}\r\n\r\nexport type HashAuthorizationReturnType<to extends To> =\r\n  | (to extends 'bytes' ? ByteArray : never)\r\n  | (to extends 'hex' ? Hex : never)\r\n\r\nexport type HashAuthorizationErrorType =\r\n  | Keccak256ErrorType\r\n  | ConcatHexErrorType\r\n  | ToRlpErrorType\r\n  | NumberToHexErrorType\r\n  | HexToBytesErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Computes an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\r\n */\r\nexport function hashAuthorization<to extends To = 'hex'>(\r\n  parameters: HashAuthorizationParameters<to>,\r\n): HashAuthorizationReturnType<to> {\r\n  const { chainId, contractAddress, nonce, to } = parameters\r\n  const hash = keccak256(\r\n    concatHex([\r\n      '0x05',\r\n      toRlp([\r\n        numberToHex(chainId),\r\n        contractAddress,\r\n        nonce ? numberToHex(nonce) : '0x',\r\n      ]),\r\n    ]),\r\n  )\r\n  if (to === 'bytes') return hexToBytes(hash) as HashAuthorizationReturnType<to>\r\n  return hash as HashAuthorizationReturnType<to>\r\n}\r\n", "import type { Address } from 'abitype'\r\n\r\nimport type { ErrorType } from '../../../errors/utils.js'\r\nimport type { ByteArray, Hex, Signature } from '../../../types/misc.js'\r\nimport type { OneOf } from '../../../types/utils.js'\r\nimport {\r\n  type RecoverAddressErrorType,\r\n  recoverAddress,\r\n} from '../../../utils/signature/recoverAddress.js'\r\nimport type {\r\n  Authorization,\r\n  SignedAuthorization,\r\n} from '../types/authorization.js'\r\nimport {\r\n  type HashAuthorizationErrorType,\r\n  hashAuthorization,\r\n} from './hashAuthorization.js'\r\n\r\nexport type RecoverAuthorizationAddressParameters<\r\n  authorization extends OneOf<Authorization | SignedAuthorization> = OneOf<\r\n    Authorization | SignedAuthorization\r\n  >,\r\n  //\r\n  _signature = Hex | ByteArray | OneOf<Signature | SignedAuthorization>,\r\n> = {\r\n  /**\r\n   * The Authorization object.\r\n   *\r\n   * - If an unsigned `authorization` is provided, the `signature` property is required.\r\n   * - If a signed `authorization` is provided, the `signature` property does not need to be provided.\r\n   */\r\n  authorization: authorization | OneOf<Authorization | SignedAuthorization>\r\n} & (authorization extends SignedAuthorization\r\n  ? {\r\n      /** Signature of the Authorization. Not required if the `authorization` is signed. */\r\n      signature?: _signature | undefined\r\n    }\r\n  : {\r\n      /** Signature of the Authorization. Not required if the `authorization` is signed. */\r\n      signature: _signature\r\n    })\r\n\r\nexport type RecoverAuthorizationAddressReturnType = Address\r\n\r\nexport type RecoverAuthorizationAddressErrorType =\r\n  | HashAuthorizationErrorType\r\n  | RecoverAddressErrorType\r\n  | ErrorType\r\n\r\nexport async function recoverAuthorizationAddress<\r\n  const authorization extends OneOf<Authorization | SignedAuthorization>,\r\n>(\r\n  parameters: RecoverAuthorizationAddressParameters<authorization>,\r\n): Promise<RecoverAuthorizationAddressReturnType> {\r\n  const { authorization, signature } = parameters\r\n\r\n  return recoverAddress({\r\n    hash: hashAuthorization(authorization as Authorization),\r\n    signature: (signature ?? authorization) as Signature,\r\n  })\r\n}\r\n", "import type { Account } from '../../accounts/types.js'\r\nimport type { EstimateGasParameters } from '../../actions/public/estimateGas.js'\r\nimport type { BaseError } from '../../errors/base.js'\r\nimport {\r\n  EstimateGasExecutionError,\r\n  type EstimateGasExecutionErrorType,\r\n} from '../../errors/estimateGas.js'\r\nimport { UnknownNodeError } from '../../errors/node.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { Chain } from '../../types/chain.js'\r\n\r\nimport {\r\n  type GetNodeErrorParameters,\r\n  type GetNodeErrorReturnType,\r\n  getNodeError,\r\n} from './getNodeError.js'\r\n\r\nexport type GetEstimateGasErrorReturnType<cause = ErrorType> = Omit<\r\n  EstimateGasExecutionErrorType,\r\n  'cause'\r\n> & { cause: cause | GetNodeErrorReturnType }\r\n\r\nexport function getEstimateGasError<err extends ErrorType<string>>(\r\n  err: err,\r\n  {\r\n    docsPath,\r\n    ...args\r\n  }: Omit<EstimateGasParameters, 'account'> & {\r\n    account?: Account | undefined\r\n    chain?: Chain | undefined\r\n    docsPath?: string | undefined\r\n  },\r\n): GetEstimateGasErrorReturnType<err> {\r\n  const cause = (() => {\r\n    const cause = getNodeError(\r\n      err as {} as BaseError,\r\n      args as GetNodeErrorParameters,\r\n    )\r\n    if (cause instanceof UnknownNodeError) return err as {} as BaseError\r\n    return cause\r\n  })()\r\n  return new EstimateGasExecutionError(cause, {\r\n    docsPath,\r\n    ...args,\r\n  }) as GetEstimateGasErrorReturnType<err>\r\n}\r\n", "import type { Address } from 'abitype'\r\n\r\nimport type { Account } from '../../accounts/types.js'\r\nimport type { Client } from '../../clients/createClient.js'\r\nimport type { Transport } from '../../clients/transports/createTransport.js'\r\nimport type { ErrorType } from '../../errors/utils.js'\r\nimport type { BlockTag } from '../../types/block.js'\r\nimport type { Chain } from '../../types/chain.js'\r\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\r\nimport {\r\n  type HexToNumberErrorType,\r\n  hexToNumber,\r\n} from '../../utils/encoding/fromHex.js'\r\nimport {\r\n  type NumberToHexErrorType,\r\n  numberToHex,\r\n} from '../../utils/encoding/toHex.js'\r\n\r\nexport type GetTransactionCountParameters = {\r\n  /** The account address. */\r\n  address: Address\r\n} & (\r\n  | {\r\n      /** The block number. */\r\n      blockNumber?: bigint | undefined\r\n      blockTag?: undefined\r\n    }\r\n  | {\r\n      blockNumber?: undefined\r\n      /** The block tag. Defaults to 'latest'. */\r\n      blockTag?: BlockTag | undefined\r\n    }\r\n)\r\nexport type GetTransactionCountReturnType = number\r\n\r\nexport type GetTransactionCountErrorType =\r\n  | RequestErrorType\r\n  | NumberToHexErrorType\r\n  | HexToNumberErrorType\r\n  | ErrorType\r\n\r\n/**\r\n * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms#transaction) an Account has sent.\r\n *\r\n * - Docs: https://viem.sh/docs/actions/public/getTransactionCount\r\n * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)\r\n *\r\n * @param client - Client to use\r\n * @param parameters - {@link GetTransactionCountParameters}\r\n * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}\r\n *\r\n * @example\r\n * import { createPublicClient, http } from 'viem'\r\n * import { mainnet } from 'viem/chains'\r\n * import { getTransactionCount } from 'viem/public'\r\n *\r\n * const client = createPublicClient({\r\n *   chain: mainnet,\r\n *   transport: http(),\r\n * })\r\n * const transactionCount = await getTransactionCount(client, {\r\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\r\n * })\r\n */\r\nexport async function getTransactionCount<\r\n  chain extends Chain | undefined,\r\n  account extends Account | undefined,\r\n>(\r\n  client: Client<Transport, chain, account>,\r\n  { address, blockTag = 'latest', blockNumber }: GetTransactionCountParameters,\r\n): Promise<GetTransactionCountReturnType> {\r\n  const count = await client.request(\r\n    {\r\n      method: 'eth_getTransactionCount',\r\n      params: [address, blockNumber ? numberToHex(blockNumber) : blockTag],\r\n    },\r\n    { dedupe: Boolean(blockNumber) },\r\n  )\r\n  return hexToNumber(count)\r\n}\r\n", "import type { Address } from 'abitype'\r\nimport type { Account } from '../../accounts/types.js'\r\nimport {\r\n  type ParseAccountErrorType,\r\n  parseAccount,\r\n} from '../../accounts/utils/parseAccount.js'\r\nimport {\r\n  type EstimateFeesPerGasErrorType,\r\n  internal_estimateFeesPerGas,\r\n} from '../../actions/public/estimateFeesPerGas.js'\r\nimport {\r\n  type EstimateGasErrorType,\r\n  type EstimateGasParameters,\r\n  estimateGas,\r\n} from '../../actions/public/estimateGas.js'\r\nimport {\r\n  type GetBlockErrorType,\r\n  getBlock as getBlock_,\r\n} from '../../actions/public/getBlock.js'\r\nimport {\r\n  type GetTransactionCountErrorType,\r\n  getTransactionCount,\r\n} from '../../actions/public/getTransactionCount.js'\r\nimport type { Client } from '../../clients/createClient.js'\r\nimport type { Transport } from '../../clients/transports/createTransport.js'\r\nimport type { AccountNotFoundErrorType } from '../../errors/account.js'\r\nimport {\r\n  Eip1559FeesNotSupportedError,\r\n  MaxFeePerGasTooLowError,\r\n} from '../../errors/fee.js'\r\nimport type { DeriveAccount, GetAccountParameter } from '../../types/account.js'\r\nimport type { Block } from '../../types/block.js'\r\nimport type { Chain, DeriveChain } from '../../types/chain.js'\r\nimport type { GetChainParameter } from '../../types/chain.js'\r\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\r\nimport type {\r\n  TransactionRequest,\r\n  TransactionRequestEIP1559,\r\n  TransactionRequestEIP2930,\r\n  TransactionRequestEIP4844,\r\n  TransactionRequestEIP7702,\r\n  TransactionRequestLegacy,\r\n  TransactionSerializable,\r\n} from '../../types/transaction.js'\r\nimport type {\r\n  ExactPartial,\r\n  IsNever,\r\n  Prettify,\r\n  UnionOmit,\r\n  UnionRequiredBy,\r\n} from '../../types/utils.js'\r\nimport { blobsToCommitments } from '../../utils/blob/blobsToCommitments.js'\r\nimport { blobsToProofs } from '../../utils/blob/blobsToProofs.js'\r\nimport { commitmentsToVersionedHashes } from '../../utils/blob/commitmentsToVersionedHashes.js'\r\nimport { toBlobSidecars } from '../../utils/blob/toBlobSidecars.js'\r\nimport type { FormattedTransactionRequest } from '../../utils/formatters/transactionRequest.js'\r\nimport { getAction } from '../../utils/getAction.js'\r\nimport type { NonceManager } from '../../utils/nonceManager.js'\r\nimport {\r\n  type AssertRequestErrorType,\r\n  type AssertRequestParameters,\r\n  assertRequest,\r\n} from '../../utils/transaction/assertRequest.js'\r\nimport {\r\n  type GetTransactionType,\r\n  getTransactionType,\r\n} from '../../utils/transaction/getTransactionType.js'\r\nimport { getChainId as getChainId_ } from '../public/getChainId.js'\r\n\r\nexport const defaultParameters = [\r\n  'blobVersionedHashes',\r\n  'chainId',\r\n  'fees',\r\n  'gas',\r\n  'nonce',\r\n  'type',\r\n] as const\r\n\r\nexport type PrepareTransactionRequestParameterType =\r\n  | 'blobVersionedHashes'\r\n  | 'chainId'\r\n  | 'fees'\r\n  | 'gas'\r\n  | 'nonce'\r\n  | 'sidecars'\r\n  | 'type'\r\ntype ParameterTypeToParameters<\r\n  parameterType extends PrepareTransactionRequestParameterType,\r\n> = parameterType extends 'fees'\r\n  ? 'maxFeePerGas' | 'maxPriorityFeePerGas' | 'gasPrice'\r\n  : parameterType\r\n\r\nexport type PrepareTransactionRequestRequest<\r\n  chain extends Chain | undefined = Chain | undefined,\r\n  chainOverride extends Chain | undefined = Chain | undefined,\r\n  ///\r\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\r\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\r\n  GetTransactionRequestKzgParameter & {\r\n    /**\r\n     * Nonce manager to use for the transaction request.\r\n     */\r\n    nonceManager?: NonceManager | undefined\r\n    /**\r\n     * Parameters to prepare for the transaction request.\r\n     *\r\n     * @default ['blobVersionedHashes', 'chainId', 'fees', 'gas', 'nonce', 'type']\r\n     */\r\n    parameters?: readonly PrepareTransactionRequestParameterType[] | undefined\r\n  }\r\n\r\nexport type PrepareTransactionRequestParameters<\r\n  chain extends Chain | undefined = Chain | undefined,\r\n  account extends Account | undefined = Account | undefined,\r\n  chainOverride extends Chain | undefined = Chain | undefined,\r\n  accountOverride extends Account | Address | undefined =\r\n    | Account\r\n    | Address\r\n    | undefined,\r\n  request extends PrepareTransactionRequestRequest<\r\n    chain,\r\n    chainOverride\r\n  > = PrepareTransactionRequestRequest<chain, chainOverride>,\r\n> = request &\r\n  GetAccountParameter<account, accountOverride, false> &\r\n  GetChainParameter<chain, chainOverride> &\r\n  GetTransactionRequestKzgParameter<request> & { chainId?: number | undefined }\r\n\r\nexport type PrepareTransactionRequestReturnType<\r\n  chain extends Chain | undefined = Chain | undefined,\r\n  account extends Account | undefined = Account | undefined,\r\n  chainOverride extends Chain | undefined = Chain | undefined,\r\n  accountOverride extends Account | Address | undefined =\r\n    | Account\r\n    | Address\r\n    | undefined,\r\n  request extends PrepareTransactionRequestRequest<\r\n    chain,\r\n    chainOverride\r\n  > = PrepareTransactionRequestRequest<chain, chainOverride>,\r\n  ///\r\n  _derivedAccount extends Account | Address | undefined = DeriveAccount<\r\n    account,\r\n    accountOverride\r\n  >,\r\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\r\n  _transactionType = request['type'] extends string | undefined\r\n    ? request['type']\r\n    : GetTransactionType<request> extends 'legacy'\r\n      ? unknown\r\n      : GetTransactionType<request>,\r\n  _transactionRequest extends TransactionRequest =\r\n    | (_transactionType extends 'legacy' ? TransactionRequestLegacy : never)\r\n    | (_transactionType extends 'eip1559' ? TransactionRequestEIP1559 : never)\r\n    | (_transactionType extends 'eip2930' ? TransactionRequestEIP2930 : never)\r\n    | (_transactionType extends 'eip4844' ? TransactionRequestEIP4844 : never)\r\n    | (_transactionType extends 'eip7702' ? TransactionRequestEIP7702 : never),\r\n> = Prettify<\r\n  UnionRequiredBy<\r\n    Extract<\r\n      UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\r\n        (_derivedChain extends Chain\r\n          ? { chain: _derivedChain }\r\n          : { chain?: undefined }) &\r\n        (_derivedAccount extends Account\r\n          ? { account: _derivedAccount; from: Address }\r\n          : { account?: undefined; from?: undefined }),\r\n      IsNever<_transactionRequest> extends true\r\n        ? unknown\r\n        : ExactPartial<_transactionRequest>\r\n    > & { chainId?: number | undefined },\r\n    ParameterTypeToParameters<\r\n      request['parameters'] extends readonly PrepareTransactionRequestParameterType[]\r\n        ? request['parameters'][number]\r\n        : (typeof defaultParameters)[number]\r\n    >\r\n  > &\r\n    (unknown extends request['kzg'] ? {} : Pick<request, 'kzg'>)\r\n>\r\n\r\nexport type PrepareTransactionRequestErrorType =\r\n  | AccountNotFoundErrorType\r\n  | AssertRequestErrorType\r\n  | ParseAccountErrorType\r\n  | GetBlockErrorType\r\n  | GetTransactionCountErrorType\r\n  | EstimateGasErrorType\r\n  | EstimateFeesPerGasErrorType\r\n\r\n/**\r\n * Prepares a transaction request for signing.\r\n *\r\n * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest\r\n *\r\n * @param args - {@link PrepareTransactionRequestParameters}\r\n * @returns The transaction request. {@link PrepareTransactionRequestReturnType}\r\n *\r\n * @example\r\n * import { createWalletClient, custom } from 'viem'\r\n * import { mainnet } from 'viem/chains'\r\n * import { prepareTransactionRequest } from 'viem/actions'\r\n *\r\n * const client = createWalletClient({\r\n *   chain: mainnet,\r\n *   transport: custom(window.ethereum),\r\n * })\r\n * const request = await prepareTransactionRequest(client, {\r\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\r\n *   to: '0x0000000000000000000000000000000000000000',\r\n *   value: 1n,\r\n * })\r\n *\r\n * @example\r\n * // Account Hoisting\r\n * import { createWalletClient, http } from 'viem'\r\n * import { privateKeyToAccount } from 'viem/accounts'\r\n * import { mainnet } from 'viem/chains'\r\n * import { prepareTransactionRequest } from 'viem/actions'\r\n *\r\n * const client = createWalletClient({\r\n *   account: privateKeyToAccount('0x…'),\r\n *   chain: mainnet,\r\n *   transport: custom(window.ethereum),\r\n * })\r\n * const request = await prepareTransactionRequest(client, {\r\n *   to: '0x0000000000000000000000000000000000000000',\r\n *   value: 1n,\r\n * })\r\n */\r\nexport async function prepareTransactionRequest<\r\n  chain extends Chain | undefined,\r\n  account extends Account | undefined,\r\n  const request extends PrepareTransactionRequestRequest<chain, chainOverride>,\r\n  accountOverride extends Account | Address | undefined = undefined,\r\n  chainOverride extends Chain | undefined = undefined,\r\n>(\r\n  client: Client<Transport, chain, account>,\r\n  args: PrepareTransactionRequestParameters<\r\n    chain,\r\n    account,\r\n    chainOverride,\r\n    accountOverride,\r\n    request\r\n  >,\r\n): Promise<\r\n  PrepareTransactionRequestReturnType<\r\n    chain,\r\n    account,\r\n    chainOverride,\r\n    accountOverride,\r\n    request\r\n  >\r\n> {\r\n  const {\r\n    account: account_ = client.account,\r\n    blobs,\r\n    chain,\r\n    gas,\r\n    kzg,\r\n    nonce,\r\n    nonceManager,\r\n    parameters = defaultParameters,\r\n    type,\r\n  } = args\r\n  const account = account_ ? parseAccount(account_) : undefined\r\n\r\n  const request = { ...args, ...(account ? { from: account?.address } : {}) }\r\n\r\n  let block: Block | undefined\r\n  async function getBlock(): Promise<Block> {\r\n    if (block) return block\r\n    block = await getAction(\r\n      client,\r\n      getBlock_,\r\n      'getBlock',\r\n    )({ blockTag: 'latest' })\r\n    return block\r\n  }\r\n\r\n  let chainId: number | undefined\r\n  async function getChainId(): Promise<number> {\r\n    if (chainId) return chainId\r\n    if (chain) return chain.id\r\n    if (typeof args.chainId !== 'undefined') return args.chainId\r\n    const chainId_ = await getAction(client, getChainId_, 'getChainId')({})\r\n    chainId = chainId_\r\n    return chainId\r\n  }\r\n\r\n  if (\r\n    (parameters.includes('blobVersionedHashes') ||\r\n      parameters.includes('sidecars')) &&\r\n    blobs &&\r\n    kzg\r\n  ) {\r\n    const commitments = blobsToCommitments({ blobs, kzg })\r\n\r\n    if (parameters.includes('blobVersionedHashes')) {\r\n      const versionedHashes = commitmentsToVersionedHashes({\r\n        commitments,\r\n        to: 'hex',\r\n      })\r\n      request.blobVersionedHashes = versionedHashes\r\n    }\r\n    if (parameters.includes('sidecars')) {\r\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\r\n      const sidecars = toBlobSidecars({\r\n        blobs,\r\n        commitments,\r\n        proofs,\r\n        to: 'hex',\r\n      })\r\n      request.sidecars = sidecars\r\n    }\r\n  }\r\n\r\n  if (parameters.includes('chainId')) request.chainId = await getChainId()\r\n\r\n  if (parameters.includes('nonce') && typeof nonce === 'undefined' && account) {\r\n    if (nonceManager) {\r\n      const chainId = await getChainId()\r\n      request.nonce = await nonceManager.consume({\r\n        address: account.address,\r\n        chainId,\r\n        client,\r\n      })\r\n    } else {\r\n      request.nonce = await getAction(\r\n        client,\r\n        getTransactionCount,\r\n        'getTransactionCount',\r\n      )({\r\n        address: account.address,\r\n        blockTag: 'pending',\r\n      })\r\n    }\r\n  }\r\n\r\n  if (\r\n    (parameters.includes('fees') || parameters.includes('type')) &&\r\n    typeof type === 'undefined'\r\n  ) {\r\n    try {\r\n      request.type = getTransactionType(\r\n        request as TransactionSerializable,\r\n      ) as any\r\n    } catch {\r\n      // infer type from block\r\n      const block = await getBlock()\r\n      request.type =\r\n        typeof block?.baseFeePerGas === 'bigint' ? 'eip1559' : 'legacy'\r\n    }\r\n  }\r\n\r\n  if (parameters.includes('fees')) {\r\n    // TODO(4844): derive blob base fees once https://github.com/ethereum/execution-apis/pull/486 is merged.\r\n\r\n    if (request.type !== 'legacy' && request.type !== 'eip2930') {\r\n      // EIP-1559 fees\r\n      if (\r\n        typeof request.maxFeePerGas === 'undefined' ||\r\n        typeof request.maxPriorityFeePerGas === 'undefined'\r\n      ) {\r\n        const block = await getBlock()\r\n        const { maxFeePerGas, maxPriorityFeePerGas } =\r\n          await internal_estimateFeesPerGas(client, {\r\n            block: block as Block,\r\n            chain,\r\n            request: request as PrepareTransactionRequestParameters,\r\n          })\r\n\r\n        if (\r\n          typeof args.maxPriorityFeePerGas === 'undefined' &&\r\n          args.maxFeePerGas &&\r\n          args.maxFeePerGas < maxPriorityFeePerGas\r\n        )\r\n          throw new MaxFeePerGasTooLowError({\r\n            maxPriorityFeePerGas,\r\n          })\r\n\r\n        request.maxPriorityFeePerGas = maxPriorityFeePerGas\r\n        request.maxFeePerGas = maxFeePerGas\r\n      }\r\n    } else {\r\n      // Legacy fees\r\n      if (\r\n        typeof args.maxFeePerGas !== 'undefined' ||\r\n        typeof args.maxPriorityFeePerGas !== 'undefined'\r\n      )\r\n        throw new Eip1559FeesNotSupportedError()\r\n\r\n      const block = await getBlock()\r\n      const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(\r\n        client,\r\n        {\r\n          block: block as Block,\r\n          chain,\r\n          request: request as PrepareTransactionRequestParameters,\r\n          type: 'legacy',\r\n        },\r\n      )\r\n      request.gasPrice = gasPrice_\r\n    }\r\n  }\r\n\r\n  if (parameters.includes('gas') && typeof gas === 'undefined')\r\n    request.gas = await getAction(\r\n      client,\r\n      estimateGas,\r\n      'estimateGas',\r\n    )({\r\n      ...request,\r\n      account: account\r\n        ? { address: account.address, type: 'json-rpc' }\r\n        : undefined,\r\n    } as EstimateGasParameters)\r\n\r\n  assertRequest(request as AssertRequestParameters)\r\n\r\n  delete request.parameters\r\n\r\n  return request as any\r\n}\r\n", "import type { Address } from 'abitype'\r\nimport type { Account } from '../../accounts/types.js'\r\nimport {\r\n  type ParseAccountErrorType,\r\n  parseAccount,\r\n} from '../../accounts/utils/parseAccount.js'\r\nimport type { Client } from '../../clients/createClient.js'\r\nimport type { Transport } from '../../clients/transports/createTransport.js'\r\nimport { BaseError } from '../../errors/base.js'\r\nimport {\r\n  type RecoverAuthorizationAddressErrorType,\r\n  recoverAuthorizationAddress,\r\n} from '../../experimental/eip7702/utils/recoverAuthorizationAddress.js'\r\nimport type { BlockTag } from '../../types/block.js'\r\nimport type { Chain } from '../../types/chain.js'\r\nimport type { StateOverride } from '../../types/stateOverride.js'\r\nimport type { TransactionRequest } from '../../types/transaction.js'\r\nimport type { UnionOmit } from '../../types/utils.js'\r\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\r\nimport {\r\n  type NumberToHexErrorType,\r\n  numberToHex,\r\n} from '../../utils/encoding/toHex.js'\r\nimport {\r\n  type GetEstimateGasErrorReturnType,\r\n  getEstimateGasError,\r\n} from '../../utils/errors/getEstimateGasError.js'\r\nimport { extract } from '../../utils/formatters/extract.js'\r\nimport {\r\n  type FormattedTransactionRequest,\r\n  formatTransactionRequest,\r\n} from '../../utils/formatters/transactionRequest.js'\r\nimport { serializeStateOverride } from '../../utils/stateOverride.js'\r\nimport {\r\n  type AssertRequestErrorType,\r\n  type AssertRequestParameters,\r\n  assertRequest,\r\n} from '../../utils/transaction/assertRequest.js'\r\nimport {\r\n  type PrepareTransactionRequestParameters,\r\n  prepareTransactionRequest,\r\n} from '../wallet/prepareTransactionRequest.js'\r\nimport { getBalance } from './getBalance.js'\r\n\r\nexport type EstimateGasParameters<\r\n  chain extends Chain | undefined = Chain | undefined,\r\n> = UnionOmit<FormattedEstimateGas<chain>, 'from'> & {\r\n  account?: Account | Address | undefined\r\n  stateOverride?: StateOverride | undefined\r\n} & (\r\n    | {\r\n        /** The balance of the account at a block number. */\r\n        blockNumber?: bigint | undefined\r\n        blockTag?: undefined\r\n      }\r\n    | {\r\n        blockNumber?: undefined\r\n        /**\r\n         * The balance of the account at a block tag.\r\n         * @default 'latest'\r\n         */\r\n        blockTag?: BlockTag | undefined\r\n      }\r\n  )\r\ntype FormattedEstimateGas<chain extends Chain | undefined = Chain | undefined> =\r\n  FormattedTransactionRequest<chain>\r\n\r\nexport type EstimateGasReturnType = bigint\r\n\r\nexport type EstimateGasErrorType = GetEstimateGasErrorReturnType<\r\n  | ParseAccountErrorType\r\n  | NumberToHexErrorType\r\n  | RequestErrorType\r\n  | RecoverAuthorizationAddressErrorType\r\n  | AssertRequestErrorType\r\n>\r\n\r\n/**\r\n * Estimates the gas necessary to complete a transaction without submitting it to the network.\r\n *\r\n * - Docs: https://viem.sh/docs/actions/public/estimateGas\r\n * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)\r\n *\r\n * @param client - Client to use\r\n * @param parameters - {@link EstimateGasParameters}\r\n * @returns The gas estimate (in wei). {@link EstimateGasReturnType}\r\n *\r\n * @example\r\n * import { createPublicClient, http, parseEther } from 'viem'\r\n * import { mainnet } from 'viem/chains'\r\n * import { estimateGas } from 'viem/public'\r\n *\r\n * const client = createPublicClient({\r\n *   chain: mainnet,\r\n *   transport: http(),\r\n * })\r\n * const gasEstimate = await estimateGas(client, {\r\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\r\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\r\n *   value: parseEther('1'),\r\n * })\r\n */\r\nexport async function estimateGas<\r\n  chain extends Chain | undefined,\r\n  account extends Account | undefined = undefined,\r\n>(\r\n  client: Client<Transport, chain, account>,\r\n  args: EstimateGasParameters<chain>,\r\n): Promise<EstimateGasReturnType> {\r\n  const account_ = args.account ?? client.account\r\n  const account = account_ ? parseAccount(account_) : undefined\r\n\r\n  try {\r\n    const {\r\n      accessList,\r\n      authorizationList,\r\n      blobs,\r\n      blobVersionedHashes,\r\n      blockNumber,\r\n      blockTag,\r\n      data,\r\n      gas,\r\n      gasPrice,\r\n      maxFeePerBlobGas,\r\n      maxFeePerGas,\r\n      maxPriorityFeePerGas,\r\n      nonce,\r\n      value,\r\n      stateOverride,\r\n      ...rest\r\n    } = (await prepareTransactionRequest(client, {\r\n      ...args,\r\n      parameters:\r\n        // Some RPC Providers do not compute versioned hashes from blobs. We will need\r\n        // to compute them.\r\n        account?.type === 'local' ? undefined : ['blobVersionedHashes'],\r\n    } as PrepareTransactionRequestParameters)) as EstimateGasParameters\r\n\r\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\r\n    const block = blockNumberHex || blockTag\r\n\r\n    const rpcStateOverride = serializeStateOverride(stateOverride)\r\n\r\n    const to = await (async () => {\r\n      // If `to` exists on the parameters, use that.\r\n      if (rest.to) return rest.to\r\n\r\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\r\n      // address of the first authorization in the list.\r\n      if (authorizationList && authorizationList.length > 0)\r\n        return await recoverAuthorizationAddress({\r\n          authorization: authorizationList[0],\r\n        }).catch(() => {\r\n          throw new BaseError(\r\n            '`to` is required. Could not infer from `authorizationList`',\r\n          )\r\n        })\r\n\r\n      // Otherwise, we are sending a deployment transaction.\r\n      return undefined\r\n    })()\r\n\r\n    assertRequest(args as AssertRequestParameters)\r\n\r\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format\r\n    const format = chainFormat || formatTransactionRequest\r\n\r\n    const request = format({\r\n      // Pick out extra data that might exist on the chain's transaction request type.\r\n      ...extract(rest, { format: chainFormat }),\r\n      from: account?.address,\r\n      accessList,\r\n      authorizationList,\r\n      blobs,\r\n      blobVersionedHashes,\r\n      data,\r\n      gas,\r\n      gasPrice,\r\n      maxFeePerBlobGas,\r\n      maxFeePerGas,\r\n      maxPriorityFeePerGas,\r\n      nonce,\r\n      to,\r\n      value,\r\n    } as TransactionRequest)\r\n\r\n    function estimateGas_rpc(parameters: {\r\n      block: any\r\n      request: any\r\n      rpcStateOverride: any\r\n    }) {\r\n      const { block, request, rpcStateOverride } = parameters\r\n      return client.request({\r\n        method: 'eth_estimateGas',\r\n        params: rpcStateOverride\r\n          ? [request, block ?? 'latest', rpcStateOverride]\r\n          : block\r\n            ? [request, block]\r\n            : [request],\r\n      })\r\n    }\r\n\r\n    let estimate = BigInt(\r\n      await estimateGas_rpc({ block, request, rpcStateOverride }),\r\n    )\r\n\r\n    // TODO(7702): Remove this once https://github.com/ethereum/execution-apis/issues/561 is resolved.\r\n    //       Authorization list schema is not implemented on JSON-RPC spec yet, so we need to\r\n    //       manually estimate the gas.\r\n    if (authorizationList) {\r\n      const value = await getBalance(client, { address: request.from })\r\n      const estimates = await Promise.all(\r\n        authorizationList.map(async (authorization) => {\r\n          const { contractAddress } = authorization\r\n          const estimate = await estimateGas_rpc({\r\n            block,\r\n            request: {\r\n              authorizationList: undefined,\r\n              data,\r\n              from: account?.address,\r\n              to: contractAddress,\r\n              value: numberToHex(value),\r\n            },\r\n            rpcStateOverride,\r\n          }).catch(() => 100_000n)\r\n          return 2n * BigInt(estimate)\r\n        }),\r\n      )\r\n      estimate += estimates.reduce((acc, curr) => acc + curr, 0n)\r\n    }\r\n\r\n    return estimate\r\n  } catch (err) {\r\n    throw getEstimateGasError(err as BaseError, {\r\n      ...args,\r\n      account,\r\n      chain: client.chain,\r\n    })\r\n  }\r\n}\r\n", "import { BaseError } from './base.js'\r\n\r\nexport type AccountNotFoundErrorType = AccountNotFoundError & {\r\n  name: 'AccountNotFoundError'\r\n}\r\nexport class AccountNotFoundError extends BaseError {\r\n  constructor({ docsPath }: { docsPath?: string | undefined } = {}) {\r\n    super(\r\n      [\r\n        'Could not find an Account to execute with this Action.',\r\n        'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.',\r\n      ].join('\\n'),\r\n      {\r\n        docsPath,\r\n        docsSlug: 'account',\r\n        name: 'AccountNotFoundError',\r\n      },\r\n    )\r\n  }\r\n}\r\n\r\nexport type AccountTypeNotSupportedErrorType = AccountTypeNotSupportedError & {\r\n  name: 'AccountTypeNotSupportedError'\r\n}\r\nexport class AccountTypeNotSupportedError extends BaseError {\r\n  constructor({\r\n    docsPath,\r\n    metaMessages,\r\n    type,\r\n  }: {\r\n    docsPath?: string | undefined\r\n    metaMessages?: string[] | undefined\r\n    type: string\r\n  }) {\r\n    super(`Account type \"${type}\" is not supported.`, {\r\n      docsPath,\r\n      metaMessages,\r\n      name: 'AccountTypeNotSupportedError',\r\n    })\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["yParityOrV", "recoveryBit", "sha256", "sha256", "size", "size", "blobs", "commitments", "proofs", "v", "_a", "_b", "cause", "getBlock", "getChainId", "chainId", "block", "block", "request", "rpcStateOverride", "value", "estimate"]
}
