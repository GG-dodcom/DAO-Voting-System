import {
  CaipNetworksUtil,
  ConstantsUtil as ConstantsUtil3,
  ErrorUtil,
  HelpersUtil,
  PresetsUtil,
  ProviderUtil,
  WcHelpersUtil
} from "./chunk-3MBY52MV.js";
import "./chunk-U225TY3K.js";
import {
  AlertController,
  ChainController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  NetworkUtil,
  SafeLocalStorage,
  SafeLocalStorageKeys,
  StorageUtil,
  W3mFrameHelpers,
  W3mFrameProvider,
  W3mFrameRpcConstants,
  isReownName
} from "./chunk-I75X6WWX.js";
import {
  coinbaseWallet,
  normalize
} from "./chunk-LNJ5BZLC.js";
import {
  ChainNotConfiguredError,
  ProviderNotFoundError,
  connect,
  createConfig,
  createConnector,
  disconnect,
  estimateGas,
  getAccount,
  getBalance,
  getConnections,
  getConnectors,
  getEnsAddress,
  getEnsAvatar,
  getEnsName,
  injected,
  prepareTransactionRequest,
  reconnect,
  sendTransaction,
  signMessage,
  switchAccount,
  switchChain,
  waitForTransactionReceipt,
  watchAccount,
  watchConnectors,
  writeContract
} from "./chunk-IHUECIKB.js";
import "./chunk-UAH2N63J.js";
import {
  fallback,
  http,
  parseUnits
} from "./chunk-THEU6JAT.js";
import "./chunk-JFITEOA7.js";
import "./chunk-K3EED42H.js";
import {
  mainnet
} from "./chunk-HCYZCBEV.js";
import "./chunk-7IZQOQF4.js";
import "./chunk-465AH746.js";
import {
  SwitchChainError,
  UserRejectedRequestError,
  formatUnits,
  getAddress,
  numberToHex
} from "./chunk-6LFFB6YU.js";
import "./chunk-GUHHX4SG.js";
import "./chunk-47FCCYBK.js";
import "./chunk-DBQCCCBW.js";
import "./chunk-R7UJTMYN.js";
import "./chunk-LO2BFYP3.js";
import "./chunk-3UECR6ZZ.js";
import "./chunk-NTW2DYPR.js";
import "./chunk-I4R5TJYD.js";
import "./chunk-LEHSBXYP.js";
import "./chunk-XZZVU2JM.js";
import "./chunk-IOB7GAQF.js";
import "./chunk-2J5OESMT.js";
import "./chunk-HSFRI4UD.js";
import "./chunk-QNMR2JUL.js";
import "./chunk-MSFXBLHD.js";

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/utils/helpers.js
async function getWalletConnectCaipNetworks(connector) {
  var _a;
  if (!connector) {
    throw new Error("networkControllerClient:getApprovedCaipNetworks - connector is undefined");
  }
  const provider = await (connector == null ? void 0 : connector.getProvider());
  const approvedCaipNetworkIds = WcHelpersUtil.getChainsFromNamespaces((_a = provider == null ? void 0 : provider.session) == null ? void 0 : _a.namespaces);
  return {
    supportsAllNetworks: false,
    approvedCaipNetworkIds
  };
}
function getEmailCaipNetworks() {
  return {
    supportsAllNetworks: true,
    approvedCaipNetworkIds: PresetsUtil.WalletConnectRpcChainIds.map((id) => `${ConstantsUtil3.EIP155}:${id}`)
  };
}
function getTransport({ chain, projectId }) {
  var _a;
  const RPC_URL = CoreHelperUtil.getBlockchainApiUrl();
  const chainDefaultUrl = (_a = chain.rpcUrls.default.http) == null ? void 0 : _a[0];
  if (!PresetsUtil.WalletConnectRpcChainIds.includes(chain.id)) {
    return http(chainDefaultUrl);
  }
  return fallback([
    http(`${RPC_URL}/v1/?chainId=${ConstantsUtil3.EIP155}:${chain.id}&projectId=${projectId}`, {
      fetchOptions: {
        headers: {
          "Content-Type": "text/plain"
        }
      }
    }),
    http(chainDefaultUrl)
  ]);
}
function requireCaipAddress(caipAddress) {
  if (!caipAddress) {
    throw new Error("No CAIP address provided");
  }
  const account = caipAddress.split(":")[2];
  if (!account) {
    throw new Error("Invalid CAIP address");
  }
  return account;
}
function parseWalletCapabilities(str) {
  try {
    return JSON.parse(str);
  } catch (error) {
    throw new Error("Error parsing wallet capabilities");
  }
}

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/UniversalConnector.js
walletConnect.type = "walletConnect";
function walletConnect(parameters, appKit, caipNetworks) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let providerPromise;
  let accountsChanged;
  let chainChanged;
  let connect2;
  let displayUri;
  let sessionDelete;
  let disconnect2;
  return createConnector((config) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect.type,
    async setup() {
      const provider = await this.getProvider().catch(() => null);
      if (!provider) {
        return;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider.on("session_delete", sessionDelete);
      }
    },
    async connect({ ...rest } = {}) {
      try {
        const provider = await this.getProvider();
        if (!provider) {
          throw new ProviderNotFoundError();
        }
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider.on("display_uri", displayUri);
        }
        const isChainsStale = await this.isChainsStale();
        if (provider.session && isChainsStale) {
          await provider.disconnect();
        }
        if (!provider.session || isChainsStale) {
          const namespaces = WcHelpersUtil.createNamespaces(caipNetworks);
          await provider.connect({
            optionalNamespaces: namespaces,
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(caipNetworks.map((x) => Number(x.id)));
        }
        const accounts = (await provider.enable()).map((x) => getAddress(x));
        const currentChainId = await this.getChainId();
        if (displayUri) {
          provider.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider.on("session_delete", sessionDelete);
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error == null ? void 0 : error.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await (provider == null ? void 0 : provider.disconnect());
      } catch (error) {
        if (!/No matching key/i.test(error.message)) {
          throw error;
        }
      } finally {
        if (chainChanged) {
          provider == null ? void 0 : provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider == null ? void 0 : provider.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider == null ? void 0 : provider.on("connect", connect2);
        }
        if (accountsChanged) {
          provider == null ? void 0 : provider.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider == null ? void 0 : provider.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      var _a, _b, _c;
      const provider = await this.getProvider();
      if (!((_a = provider == null ? void 0 : provider.session) == null ? void 0 : _a.namespaces)) {
        return [];
      }
      const accountsList = (_c = (_b = provider == null ? void 0 : provider.session) == null ? void 0 : _b.namespaces["eip155"]) == null ? void 0 : _c.accounts;
      const accounts = (accountsList == null ? void 0 : accountsList.map((account) => account.split(":")[2])) ?? [];
      return accounts;
    },
    async getProvider({ chainId } = {}) {
      var _a, _b, _c;
      async function initProvider() {
        var _a2;
        const optionalChains = caipNetworks.map((x) => Number(x.id));
        if (!optionalChains.length) {
          return void 0;
        }
        const provider = (_a2 = appKit.universalAdapter) == null ? void 0 : _a2.getWalletConnectProvider();
        if (!provider) {
          throw new Error("Provider not found");
        }
        return provider;
      }
      if (!provider_) {
        if (!providerPromise) {
          providerPromise = initProvider();
        }
        provider_ = await providerPromise;
        provider_ == null ? void 0 : provider_.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      const currentChainId = (_a = appKit.getCaipNetwork()) == null ? void 0 : _a.id;
      if (chainId && currentChainId !== chainId) {
        const storedCaipNetwork = StorageUtil.getStoredActiveCaipNetwork();
        if (storedCaipNetwork && storedCaipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
          await ((_b = this.switchChain) == null ? void 0 : _b.call(this, { chainId: Number(storedCaipNetwork.id) }));
        } else {
          await ((_c = this.switchChain) == null ? void 0 : _c.call(this, { chainId }));
        }
      }
      return provider_;
    },
    async getChainId() {
      var _a, _b, _c, _d;
      const chainId = (_a = appKit.getCaipNetwork()) == null ? void 0 : _a.id;
      if (chainId) {
        return chainId;
      }
      const provider = await this.getProvider();
      const chain = (_d = (_c = (_b = provider.session) == null ? void 0 : _b.namespaces["eip155"]) == null ? void 0 : _c.chains) == null ? void 0 : _d[0];
      const network = caipNetworks.find((c) => c.id === chain);
      return network == null ? void 0 : network.id;
    },
    async isAuthorized() {
      try {
        const [accounts, provider] = await Promise.all([this.getAccounts(), this.getProvider()]);
        if (!accounts.length) {
          return false;
        }
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a, _b;
      const provider = await this.getProvider();
      if (!provider) {
        throw new ProviderNotFoundError();
      }
      const chainToSwitch = caipNetworks.find((x) => x.id === chainId);
      if (!chainToSwitch) {
        throw new SwitchChainError(new ChainNotConfiguredError());
      }
      try {
        if (chainToSwitch == null ? void 0 : chainToSwitch.caipNetworkId) {
          provider.setDefaultChain(chainToSwitch == null ? void 0 : chainToSwitch.caipNetworkId);
        }
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chainId) }]
        });
        config.emitter.emit("change", { chainId: Number(chainId) });
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return { ...chainToSwitch, id: chainToSwitch.id };
      } catch (err) {
        const error = err;
        if (/(?:user rejected)/iu.test(error.message)) {
          throw new UserRejectedRequestError(error);
        }
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls) {
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          } else {
            blockExplorerUrls = ((_a = chainToSwitch.blockExplorers) == null ? void 0 : _a.default.url) ? [(_b = chainToSwitch.blockExplorers) == null ? void 0 : _b.default.url] : [];
          }
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: chainToSwitch.name,
            iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
            nativeCurrency: chainToSwitch.nativeCurrency,
            rpcUrls: chainToSwitch.rpcUrls.default.http
          };
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return { ...chainToSwitch, id: chainToSwitch.id };
        } catch (e) {
          throw new UserRejectedRequestError(e);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const chainId = Number(connectInfo.chainId);
      const accounts = await this.getAccounts();
      config.emitter.emit("connect", { accounts, chainId });
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (sessionDelete) {
        provider.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var _a, _b, _c;
      if (!((_a = provider_ == null ? void 0 : provider_.session) == null ? void 0 : _a.namespaces)) {
        return [];
      }
      const accounts = (_c = (_b = provider_ == null ? void 0 : provider_.session) == null ? void 0 : _b.namespaces["eip155"]) == null ? void 0 : _c.accounts;
      const chainIds = (accounts == null ? void 0 : accounts.map((account) => Number.parseInt(account.split(":")[1] ?? ""))) ?? [];
      return chainIds;
    },
    async getRequestedChainsIds() {
      var _a;
      const chainIds = await ((_a = config.storage) == null ? void 0 : _a.getItem(this.requestedChainsStorageKey)) ?? [];
      return [...new Set(chainIds)];
    },
    async isChainsStale() {
      if (!isNewChainsStale) {
        return false;
      }
      const connectorChains = config.chains.map((x) => x.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id) => connectorChains.includes(id))) {
        return false;
      }
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id) => requestedChains.includes(Number(id)));
    },
    async setRequestedChainsIds(chains) {
      var _a;
      await ((_a = config.storage) == null ? void 0 : _a.setItem(this.requestedChainsStorageKey, chains));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}

// node_modules/@reown/appkit/dist/esm/src/auth-provider/W3MFrameProviderSingleton.js
var W3mFrameProviderSingleton = class _W3mFrameProviderSingleton {
  // eslint-disable-next-line @typescript-eslint/no-empty-function -- This is a singleton
  constructor() {
  }
  static getInstance({ projectId, chainId, onTimeout }) {
    if (!_W3mFrameProviderSingleton.instance) {
      _W3mFrameProviderSingleton.instance = new W3mFrameProvider({ projectId, chainId, onTimeout });
    }
    return _W3mFrameProviderSingleton.instance;
  }
};

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/AuthConnector.js
function authConnector(parameters) {
  function parseChainId(chainId) {
    return NetworkUtil.parseEvmChainId(chainId) || 1;
  }
  return createConnector((config) => ({
    id: ConstantsUtil3.AUTH_CONNECTOR_ID,
    name: "AppKit Auth",
    type: "w3mAuth",
    chain: ConstantsUtil.CHAIN.EVM,
    async connect(options = {}) {
      const provider = await this.getProvider();
      let chainId = options.chainId;
      if (options.isReconnecting) {
        chainId = provider.getLastUsedChainId();
        if (!chainId) {
          throw new Error("ChainId not found in provider");
        }
      }
      const { address, chainId: frameChainId } = await provider.connect({
        chainId
      });
      await provider.getSmartAccountEnabledNetworks();
      const parsedChainId = parseChainId(frameChainId);
      return {
        accounts: [address],
        account: address,
        chainId: parsedChainId,
        chain: {
          id: parsedChainId,
          unsuported: false
        }
      };
    },
    async disconnect() {
      const provider = await this.getProvider();
      await provider.disconnect();
    },
    async getAccounts() {
      const provider = await this.getProvider();
      const { address } = await provider.connect();
      config.emitter.emit("change", { accounts: [address] });
      return [address];
    },
    async getProvider() {
      if (!this.provider) {
        this.provider = W3mFrameProviderSingleton.getInstance({
          projectId: parameters.options.projectId,
          onTimeout: () => {
            AlertController.open(ErrorUtil.ALERT_ERRORS.INVALID_APP_CONFIGURATION_SOCIALS, "error");
          }
        });
      }
      return Promise.resolve(this.provider);
    },
    async getChainId() {
      const provider = await this.getProvider();
      const { chainId } = await provider.getChainId();
      return parseChainId(chainId);
    },
    async isAuthorized() {
      const provider = await this.getProvider();
      const { isConnected } = await provider.isConnected();
      return isConnected;
    },
    async switchChain({ chainId }) {
      try {
        const chain = config.chains.find((c) => c.id === chainId);
        if (!chain) {
          throw new SwitchChainError(new Error("chain not found on connector."));
        }
        const provider = await this.getProvider();
        const response = await provider.connect({ chainId });
        config.emitter.emit("change", {
          chainId: Number(chainId),
          accounts: [response.address]
        });
        return chain;
      } catch (error) {
        if (error instanceof Error) {
          throw new SwitchChainError(error);
        }
        throw error;
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", { accounts: accounts.map(getAddress) });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      const provider = await this.getProvider();
      await provider.disconnect();
    }
  }));
}

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/client.js
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  "wallet_grantPermissions"
];
var WagmiAdapter = class {
  constructor(configParams) {
    var _a, _b;
    this.appKit = void 0;
    this.options = void 0;
    this.chainNamespace = ConstantsUtil.CHAIN.EVM;
    this.defaultCaipNetwork = void 0;
    this.tokens = HelpersUtil.getCaipTokens((_a = this.options) == null ? void 0 : _a.tokens);
    this.siweControllerClient = (_b = this.options) == null ? void 0 : _b.siweConfig;
    this.adapterType = "wagmi";
    if (!configParams.projectId) {
      throw new Error(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED.shortMessage);
    }
    this.caipNetworks = CaipNetworksUtil.extendCaipNetworks(configParams.networks, {
      projectId: configParams.projectId,
      customNetworkImageUrls: {}
    });
    this.wagmiChains = this.caipNetworks.filter((caipNetwork) => caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM);
    const transportsArr = this.wagmiChains.map((chain) => [
      chain.id,
      getTransport({ chain, projectId: configParams.projectId })
    ]);
    const transports = Object.fromEntries(transportsArr);
    const connectors = [...configParams.connectors ?? []];
    this.wagmiConfig = createConfig({
      ...configParams,
      chains: this.wagmiChains,
      transports,
      connectors: [...connectors, ...(configParams == null ? void 0 : configParams.connectors) ?? []]
    });
  }
  setCustomConnectors(options, appKit) {
    var _a, _b, _c, _d, _e, _f, _g;
    const customConnectors = [];
    if (options.enableWalletConnect !== false) {
      customConnectors.push(walletConnect(options, appKit, this.caipNetworks));
    }
    if (options.enableInjected !== false) {
      customConnectors.push(injected({ shimDisconnect: true }));
    }
    if (options.enableCoinbase !== false) {
      customConnectors.push(coinbaseWallet({
        version: "4",
        appName: ((_a = options.metadata) == null ? void 0 : _a.name) ?? "Unknown",
        appLogoUrl: ((_b = options.metadata) == null ? void 0 : _b.icons[0]) ?? "Unknown",
        preference: options.coinbasePreference ?? "all"
      }));
    }
    const emailEnabled = ((_c = options.features) == null ? void 0 : _c.email) === void 0 ? ConstantsUtil2.DEFAULT_FEATURES.email : (_d = options.features) == null ? void 0 : _d.email;
    const socialsEnabled = ((_e = options.features) == null ? void 0 : _e.socials) ? ((_g = (_f = options.features) == null ? void 0 : _f.socials) == null ? void 0 : _g.length) > 0 : ConstantsUtil2.DEFAULT_FEATURES.socials;
    if (emailEnabled || socialsEnabled) {
      customConnectors.push(authConnector({
        chains: this.wagmiChains,
        options: { projectId: options.projectId }
      }));
    }
    customConnectors.forEach((connector) => {
      const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
      this.wagmiConfig._internal.connectors.setState((prev) => [...prev, cnctr]);
    });
  }
  construct(appKit, options) {
    var _a, _b, _c, _d;
    this.appKit = appKit;
    this.options = options;
    this.defaultCaipNetwork = options.defaultNetwork || ((_a = options.networks) == null ? void 0 : _a[0]);
    this.tokens = HelpersUtil.getCaipTokens(options.tokens);
    this.setCustomConnectors(options, appKit);
    if (!this.wagmiConfig) {
      throw new Error("appkit:wagmiConfig - is undefined");
    }
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => {
        const chainId = caipNetwork == null ? void 0 : caipNetwork.id;
        if (chainId && this.wagmiConfig) {
          await switchChain(this.wagmiConfig, { chainId });
        }
      },
      getApprovedCaipNetworksData: async () => {
        if (!this.wagmiConfig) {
          throw new Error("networkControllerClient:getApprovedCaipNetworksData - wagmiConfig is undefined");
        }
        return new Promise((resolve) => {
          var _a2, _b2;
          const connections = new Map(this.wagmiConfig.state.connections);
          const connection = connections.get(this.wagmiConfig.state.current || "");
          if (((_a2 = connection == null ? void 0 : connection.connector) == null ? void 0 : _a2.id) === ConstantsUtil3.AUTH_CONNECTOR_ID) {
            resolve(getEmailCaipNetworks());
          } else if (((_b2 = connection == null ? void 0 : connection.connector) == null ? void 0 : _b2.id) === ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID) {
            const connector = this.wagmiConfig.connectors.find((c) => c.id === ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID);
            resolve(getWalletConnectCaipNetworks(connector));
          }
          resolve({ approvedCaipNetworkIds: [], supportsAllNetworks: true });
        });
      }
    };
    this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var _a2, _b2, _c2, _d2, _e, _f, _g, _h, _i, _j, _k;
        if (!this.wagmiConfig) {
          throw new Error("connectionControllerClient:getWalletConnectUri - wagmiConfig is undefined");
        }
        const connector = this.wagmiConfig.connectors.find((c) => c.id === ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID);
        if (!connector) {
          throw new Error("connectionControllerClient:getWalletConnectUri - connector is undefined");
        }
        const provider = await connector.getProvider();
        const siweParams = await ((_c2 = (_b2 = (_a2 = this.options) == null ? void 0 : _a2.siweConfig) == null ? void 0 : _b2.getMessageParams) == null ? void 0 : _c2.call(_b2));
        const isSiweEnabled = (_f = (_e = (_d2 = this.options) == null ? void 0 : _d2.siweConfig) == null ? void 0 : _e.options) == null ? void 0 : _f.enabled;
        const isProviderSupported = typeof (provider == null ? void 0 : provider.authenticate) === "function";
        const isSiweParamsValid = siweParams && Object.keys(siweParams || {}).length > 0;
        const siweConfig = (_g = this.options) == null ? void 0 : _g.siweConfig;
        if (isSiweEnabled && isProviderSupported && isSiweParamsValid && siweConfig) {
          await connector.setRequestedChainsIds(siweParams.chains);
          const { SIWEController, getDidChainId, getDidAddress } = await import("./exports-R36WTXMK.js");
          const chains = (_h = this.caipNetworks) == null ? void 0 : _h.filter((network) => network.chainNamespace === "eip155").map((chain) => chain.caipNetworkId);
          siweParams.chains = (_i = this.caipNetworks) == null ? void 0 : _i.filter((network) => network.chainNamespace === "eip155").map((chain) => chain.id);
          const result = await provider.authenticate({
            nonce: await siweConfig.getNonce(),
            methods: [...OPTIONAL_METHODS],
            ...siweParams,
            chains
          });
          const signedCacao = (_j = result == null ? void 0 : result.auths) == null ? void 0 : _j[0];
          if (signedCacao) {
            const { p, s } = signedCacao;
            const cacaoChainId = getDidChainId(p.iss);
            const address = getDidAddress(p.iss);
            if (address && cacaoChainId) {
              SIWEController.setSession({
                address,
                chainId: parseInt(cacaoChainId, 10)
              });
            }
            try {
              const message = provider.client.formatAuthMessage({
                request: p,
                iss: p.iss
              });
              await SIWEController.verifyMessage({
                message,
                signature: s.s,
                cacao: signedCacao
              });
            } catch (error) {
              console.error("Error verifying message", error);
              await provider.disconnect().catch(console.error);
              await SIWEController.signOut().catch(console.error);
              throw error;
            }
          }
        }
        const chainId = (_k = this.appKit) == null ? void 0 : _k.getCaipNetworkId();
        await connect(this.wagmiConfig, { connector, chainId });
      },
      connectExternal: async ({ id, provider, info }) => {
        var _a2, _b2, _c2;
        if (!this.wagmiConfig) {
          throw new Error("networkControllerClient:getApprovedCaipNetworksData - wagmiConfig is undefined");
        }
        const connector = this.wagmiConfig.connectors.find((c) => c.id === id);
        if (!connector) {
          throw new Error("connectionControllerClient:connectExternal - connector is undefined");
        }
        (_a2 = this.appKit) == null ? void 0 : _a2.setClientId(null);
        if (provider && info && connector.id === ConstantsUtil3.EIP6963_CONNECTOR_ID) {
          (_b2 = connector.setEip6963Wallet) == null ? void 0 : _b2.call(connector, { provider, info });
        }
        const chainId = (_c2 = this.appKit) == null ? void 0 : _c2.getCaipNetworkId();
        await connect(this.wagmiConfig, { connector, chainId });
      },
      checkInstalled: (ids) => {
        var _a2;
        const injectedConnector = (_a2 = this.appKit) == null ? void 0 : _a2.getConnectors().find((c) => c.type === "INJECTED");
        if (!ids) {
          return Boolean(window.ethereum);
        }
        if (injectedConnector) {
          if (!(window == null ? void 0 : window.ethereum)) {
            return false;
          }
          return ids.some((id) => {
            var _a3;
            return Boolean((_a3 = window.ethereum) == null ? void 0 : _a3[String(id)]);
          });
        }
        return false;
      },
      disconnect: async () => {
        var _a2, _b2, _c2, _d2, _e;
        await disconnect(this.wagmiConfig);
        if ((_c2 = (_b2 = (_a2 = this.options) == null ? void 0 : _a2.siweConfig) == null ? void 0 : _b2.options) == null ? void 0 : _c2.signOutOnDisconnect) {
          const { SIWEController } = await import("./exports-R36WTXMK.js");
          await SIWEController.signOut();
        }
        SafeLocalStorage.removeItem(SafeLocalStorageKeys.WALLET_ID);
        SafeLocalStorage.removeItem(SafeLocalStorageKeys.CONNECTED_CONNECTOR);
        SafeLocalStorage.removeItem(SafeLocalStorageKeys.WALLET_NAME);
        (_d2 = this.appKit) == null ? void 0 : _d2.setClientId(null);
        this.syncAccount({
          address: void 0,
          chainId: void 0,
          connector: void 0,
          addresses: void 0,
          status: "disconnected"
        });
        (_e = this.appKit) == null ? void 0 : _e.resetAccount("solana");
      },
      signMessage: async (message) => {
        var _a2;
        const caipAddress = ((_a2 = this.appKit) == null ? void 0 : _a2.getCaipAddress()) || "";
        const account = requireCaipAddress(caipAddress);
        return signMessage(this.wagmiConfig, { message, account });
      },
      estimateGas: async (args) => {
        if (args.chainNamespace && args.chainNamespace !== "eip155") {
          throw new Error(`Invalid chain namespace - Expected eip155, got ${args.chainNamespace}`);
        }
        try {
          return await estimateGas(this.wagmiConfig, {
            account: args.address,
            to: args.to,
            data: args.data,
            type: "legacy"
          });
        } catch (error) {
          return BigInt(0);
        }
      },
      getCapabilities: async (params) => {
        var _a2, _b2;
        if (!this.wagmiConfig) {
          throw new Error("connectionControllerClient:getCapabilities - wagmiConfig is undefined");
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        if (!(connection == null ? void 0 : connection.connector)) {
          throw new Error("connectionControllerClient:getCapabilities - connector is undefined");
        }
        const provider = await connection.connector.getProvider();
        if (!provider) {
          throw new Error("connectionControllerClient:getCapabilities - provider is undefined");
        }
        const walletCapabilitiesString = (_b2 = (_a2 = provider.session) == null ? void 0 : _a2.sessionProperties) == null ? void 0 : _b2["capabilities"];
        if (walletCapabilitiesString) {
          const walletCapabilities = parseWalletCapabilities(walletCapabilitiesString);
          const accountCapabilities = walletCapabilities[params];
          if (accountCapabilities) {
            return accountCapabilities;
          }
        }
        return await provider.request({ method: "wallet_getCapabilities", params: [params] });
      },
      grantPermissions: async (params) => {
        if (!this.wagmiConfig) {
          throw new Error("connectionControllerClient:grantPermissions - wagmiConfig is undefined");
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        if (!(connection == null ? void 0 : connection.connector)) {
          throw new Error("connectionControllerClient:grantPermissions - connector is undefined");
        }
        const provider = await connection.connector.getProvider();
        if (!provider) {
          throw new Error("connectionControllerClient:grantPermissions - provider is undefined");
        }
        return provider.request({ method: "wallet_grantPermissions", params });
      },
      sendTransaction: async (data) => {
        if (data.chainNamespace && data.chainNamespace !== "eip155") {
          throw new Error(`Invalid chain namespace - Expected eip155, got ${data.chainNamespace}`);
        }
        const { chainId } = getAccount(this.wagmiConfig);
        const txParams = {
          account: data.address,
          to: data.to,
          value: data.value,
          gas: data.gas,
          gasPrice: data.gasPrice,
          data: data.data,
          chainId,
          type: "legacy"
        };
        await prepareTransactionRequest(this.wagmiConfig, txParams);
        const tx = await sendTransaction(this.wagmiConfig, txParams);
        await waitForTransactionReceipt(this.wagmiConfig, { hash: tx, timeout: 25e3 });
        return tx;
      },
      writeContract: async (data) => {
        var _a2, _b2, _c2;
        const caipAddress = ((_a2 = this.appKit) == null ? void 0 : _a2.getCaipAddress()) || "";
        const account = requireCaipAddress(caipAddress);
        const chainId = (_b2 = this.appKit) == null ? void 0 : _b2.getCaipNetworkId();
        if (!chainId) {
          throw new Error("networkControllerClient:writeContract - chainId is undefined");
        }
        const tx = await writeContract(this.wagmiConfig, {
          chain: (_c2 = this.wagmiChains) == null ? void 0 : _c2[chainId],
          chainId,
          address: data.tokenAddress,
          account,
          abi: data.abi,
          functionName: data.method,
          args: [data.receiverAddress, data.tokenAmount]
        });
        return tx;
      },
      getEnsAddress: async (value) => {
        var _a2, _b2;
        try {
          if (!this.wagmiConfig) {
            throw new Error("networkControllerClient:getApprovedCaipNetworksData - wagmiConfig is undefined");
          }
          const chainId = (_a2 = this.appKit) == null ? void 0 : _a2.getCaipNetworkId();
          let ensName = false;
          let wcName = false;
          if (isReownName(value)) {
            wcName = await ((_b2 = this.appKit) == null ? void 0 : _b2.resolveReownName(value)) || false;
          }
          if (chainId === 1) {
            ensName = await getEnsAddress(this.wagmiConfig, {
              name: normalize(value),
              chainId
            });
          }
          return ensName || wcName || false;
        } catch {
          return false;
        }
      },
      getEnsAvatar: async (value) => {
        var _a2;
        const chainId = (_a2 = this.appKit) == null ? void 0 : _a2.getCaipNetworkId();
        if (chainId !== mainnet.id) {
          return false;
        }
        const avatar = await getEnsAvatar(this.wagmiConfig, {
          name: normalize(value),
          chainId
        });
        return avatar || false;
      },
      parseUnits,
      formatUnits
    };
    ChainController.state.chains.set(this.chainNamespace, {
      chainNamespace: this.chainNamespace,
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient,
      adapterType: this.adapterType,
      caipNetworks: this.caipNetworks
    });
    this.syncConnectors(this.wagmiConfig.connectors);
    this.syncAuthConnector((_b = this.wagmiConfig) == null ? void 0 : _b.connectors.find((c) => c.id === ConstantsUtil3.AUTH_CONNECTOR_ID));
    this.syncRequestedNetworks(this.caipNetworks);
    watchConnectors(this.wagmiConfig, {
      onChange: (_connectors) => {
        this.syncConnectors(_connectors);
        this.syncAuthConnector(_connectors.find((c) => c.id === ConstantsUtil3.AUTH_CONNECTOR_ID));
      }
    });
    watchAccount(this.wagmiConfig, {
      onChange: (accountData) => {
        this.syncAccount(accountData);
      }
    });
    (_c = this.appKit) == null ? void 0 : _c.setEIP6963Enabled(options.enableEIP6963 !== false);
    (_d = this.appKit) == null ? void 0 : _d.subscribeShouldUpdateToAddress((newAddress) => {
      var _a2;
      if (newAddress) {
        const connections = getConnections(this.wagmiConfig);
        const connector = (_a2 = connections[0]) == null ? void 0 : _a2.connector;
        if (connector) {
          switchAccount(this.wagmiConfig, {
            connector
          }).then((response) => this.syncAccount({
            address: newAddress,
            isConnected: true,
            addresses: response.accounts,
            connector,
            chainId: response.chainId,
            status: "connected"
          }));
        }
      }
    });
  }
  subscribeState(callback) {
    var _a;
    return (_a = this.appKit) == null ? void 0 : _a.subscribeState((state) => callback({
      ...state,
      selectedNetworkId: state.selectedNetworkId ? Number(NetworkUtil.caipNetworkIdToNumber(state.selectedNetworkId)) : void 0
    }));
  }
  syncRequestedNetworks(caipNetworks) {
    const uniqueChainNamespaces = Array.from(new Set(caipNetworks.map((caipNetwork) => caipNetwork.chainNamespace)));
    uniqueChainNamespaces.filter((c) => Boolean(c)).forEach((chainNamespace) => {
      var _a;
      (_a = this.appKit) == null ? void 0 : _a.setRequestedCaipNetworks(caipNetworks.filter((caipNetwork) => caipNetwork.chainNamespace === chainNamespace), chainNamespace);
    });
  }
  async syncAccount({ address, chainId, connector, addresses, status }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    const isAuthConnector = (connector == null ? void 0 : connector.id) === ConstantsUtil3.AUTH_CONNECTOR_ID;
    if (status === "disconnected") {
      (_a = this.appKit) == null ? void 0 : _a.resetAccount(this.chainNamespace);
      (_b = this.appKit) == null ? void 0 : _b.resetWcConnection();
      (_c = this.appKit) == null ? void 0 : _c.resetNetwork(this.chainNamespace);
      (_d = this.appKit) == null ? void 0 : _d.setAllAccounts([], this.chainNamespace);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.WALLET_ID);
      if (isAuthConnector) {
        await connector.disconnect();
      }
      return;
    }
    if (this.wagmiConfig) {
      if (connector) {
        if (connector && connector.name === "WalletConnect" && connector.getProvider && address) {
          const activeCaipNetwork = (_e = this.appKit) == null ? void 0 : _e.getCaipNetwork();
          const currentChainId = chainId || (activeCaipNetwork == null ? void 0 : activeCaipNetwork.id);
          const provider = await connector.getProvider();
          const namespaces = ((_f = provider == null ? void 0 : provider.session) == null ? void 0 : _f.namespaces) || {};
          const namespaceKeys = namespaces ? Object.keys(namespaces) : [];
          const preferredAccountType = (_g = this.appKit) == null ? void 0 : _g.getPreferredAccountType();
          namespaceKeys.forEach((key) => {
            var _a2, _b2, _c2;
            const chainNamespace = key;
            const caipAddress = (_a2 = namespaces == null ? void 0 : namespaces[key]) == null ? void 0 : _a2.accounts[0];
            ProviderUtil.setProvider(chainNamespace, provider);
            ProviderUtil.setProviderId(chainNamespace, "walletConnect");
            (_b2 = this.appKit) == null ? void 0 : _b2.setPreferredAccountType(preferredAccountType, chainNamespace);
            (_c2 = this.appKit) == null ? void 0 : _c2.setCaipAddress(caipAddress, chainNamespace);
          });
          if (((_i = (_h = this.appKit) == null ? void 0 : _h.getCaipNetwork()) == null ? void 0 : _i.chainNamespace) !== ConstantsUtil.CHAIN.SOLANA && currentChainId) {
            this.syncNetwork(address, currentChainId, true);
            await Promise.all([
              this.syncProfile(address, currentChainId),
              this.syncBalance(address, currentChainId),
              this.syncConnectedWalletInfo(connector),
              (_j = this.appKit) == null ? void 0 : _j.setApprovedCaipNetworksData(this.chainNamespace)
            ]);
          }
        } else if (status === "connected" && address && chainId) {
          const caipAddress = `eip155:${chainId}:${address}`;
          this.syncNetwork(address, chainId, true);
          (_k = this.appKit) == null ? void 0 : _k.setCaipAddress(caipAddress, this.chainNamespace);
          await Promise.all([
            this.syncProfile(address, chainId),
            this.syncBalance(address, chainId),
            this.syncConnectedWalletInfo(connector),
            (_l = this.appKit) == null ? void 0 : _l.setApprovedCaipNetworksData(this.chainNamespace)
          ]);
          if (connector) {
            this.syncConnectedWalletInfo(connector);
          }
          if (!isAuthConnector && (addresses == null ? void 0 : addresses.length)) {
            (_m = this.appKit) == null ? void 0 : _m.setAllAccounts(addresses.map((addr) => ({ address: addr, type: "eoa" })), this.chainNamespace);
          }
        } else if (status === "reconnecting") {
          (_n = this.appKit) == null ? void 0 : _n.setLoading(true);
          const connectors = getConnectors(this.wagmiConfig);
          const currentConnector = connectors.find((c) => c.id === connector.id);
          if (currentConnector) {
            await reconnect(this.wagmiConfig, {
              connectors: [currentConnector]
            });
            (_o = this.appKit) == null ? void 0 : _o.setLoading(false);
          }
        }
      }
    }
  }
  async syncNetwork(address, chainId, isConnected) {
    var _a, _b, _c, _d, _e;
    const caipNetwork = this.caipNetworks.find((c) => c.id === chainId);
    if (caipNetwork && chainId) {
      (_a = this.appKit) == null ? void 0 : _a.setCaipNetwork(caipNetwork);
      if (isConnected && address && chainId) {
        const caipAddress = `eip155:${chainId}:${address}`;
        (_b = this.appKit) == null ? void 0 : _b.setCaipAddress(caipAddress, this.chainNamespace);
        if ((_c = caipNetwork == null ? void 0 : caipNetwork.blockExplorers) == null ? void 0 : _c.default.url) {
          const url = `${caipNetwork.blockExplorers.default.url}/address/${address}`;
          (_d = this.appKit) == null ? void 0 : _d.setAddressExplorerUrl(url, this.chainNamespace);
        } else {
          (_e = this.appKit) == null ? void 0 : _e.setAddressExplorerUrl(void 0, this.chainNamespace);
        }
        await this.syncBalance(address, chainId);
      }
    }
  }
  async syncReownName(address) {
    var _a, _b, _c;
    if (!this.appKit) {
      throw new Error("syncReownName - appKit is undefined");
    }
    try {
      const registeredWcNames = await this.appKit.getReownName(address);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        (_a = this.appKit) == null ? void 0 : _a.setProfileName(wcName.name, this.chainNamespace);
      } else {
        (_b = this.appKit) == null ? void 0 : _b.setProfileName(null, this.chainNamespace);
      }
    } catch {
      (_c = this.appKit) == null ? void 0 : _c.setProfileName(null, this.chainNamespace);
    }
  }
  async syncProfile(address, chainId) {
    var _a, _b, _c, _d, _e, _f;
    if (!this.appKit) {
      throw new Error("syncProfile - appKit is undefined");
    }
    try {
      const { name, avatar } = await this.appKit.fetchIdentity({
        address
      });
      (_a = this.appKit) == null ? void 0 : _a.setProfileName(name, this.chainNamespace);
      (_b = this.appKit) == null ? void 0 : _b.setProfileImage(avatar, this.chainNamespace);
      if (!name) {
        await this.syncReownName(address);
      }
    } catch {
      if (chainId === mainnet.id) {
        const profileName = await getEnsName(this.wagmiConfig, { address, chainId });
        if (profileName) {
          (_c = this.appKit) == null ? void 0 : _c.setProfileName(profileName, this.chainNamespace);
          const profileImage = await getEnsAvatar(this.wagmiConfig, {
            name: profileName,
            chainId
          });
          if (profileImage) {
            (_d = this.appKit) == null ? void 0 : _d.setProfileImage(profileImage, this.chainNamespace);
          }
        } else {
          await this.syncReownName(address);
          (_e = this.appKit) == null ? void 0 : _e.setProfileImage(null, this.chainNamespace);
        }
      } else {
        await this.syncReownName(address);
        (_f = this.appKit) == null ? void 0 : _f.setProfileImage(null, this.chainNamespace);
      }
    }
  }
  async syncBalance(address, chainId) {
    var _a, _b, _c, _d, _e;
    const caipNetwork = this.caipNetworks.find((c) => c.id === chainId);
    if (caipNetwork && this.wagmiConfig) {
      const balance = await getBalance(this.wagmiConfig, {
        address,
        chainId,
        token: (_c = (_b = (_a = this.options) == null ? void 0 : _a.tokens) == null ? void 0 : _b[caipNetwork.caipNetworkId]) == null ? void 0 : _c.address
      });
      (_d = this.appKit) == null ? void 0 : _d.setBalance(balance.formatted, balance.symbol, this.chainNamespace);
      return;
    }
    (_e = this.appKit) == null ? void 0 : _e.setBalance(void 0, void 0, this.chainNamespace);
  }
  async syncConnectedWalletInfo(connector) {
    var _a, _b, _c, _d;
    if (!connector) {
      throw Error("syncConnectedWalletInfo - connector is undefined");
    }
    if (connector.id === ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID && connector.getProvider) {
      const walletConnectProvider = await connector.getProvider();
      if (walletConnectProvider.session) {
        (_b = this.appKit) == null ? void 0 : _b.setConnectedWalletInfo({
          ...walletConnectProvider.session.peer.metadata,
          name: walletConnectProvider.session.peer.metadata.name,
          icon: (_a = walletConnectProvider.session.peer.metadata.icons) == null ? void 0 : _a[0]
        }, this.chainNamespace);
      }
    } else {
      const wagmiConnector = (_c = this.appKit) == null ? void 0 : _c.getConnectors().find((c) => c.id === connector.id);
      (_d = this.appKit) == null ? void 0 : _d.setConnectedWalletInfo({
        name: connector.name,
        icon: connector.icon || this.appKit.getConnectorImage(wagmiConnector)
      }, this.chainNamespace);
    }
  }
  syncConnectors(_connectors) {
    var _a;
    const connectors = _connectors.map((connector) => ({ ...connector, chain: this.chainNamespace }));
    const uniqueIds = /* @__PURE__ */ new Set();
    const filteredConnectors = connectors.filter((item) => {
      const isDuplicate = uniqueIds.has(item.id);
      uniqueIds.add(item.id);
      return !isDuplicate;
    });
    const w3mConnectors = [];
    filteredConnectors.forEach(({ id, name, type, icon }) => {
      var _a2, _b;
      const shouldSkip = ConstantsUtil3.AUTH_CONNECTOR_ID === id;
      if (!shouldSkip) {
        w3mConnectors.push({
          id,
          explorerId: PresetsUtil.ConnectorExplorerIds[id],
          imageUrl: ((_b = (_a2 = this.options) == null ? void 0 : _a2.connectorImages) == null ? void 0 : _b[id]) ?? icon,
          name: PresetsUtil.ConnectorNamesMap[id] ?? name,
          imageId: PresetsUtil.ConnectorImageIds[id],
          type: PresetsUtil.ConnectorTypesMap[type] ?? "EXTERNAL",
          info: {
            rdns: id
          },
          chain: this.chainNamespace
        });
      }
    });
    (_a = this.appKit) == null ? void 0 : _a.setConnectors(w3mConnectors);
  }
  async syncAuthConnector(_authConnector) {
    var _a;
    const connector = _authConnector;
    if (connector) {
      const provider = await connector.getProvider();
      (_a = this.appKit) == null ? void 0 : _a.addConnector({
        id: ConstantsUtil3.AUTH_CONNECTOR_ID,
        type: "AUTH",
        name: "w3mAuth",
        provider,
        chain: this.chainNamespace
      });
      this.initAuthConnectorListeners(_authConnector);
    }
  }
  async initAuthConnectorListeners(_authConnector) {
    if (_authConnector) {
      await this.listenAuthConnector(_authConnector);
      await this.listenModal(_authConnector);
    }
  }
  async listenAuthConnector(connector, bypassWindowCheck = false) {
    var _a, _b;
    if (bypassWindowCheck || typeof window !== "undefined" && connector) {
      (_a = this.appKit) == null ? void 0 : _a.setLoading(true);
      const provider = await connector.getProvider();
      const isLoginEmailUsed = provider.getLoginEmailUsed();
      (_b = this.appKit) == null ? void 0 : _b.setLoading(isLoginEmailUsed);
      provider.onRpcRequest((request) => {
        var _a2, _b2;
        if (W3mFrameHelpers.checkIfRequestExists(request)) {
          if (!W3mFrameHelpers.checkIfRequestIsSafe(request)) {
            (_a2 = this.appKit) == null ? void 0 : _a2.handleUnsafeRPCRequest();
          }
        } else {
          (_b2 = this.appKit) == null ? void 0 : _b2.open();
          console.error(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
            method: request.method
          });
          setTimeout(() => {
            var _a3;
            (_a3 = this.appKit) == null ? void 0 : _a3.showErrorMessage(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
          }, 300);
          provider.rejectRpcRequests();
        }
      });
      provider.onRpcError(() => {
        var _a2, _b2, _c, _d;
        const isModalOpen = (_a2 = this.appKit) == null ? void 0 : _a2.isOpen();
        if (isModalOpen) {
          if ((_b2 = this.appKit) == null ? void 0 : _b2.isTransactionStackEmpty()) {
            (_c = this.appKit) == null ? void 0 : _c.close();
          } else {
            (_d = this.appKit) == null ? void 0 : _d.popTransactionStack(true);
          }
        }
      });
      provider.onRpcSuccess((_, request) => {
        var _a2, _b2, _c;
        const isSafeRequest = W3mFrameHelpers.checkIfRequestIsSafe(request);
        if (isSafeRequest) {
          return;
        }
        if ((_a2 = this.appKit) == null ? void 0 : _a2.isTransactionStackEmpty()) {
          (_b2 = this.appKit) == null ? void 0 : _b2.close();
        } else {
          (_c = this.appKit) == null ? void 0 : _c.popTransactionStack();
        }
      });
      provider.onNotConnected(() => {
        var _a2, _b2, _c;
        const isConnected = (_a2 = this.appKit) == null ? void 0 : _a2.getIsConnectedState();
        const connectedConnector = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_CONNECTOR);
        const isConnectedWithAuth = connectedConnector === "AUTH";
        if (!isConnected && isConnectedWithAuth) {
          (_b2 = this.appKit) == null ? void 0 : _b2.setCaipAddress(void 0, this.chainNamespace);
          (_c = this.appKit) == null ? void 0 : _c.setLoading(false);
        }
      });
      provider.onIsConnected(() => {
        provider.connect();
      });
      provider.onConnect((user) => {
        var _a2, _b2, _c, _d, _e;
        const caipAddress = `eip155:${user.chainId}:${user.address}`;
        (_a2 = this.appKit) == null ? void 0 : _a2.setCaipAddress(caipAddress, this.chainNamespace);
        (_b2 = this.appKit) == null ? void 0 : _b2.setSmartAccountDeployed(Boolean(user.smartAccountDeployed), this.chainNamespace);
        (_c = this.appKit) == null ? void 0 : _c.setPreferredAccountType(user.preferredAccountType, this.chainNamespace);
        (_d = this.appKit) == null ? void 0 : _d.setAllAccounts(user.accounts || [
          {
            address: user.address,
            type: user.preferredAccountType || "eoa"
          }
        ], this.chainNamespace);
        StorageUtil.setConnectedConnector("AUTH");
        (_e = this.appKit) == null ? void 0 : _e.setLoading(false);
      });
      provider.onGetSmartAccountEnabledNetworks((networks) => {
        var _a2;
        (_a2 = this.appKit) == null ? void 0 : _a2.setSmartAccountEnabledNetworks(networks, this.chainNamespace);
      });
      provider.onSetPreferredAccount(({ address, type }) => {
        var _a2;
        if (!address) {
          return;
        }
        (_a2 = this.appKit) == null ? void 0 : _a2.setPreferredAccountType(type, this.chainNamespace);
        if (this.wagmiConfig) {
          reconnect(this.wagmiConfig, { connectors: [connector] });
        }
      });
    }
  }
  async listenModal(connector) {
    const provider = await connector.getProvider();
    this.subscribeState((val) => {
      if (!val.open) {
        provider.rejectRpcRequests();
      }
    });
  }
};
export {
  WagmiAdapter,
  authConnector
};
//# sourceMappingURL=@reown_appkit-adapter-wagmi.js.map
